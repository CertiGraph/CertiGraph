\texttt{MST-KRUSKAL}(\textit{G},\textit{w})
\newline
A = $\varnothing$
\newline
for each vertex \textit{v} $\in$ \textit{G.V}
\newline
$\hspace*{4mm}$ \texttt{MAKE-SET}(\textit{v})
\newline
sort the edges of \textit{G.E} into nonincreasing order by weight w
\newline
for each edge \textit{(u,v)} $\in$ \textit{G.E}, taken in nonicreasing order by weight
\newline
$\hspace*{4mm}$if \texttt{FIND-SET}(\textit{u}) $\neq$ \texttt{FIND-SET}(\textit{v})
\newline
$\hspace*{8mm}$\textit{A} = \textit{A} $\cup$ {\textit{(u,v)}}
\newline
$\hspace*{8mm}$\texttt{UNION}(\textit{u},\textit{v})
\newline
return \textit{A}
\begin{center}Abstract Kruskal's algorithm from CLRS~\cite{clrs}
\end{center}

\subsection{Edge list representation, multi-graph trimming, and subtle differences of graphs in different representations}
Kruskal's algorithm differs from Prim's and even Dijkstra's in that it directly operates on the edges of the input graph, rather than the latter two's vertex-based approaches. Consequently, in C implementations it is useful to pass the graph in as a list of graph edges, rather than an adjacency matrix or list. This also simplifies the sorting necessary in Kruskal's.
\newline\newline
We define a separate spatial representation of graphs as an edge list, and observe slight differences between the graphs that can be represented by an edge list and an adjacency-matrix representation. As mentioned in the Prim's section, in a symmetric adjacency matrix, $(u,v)$ and $(v,u)$ are considered the same edge; however, this is not true for an edge list, where a list can contain $(u,v)$ and $(v,u)$, even multiple copies of them. We do not prove the latter case for convenience reasons, but prove the former, to demonstrate the difference between an edge list representation and adjacency matrix representation.
\newline
\begin{lstlisting}
struct edge {
	int weight;
	int src;
	int dst;
};

struct graph {
	int V; //number of vertices {0...V-1}
	int E; //number of edges in the edgelist
	struct edge *edge_list;
};
//Consider a graph with edges {weight=1,src=0,dst=1}
//	and {weight=2,src=1,dst=0}
\end{lstlisting}
\begin{center}
\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={ circle}]
	\node[state] (V0) {$V0$};
	\node[state] (V1) [right=of V0] {$V1$};
	\path (V0) edge [bend left] node[above=0.15 cm] {$\{1,V0,V1\}$} (V1);
	\path (V1) edge [bend left] node[below=0.15 cm] {$\{2,V1,V0\}$} (V0);
\end{tikzpicture}
\end{center}
\begin{center}
Example of one kind of multi-graph representable by the above C edge-list implementation, which we have verified that Kruskal's algorithm is able to prune. We did not verify the case where another possible edge $\{2,V0,V1\}$ is in the edge list, for convenience
\end{center}

\subsection{Reusing previously verified union-find} %%why is there such an absurdly large space?
Kruskal's algorithm requires a union-find data structure to keep track of the state of connectedness in the graph. We made use of one of our previously verified union-find implementations. The union-find data structures were represented by their own specialized graph, denoted \texttt{UFGraph} within the kruskal verification.
\newline\newline
However, as the verified union-find implementations had no client using them until now, we discovered that the postconditions of using the union-find structures were difficult to use for Kruskal's verification. Kruskal's algorithm uses union-find to track the connectedness of vertices. However, the union-find implementations were verified prior to the introduction of such undirected graph properties, and thus were not designed with connectedness in mind. To that end, my research partner Anshuman has extended lemmas about the results of union and find operations as an analog to connectivity.
\newline\newline
We are pleased to say that no change was required for the existing union-find definitions, lemmas, specifications and verification. Instead, we proved that the postcondition of any of our union-find implementations, yields an analog to connectivity in undirected graphs. In other words, the verified postcondition was satisfactory, and just required translation into what we wanted in the context of Kruskal's.
\newline\newline
We mention this to emphasise the modularity and buildability of VST and CertiGraph infrastructure, that we were able to use previously, independently proven code in a bigger system later. The verification and internal details of the union-find system are furthermore independent from that of Kruskal's, whose proof only required the preconditions and postconditions of whichever union-find implementation we decided to use.