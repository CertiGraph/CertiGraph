\subsection{Graph definition in CertiGraph}

We first present the definition of a graph in CertiGraph. As mentioned in Wang et al~\cite{DBLP:journals/pacmpl/WangCMH19}, our graph library makes three types of graphs - \textit{PreGraph}, \textit{LabeledGraph} and \textit{GeneralGraph}, each built on top of the previous.
\begin{lstlisting}
Record PreGraph {EV: EqDec Vertex eq} {EE: EqDec Edge eq} := {
	vvalid : Ensemble Vertex;
	evalid : Ensemble Edge;
	src : Edge -> Vertex;
	dst : Edge -> Vertex
}.

Record LabeledGraph {DV DE DG: Type} := {
	pg_lg: PreGraph;
	vlabel: Vertex -> DV;
	elabel: Edge -> DE;
	glabel: DG
}.

Record GeneralGraph {DV DE DG: Type}
	{P: @LabeledGraph DV DE DG -> Type} := {
		lg_gg: @LabeledGraph DV DE DG;
		sound_gg: P lg_gg
}.
\end{lstlisting}
In our library, a graph has the four following basic functions: $vvalid$ which determines which vertices are valid in the graph; $evalid$ which determines which edges are valid in the graph, and two functions $src$ and $dst$ to map each edge to vertices. For example, an edge $e$ in graph $g$ pointing from vertex $u$ to $v$ will have $src$ $g$ $e$ $=$ $u$ and $dst$ $g$ $e$ $=$ $v$. What these functions actually are, is defined during the actual construction of a graph.
\newline\newline
It is important to note that although the primary purpose of an edge is to connect two vertices, we do not necessarily represent them as conventional ordered or unordered pairs. The vertices that an edge joins are determined by $src$ and $dst$, but the edge itself can be something else - a pointer value, for instance, providing a link between two nodes in the program heap. For the purposes of this paper, we do restrain them to ordered pairs for simplicity.
\newline\newline
It is important to note that an $evalid$ edge does not mean its $src$ and $dst$ vertices are valid - that is, a valid edge may not connected valid vertices. This is part of CertiGraph's design, to capture the idea of "dangling" edges such as dangling pointers to no-longer-valid memory blocks. The standard idea of a valid edge is captured by $strong\_evalid$, which states that not only is an edge $evalid$ in the graph, but its $src$ and $ds$ vertices are also $vvalid$. We will see below in the definition of forests the difference between a $strong\_evalid$ edge and a merely $evalid$ edge.

\subsection{Making a directed graph library reason about undirected graphs}

As a result of this definition, the graphs defined in our library are effectively directed - each valid edge in the graph has a clear direction defined by the $src$ and $dst$ functions. This makes sense for our previous use cases, especially when reasoning about C pointers.
\newline\newline
The issue is how then to reason about undirected graphs in a library whose graphs are directed by design. Undirected graphs are generally treated as a separate kind of graph from directed graphs - for example, CLRS distinguishes them based on whether their edges are ordered or unordered. However, even if edges are defined as an unordered pair, $src$ and $dst$ will grant the edge an implicit direction.
\newline\newline
The most naive idea is to consider undirected edges as a separate category from directed edges - introduce a new \texttt{Ensemble} for undirected edges. This has the benefit of reasoning with multigraphs if necessary. However, as most of our use cases are either directed or undirected, it would be unwieldy for a graph to have to maintain ensembles of both directed and undirected edges when it would never use one kind. Furthermore, it requires us to recreate many fundamental operations for manipulating undirected edges, ignoring the already robust suite of lemmas we have for $evalid$, $src$ and $dst$.
\newline\newline
Instead of this approach, we decided to rely on the observation that \textit{every directed graph can be treated as an undirected graph} by simply ignoring the directions of the edges. That is, we can assert that a graph in our library, directed by default, holds certain undirected graph properties. This is backed by our observation that undirected graph properties are largely mathematical in nature and, depending on the representation have few to no spatial requirements. Furthermore, there is no overlap in their properties - using a directed graph as an undirected graph, and claiming that it holds a certain undirected property, does not affect its directed properties. It also allows us to use our rich set of directed-graph lemmas about the addition and removal of edges.

\subsection{Undirected graph properties}

Here we give a quick explanation of the main undirected definitions and properties we're interested in. Our definitions are largely based on CLRS~\cite{clrs}.
\newline\newline
Let $g$ be a graph. A valid edge $e$ in $g$ is an adjacent edge (or \textit{adj\_edge} for short) of valid vertices $u$ and $v$ if those are its $src$ and $dst$. $u$ and $v$ are \textit{adjacent} if such an edge exists in $g$.
\begin{lstlisting}
Definition adj_edge (g: PreGraph V E) (e: E) (u v: V) :=
	strong_evalid g e /\
	((src g e = u /\ dst g e = v) \/ (src g e = v /\ dst g e = u)).

Definition adjacent (g: PreGraph V E) (u v: V) :=
	exists e: E, adj_edge g e u v.
\end{lstlisting}
A similar approach is proposed in Halsbeck~\cite{DBLP:journals/afp/HaslbeckLB19}.
\newline\newline
A valid undirected path, or \textit{upath}, in $g$ is a list of vertices such that each vertex in the list is adjacent with the subsequent vertex. An empty path, $nil$, is by default a valid $upath$. A singleton path $[v]$ is also a valid $upath$ if $v$ is a valid vertex.
\begin{lstlisting}
Fixpoint valid_upath (g: PreGraph V E) (p: upath) : Prop :=
match p with
| nil => True
| u :: nil => vvalid g u
| u :: ((v :: _) as p') => adjacent g u v /\ valid_upath g p'
end.
\end{lstlisting}
Two vertices $u$ and $v$ are \textit{connected by p} if $p$ is a valid $upath$ in $g$ with the head vertex $u$ and last vertex $v$. They are \textit{connected} if such a $upath$ exists. By the above, every valid vertex in $g$ is trivially connected to itself.
\begin{lstlisting}
Definition connected_by_path (g: PreGraph V E) (p: upath) (n : V) :=
	fun n' => valid_upath g p /\
		hd_error p = Some n /\ last_error p = Some n'.

Definition connected (g: PreGraph V E) (n : V) :=
	fun n' => exists p, connected_by_path g p n n'.
\end{lstlisting}
An undirected cycle, or $ucycle$, is a $upath$ whose first and last vertices are the same. A $simple$ $upath$ is a valid $upath$ that has no duplicate vertices - no vertex is visited twice. A $simple$ $ucycle$ is a cycle whose tail has no duplicate vertices - the only "duplicates" in the cycle are the first and last vertices.
\newline\newline
Note that the definition of path varies between textbooks and papers. For example, \textit{Discrete Mathematics and its Applications}~\cite{rozen} define paths as a sequence of edges with an implicit sequence of vertices, whereas CLRS, which we have followed, defines it as a sequence of vertices with an implicit sequence of edges.

\subsection{Defining forests before trees}

CLRS defines a tree as "a (connected) graph with no simple undirected cycles" - in other words, a connected, acyclic graph. We use the same definition:
\begin{lstlisting}
Definition uforest g:=
	(forall e, evalid g e -> strong_evalid g e) /\
	(forall p l, $\neg$ simple_ucycle g p l).
\end{lstlisting}
Our definition contains two propositions. The first constrains a forest to have no excess, "dangling" edges. Although our graph library needs to reason about such edges, we do not want to tolerate them in our forests. The second is the key "no simple undirected cycles".
\begin{center}
	\begin{tikzpicture} [auto, node distance =1.5 cm and 1.5cm ,on grid, semithick, state/.style ={ circle}]
		\node[state] (V0) {$V0$};
		\node[state] (V1) [right=of V0] {$V1$};
		\node[state] (V2) [below=of V0] {$V2$};
		\node[state] (?1) [above=of V0] {$?$};
		\node[state] (?2) [right=of V1] {$?$};
		\node[state] (?3) [below right=of ?2] {$?$};
		\path (V0) edge node[above=0.15 cm] {$5$} (V1);
		\path (V0) edge node[left=0.15 cm] {$6$} (V2);
		\path (V0) edge node[left=0.15 cm] {$-1$} (?1);
		\path (?2) edge node[above right=0.15 cm] {$2$} (?3);
	\end{tikzpicture}
	\newline
	The above is not a forest, due to the "garbage" edges (? being a placeholder for invalid vertices)
\end{center}
We highlight a difference in our definition compared to mathematical textbooks. Prim's and Kruskal's algorithms are presented as minimum-spanning \textit{tree} algorithms, and often have the implicit assumption that the graph is fully connected. They may or may not discuss forests - CLRS does not, while \textit{Discrete Mathematics} informally defines forests as ``graphs containing no simple circuits that are not necessarily connected [...] and have the property that each of their connected components is a tree." In short, these sources define forests from ``bottom-up" using trees. Our ``top-down" approach, however, recognises forests as acyclic graphs, and trees as a special case of forests where every vertex is connected to each other. This is also observed by Lammich et al~\cite{DBLP:journals/afp/LammichN19}.
\begin{lstlisting}
Definition connected_graph (g: PGraph) :=
	forall u v, vvalid g u -> vvalid g v -> connected g u v.

Definition utree g := uforest g /\ connected_graph g.
\end{lstlisting}
\paragraph{Exploring alternative definitions.} We explored a more complicated definition of an undirected forest using the idea of unique simple paths: ``Any two connected vertices have a unique simple path between them". This definition is more appropriate for edged-based path definitions like in \textit{Discrete Mathematics}, rather than vertex-based paths like in CLRS. Indeed, we found that by itself, ``unique simple vertex-based paths" allows for self-loops and cycles formed by multiple edges between the same vertices, which we have to further constrain, resulting in a more complicated definition. We proved its equivalence in our library.
\begin{lstlisting}
Definition uforest' g :=
	(forall e, evalid g e -> strong_evalid g e) /\
	(*no self-loops*)
		(forall e, evalid g e -> src g e <> dst g e) /\
	(*one edge between two vertices*)
 		(forall u v e1 e2, adj_edge g e1 u v /\
		adj_edge g e2 u v -> e1 = e2)
	/\ unique_simple_upath g.

Lemma uforest'_uforest: forall g, uforest' g -> uforest g.

Lemma uforest_uforest': forall g, uforest g -> uforest' g.
\end{lstlisting}