\texttt{MST-PRIM}(\textit{G},\textit{w},\textit{r})
\newline
for each \textit{u} $\in$ \textit{G.V}
\newline
$\hspace*{4mm}$\textit{u.key} = \texttt{INF}
\newline
$\hspace*{4mm}$\textit{u.}$\pi$ = \texttt{NIL}
\newline
\textit{r.key} = 0
\newline
\textit{Q} = \textit{G.V}
\newline
while \textit{Q} $\neq$ 0
\newline
$\hspace*{4mm}$\textit{u} = \texttt{EXTRACT-MIN}(\textit{Q})
\newline
for each \textit{v} $\in$ \textit{G.Adj[u]}
\newline
$\hspace*{4mm}$if \textit{v} $\in$ \textit{Q} and \textit{w(u,v)} $<$ \textit{v.key}
\newline
$\hspace*{8mm}$\textit{v.}$pi$ = \textit{u}
\newline
$\hspace*{8mm}$\textit{v.key} = \textit{w(u,v)}
\begin{center}Abstract Prim's algorithm from CLRS~\cite{clrs}. Note that \texttt{EXTRACT-MIN} is not explicitly defined
\end{center}

\subsection{Undirected adjacency matrix representation}

We chose a symmetrical matrix representation for the undirected graph to be used in Prim's algorithm. While other representations such as adjacency lists may be more efficient in terms of complexity, we chose this as a demonstration of matrix representations.
\newline\newline
The adjacency matrix bears similarities to that of Dijkstra's. We note several properties a graph must have in order to be represented as an adjacency matrix, such as that every edge is $strong\_evalid$, and that every weight is bounded by a limit in C.
\newline\newline
We observe a mild quirk in the symmetrical matrix representation. In our graphs, which are fundamentally directed, the edges $(u,v)$ and $(v,u)$ where $u \neq v$ are clearly distinct from each other, but it is not clear which edge is in the graph from the matrix, where both $g[u][v]$ and $g[v][u]$ are marked. To disambiguate, we impose the following condition: If $g[u][v]$ and $g[v][u]$ is marked, and $u \leq v$, then we consider $(u,v)$ to be the valid edge; if $v \textless u$, then $(v,u)$ is the valid edge.
\newline\newline
Thus, we consider that that the input graph in matrix form does \textit{not} have multiple edges between two vertices. If these assumptions were untrue in another representation, then such information will be lost when the graph is translated to the symmetric matrix. We will see later in Section 4 that another form of graph representation allows both $(u,v)$ and $(v,u)$ to be accepted as distinct undirected edges, even multiple $(u,v)$s, in contrast to the symmetric matrix.
\newline\newline
This minor discussion serves to highlight mathematical limitations of different graph representations, which are often not discussed beyond operational complexity.

\subsection{Modification (or lack thereof) to return a forest}

Textbook discussions of Prim's algorithm are often limited to the case where the input graph is a connected graph - fitting, as the primary purpose is to introduce the concept of minimum-spanning \textit{tree} algorithms. However, they do not expand on the subject of spanning forests for disconnected graphs. CLRS does not mention the case of disconnected graphs. \textit{Discrete Mathematics and Its Applications}~\cite{rozen} leaves it as an exercise to the reader. \textit{The Algorithm Design Manual, Second Edition}~\cite{DBLP:books/daglib/0022194} suggests Boruvkaâ€™s algorithm, and a combination with Prim's for complexity. \textit{Graph Algorithms in the Language of Linear Algebra}~\cite{kepnergilbert} suggests running Prim's on each component of the disconnected graph to obtain a minimum spanning forest. The last appears to be the most common solution, with lectures and practical implementations suggesting this.
\newline\newline
We observed that our code is able to return a minimum spanning forest when the input graph is disconnected \textit{in a single run}. The reason for this is: We treat a vertex of weight \texttt{INF} and a vertex's membership in the priority queue as \textit{separate} matters - a vertex can be in the priority queue with weight \texttt{INF}, and therefore can be popped. Thus, during the priority queue's emptiness check and the \texttt{EXTRACT-MIN} call, our implementation can return a vertex with weight \texttt{INF}. \texttt{key[u] = INF} means that \texttt{u} is \textit{not} connected to any previously popped vertex; otherwise its weight would have been previously lowered. Thus, \texttt{u} can be treated as the "root" of a new component, and the inner loop of Prim's subsequently proceeds to operate on \textit{its} adjacent vertices.
\newline
\begin{center}
\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
\node[state] (V0) {$V0=r$};
\node[state] (V1) [right=of V0] {$V1$};
\node[state] (V2) [below=of V0] {$V2$};
\node[state] (V3) [below right=of V0] {$V3$};
\node[color=green] (V4) [right=of V3] {$V4$};
\node[color=green] (V5) [right=of V4] {$V5$};
\draw[color=red] (V0) edge [ultra thick] node[above=0.15 cm] {$5$} (V1);
\path (V0) edge node[left=0.15 cm] {$6$} (V2);
\path (V0) edge [thin] node[above right=0.05 cm] {$5$} (V3);
\path[color=red] (V1) edge [ultra thick] node[right=0.15 cm] {$5$} (V3);
\path[color=red] (V2) edge [ultra thick] node[below=0.15 cm] {$4$} (V3);
\path (V4) edge node[below=0.15 cm] {$1$} (V5);
\end{tikzpicture}
\newline
Figure of a partial Prim's execution, with root $r = V0$. At this point, a spanning tree for the left component has been found; while $V4$ and $V5$ are in the priority queue with weight \texttt{INF}. As our \texttt{EXTRACT-MIN} tolerates \texttt{INF}, our implementation will pop $V4$ from the priority queue and proceed as usual, instead of terminating and requesting a second run of Prim's on the right component.
\newline
\end{center}
Is our assumption reasonable? We believe so, because the general algorithm in CLRS makes no claim about the relation between \texttt{INF} and the priority queue. Considering that the algorithm creates the priority queue with the vertices having initial weight \texttt{INF}, it is reasonable to say the priority queue can tolerate \texttt{INF}. Doing so simplifies \texttt{EXTRACT-MIN} to a pop operation using the priority queue's API, without requiring further checks for \texttt{INF}.
\newline\newline
Consequently, our code allows a simple implementation of Prim's to return a forest for a disconnected input graph, in a single run of the algorithm without needing to identify the disconnected components beforehand. It is important to note that we do not explicitly define ``components", nor do we tag u as a``"new root". It is sufficient to prove that the loop invariant is satisfied whether \texttt{key[u] < INF} or \texttt{key[u] = INF}.
\newline\newline
In our review of textbook graph algorithms, we observe that \textit{Algorithms in a Nutshell}~\cite{heineman2008algorithms} provides a C++ example that aligns with our C implementation. They push their version of \texttt{INF} into the priority queue during the setup, and do not perform any explicit rejections of \texttt{INF}, simply popping from the priority queue at the \texttt{EXTRACT-MIN} step. However, they do not discuss minimum spanning forests, hence this observation is not recorded.
\newline\newline
Note that the priority queue used for this verification is still tied to \texttt{INF}, and thus in the verification our argument is weakened to "\texttt{INF} is a valid weight in the priority queue" rather than "membership in the priority queue is independent of \texttt{INF}". Work on a stronger priority queue which completely dissociates from \texttt{INF} was being done by our supervisor, and remains incomplete as of the submission of this paper.
\newline\newline
A further observation is that in this version, the input root required by Prim's is no longer necessary. The root's key is artificially set to 0 in Prim's, which kickstarts the main loop. However, since our emptiness check and \texttt{EXTRACT-MIN} implementation can return vertices with \texttt{INF} weight, the loop will proceed as long as there are un-popped vertices. Thus, we suggest it is possible to remove the \texttt{rt} parameter. Doing so slightly simplifies the proof, because we do not have to reason about the artificially weighted \texttt{key[rt]}, as shown in \texttt{noroot\_prim.v}.
\newline\newline
	\texttt{MST-PRIM-NOROOT}(\textit{G},\textit{w})
	\newline
	for each \textit{u} $\in$ \textit{G.V}
	\newline
	$\hspace*{4mm}$\textit{u.key} = \texttt{INF}
	\newline
	$\hspace*{4mm}$\textit{u.}$\pi$ = \texttt{NIL}
	\newline
	\textit{Q} = \textit{G.V}
	\newline
	while \textit{Q} $\neq$ 0
	\newline
	$\hspace*{4mm}$\textit{u} = \texttt{POP-MIN}(\textit{Q})
	\newline
	for each \textit{v} $\in$ \textit{G.Adj[u]}
	\newline
	$\hspace*{4mm}$if \textit{v} $\in$ \textit{Q} and \textit{w(u,v)} $<$ \textit{v.key}
	\newline
	$\hspace*{8mm}$\textit{v.}$pi$ = \textit{u}
	\newline
	$\hspace*{8mm}$\textit{v.key} = \textit{w(u,v)}
	\begin{center}Example abstract Prim's algorithm without root, and relying on Q's \texttt{POP-MIN}
	\end{center}

\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
	\node[state, color=red] (V0) {$V0=r$};
	\node[state] (V1) [right=of V0] {$V1$};
	\node[state] (V2) [below=of V0] {$V2$};
	\node[state] (V3) [below right=of V0] {$V3$};
	\path[color=green] (V0) edge node[above=0.15 cm] {$5$} (V1);
	\path[color=green] (V0) edge node[left=0.15 cm] {$6$} (V2);
	\path[color=green] (V0) edge node[above right=0.05 cm] {$5$} (V3);
	\path (V1) edge node[right=0.15 cm] {$5$} (V3);
	\path (V2) edge node[below=0.15 cm] {$4$} (V3);
\end{tikzpicture}

\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
	\node[state, color=red] (V0) {$V0=r$};
	\node[state, color=red] (V1) [right=of V0] {$V1$};
	\node[state] (V2) [below=of V0] {$V2$};
	\node[state] (V3) [below right=of V0] {$V3$};
	\path[color=red] (V0) edge [ultra thick] node[above=0.15 cm] {$5$} (V1);
	\path (V0) edge node[left=0.15 cm] {$6$} (V2);
	\path (V0) edge node[above right=0.05 cm] {$5$} (V3);
	\path (V1) edge node[right=0.15 cm] {$5$} (V3);
	\path (V2) edge node[below=0.15 cm] {$4$} (V3);
\end{tikzpicture}

\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
	\node[state,color=red] (V0) {$V0=r$};
	\node[state,color=red] (V1) [right=of V0] {$V1$};
	\node[state] (V2) [below=of V0] {$V2$};
	\node[state,color=red] (V3) [below right=of V0] {$V3$};
	\path[color=red] (V0) edge [ultra thick] node[above=0.15 cm] {$5$} (V1);
	\path (V0) edge node[left=0.15 cm] {$6$} (V2);
	\path (V0) edge [thin] node[above right=0.05 cm] {$5$} (V3);
	\path[color=red] (V1) edge [ultra thick] node[right=0.15 cm] {$5$} (V3);
	\path (V2) edge node[below=0.15 cm] {$4$} (V3);
\end{tikzpicture}

\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
	\node[state,color=red] (V0) {$V0=r$};
	\node[state,color=red] (V1) [right=of V0] {$V1$};
	\node[state] (V2) [below=of V0] {$V2$};
	\node[state,color=red] (V3) [below right=of V0] {$V3$};
	\path[color=red] (V0) edge [ultra thick] node[above=0.15 cm] {$5$} (V1);
	\path (V0) edge node[left=0.15 cm] {$6$} (V2);
	\path (V0) edge [thin] node[above right=0.05 cm] {$5$} (V3);
	\path[color=red] (V1) edge [ultra thick] node[right=0.15 cm] {$5$} (V3);
	\path[color=red] (V2) edge [ultra thick] node[below=0.15 cm] {$4$} (V3);
\end{tikzpicture}