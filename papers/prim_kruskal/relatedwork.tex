\subsection{Previous work}

In Section 1, we have discussed Wang et al's development and use of CertiGraph to verify graph algorithms and graph-related data structures. We have explained the use of these previous algorithms in our implementation of Kruskal's.

\subsection{Related work}
In 2019, Lammich et al provided a verification of Prim's and Dijkstra's algorithms~\cite{DBLP:journals/afp/LammichN19}. Haslbeck et al, with Lammich in the same team, verified Kruskal's algorithm in a separate paper~\cite{DBLP:journals/afp/HaslbeckLB19}. The main highlights of their papers are writing efficient data structures in Isabelle/HOL and extracting them to executable code. In the Kruskal's paper, they took the same approach as we did in defining forests: That a forest is an acyclic graph, and a tree is a connected forest. In their paper on Prim's and Dijkstra's, the case of forests was not discussed.
\newline\newline
Guttman formalised and proved the correctness of Prim's algorithm using Stone relation and Kleene algebras in Isabelle/HOL~\cite{DBLP:conf/ictac/Guttmann16}. They later generalised minimum spanning tree algorithms using Stone relation algebras~\cite{DBLP:journals/jlp/Guttmann18}, and provided a verified proof of Kruskal's algorithm formatted in their algebra. They do not require the development of explicit data structures such as priority-queues and union-find, as these are captured as equivalence relations in their algebra.
\newline\newline
Guttman observed in their later paper that their earlier proof of Prim's assumed that "every finite graph had a minimum spanning forest". Guttman proved this by relying on their later proof of Kruskal's. We use the same theorem in our proof of Prim's, but in our case, as Kruskal's was defined in the lower layers of our library, it is clunky to extract the minimum spanning forest returned in a VST specification back to the mathematical-layer. Thus, we provide a mathematical proof - by showing that every finite graph has a finite, nonempty list of spanning forests. Using each graph's sum of edge weights as a comparator, we prove that we can obtain a minimal element in the list, thus there exists a minimum spanning forest.
\newline\newline
In terms of graph verification libraries, Krishna et al~\cite{DBLP:conf/esop/KrishnaSW20} has developed a flow algebraic framework to reason about local and global properties of \textit{flow graphs} in the program heap. Their flow algebra, in which a graph is then defined in similar to Guttman's approach, is designed to mainly tackle local reasoning of global graphs in program heaps, tackling similar issues to Wang et al ~\cite{DBLP:journals/pacmpl/WangCMH19}, but in this paper, local reasoning is not required, and our explored graph representations and algorithms are also vastly different. Their flow algebra is said to be compatible with existing separation logics, although actual implementation and integration with SL tools appears to be an ongoing progress.
\newline\newline
We have reviewed both formal and informal sources, the former including textbooks cited in Sections 2 and 3, over their discussion of Prim's and Kruskal's algorithms. As mentioned, they often omit the forest case, and thus did not arrive at the forest-observation of Prim's we have discovered in this work.
\newline\newline
In terms of this paper's contribution, we maintain our specialty of focusing on verified C code, using proof assistants as the verification platform instead of the executable language itself. Yet at the same time, our graph library is capable of proving graph lemmas and theorems entirely in Coq. It is also \textit{not} restricted to ``clean", textbook graphs. We have also verified Prim's and Kruskal's algorithms with minimum spanning \textit{forests} in mind, rather than trees. Lastly, this work is an extension of our graph library, adding Prim's and Kruskal's to our repository of verified graph algorithms, rather than them being standalone proofs.

\subsection{Ongoing and future work.}
Our supervisor remains in the midst of implementing a more versatile, general priority queue, to replace the current array-based queue being used in Dijkstra's and Prim's algorithms.
\newline\newline
We have left the sorting algorithm used by Kruskal's as an axiomatised specification without providing matching C code. This was to be implemented by our supervisor using his aforementioned priority queue. Sorting algorithms in C are also being explored by the VST developers, in response to a C program verification challenge paper~\cite{DBLP:journals/corr/abs-1904-01009}. We have had limited discussion with them on generalizing their current work to sort C-structs, as their primary focus was on floats.
%%Anshuman and I may look into the development and verification of priority queues and sorting algorithms in C in general.
\newline\newline
A graph algorithm we considered verifying is topological sort, specifically the \texttt{tsort} program in coreutils. It is particularly challenging as it handles a graph of \textit{string} vertices, represented in custom, pointer-linked data structures. To begin considering its verification, one must first have verified specifications of string functions. Our search into formalization of string functions in C show that the last work on a verified C-string library was in 2006 by Artem Starostin~\cite{cstring} using Isabelle/HOL, in a different subvariant of ANSI C. The current VST repository has examples of some string functions, but they are not extensive enough for our purposes. Therefore, I think that the verification of a modern, compiler-compatible C-string library is not only an open area for development, but a necessity.
\newline\newline
With the above in mind, I intend to take a step back from graph algorithms, as I am interested in the development and verification of a library of commonly used C functions, effectively building towards a ``verified libc". I believe it is necessary for the development of C programs and systems with safety guarantees. %%Indeed, work towards these systems have recently bore fruit, such as the seL4 microkernel whose resilience to security attacks have been demonstrated in 2018. Thus, I believe this work will contribute to ensuring the safety and security of C programs.%%