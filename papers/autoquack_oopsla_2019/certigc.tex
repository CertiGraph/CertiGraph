Our certification of a garbage collector (GC) for the 
CertiCoq compiler serves to show that our techniques 
scale well beyond short toy programs. 

\hide{The GC is our most complicated example,
and we will discuss some of its key proofs, but the larger
point here is that we completed this certification using 
exactly the framework and principles we have discussed
thus far. 

We enjoyed significant code 
reuse from our prior certifications, and when we stated 
new lemmas for the GC, we filed them away at the appropriate
``layers'' so that they may be reused in the future.
}%end hide

\subsection{Background}
\label{sec:gcbackground}

The CertiCoq compiler \cite{certicoqwebsite} takes Gallina code to 
C-light, which it then compiles to assembly using CompCert \cite{leroy:compcert}.
CertiCoq provides garbage collection at
the C-light level in order to support Gallina's presumption of
infinite heap memory. 
Since CertiCoq aims to be end-to-end certified, the GC 
also needs certification.

The $12$-generation collector, written in the spirit of the OCaml GC, 
is relatively realistic and sophisticated, though by no means 
industrial-strength. 
Because CertiCoq borrows OCaml's model of representing blocks and 
values \cite{realworldocaml}, the GC must support features such as 
variable-length memory blocks, memory fields that may be boxed 
or unboxed and must be disambiguated at runtime, pointers to places 
outside the GC-managed heap, \note[expand later]{etc.}
The CertiCoq GC's task is a little easier than the OCaml GC's because 
its mutator is purely functional\footnote{Gallina is purely functional, and
the C-light code generated by CertiCoq preserves this behavior.
OCaml is partly imperative.},
meaning it does not mutate data. The mutator maintains an array of 
local variables, and the GC scans this array to 
calculate the root set. When called, the GC collects the first generation 
into the second using Cheney's algorithm \cite{cheney:gc}.
This collection may trigger the collection of the second genertation 
into the third, \emph{etc.}, and the GC completes this potential cascade 
of collections before returning control to the mutator. We put a 
fuller explanation of GC's operation in Appendix \ref{apx:gcstructure}.

The mutator's array of local variables features large in the specification 
of the GC. The GC must ensure that any memory blocks that the mutator 
could reach by recursively following those root variables \emph{before} the 
collection can still be reached, via the same steps, \emph{after} the collection.
This idea can be abstracted into mathematical graphs,
where the task reduces to showing graph isomorphism.

\subsection{From C to Mathematical Graphs}
\label{sec:movetomathgraph}
TODO

\subsection{Forward}
\label{sec:gcforward}
The GC's main workhorse is the function \emph{forward}.
Whenever we have mentioned any kind of copying in the preceeding 
discussion, we have always meant a call to \emph{forward}. 
Given a pointer, it checks that the pointer's target is a block
in the \emph{from} generation, and, if so, 
makes a copy of that block in the \emph{to} generation. 
{\color{magenta}The function 
is robust and versatile, and gets called in a variety of different 
situations.}

Figure \ref{fig:forward} shows a decorated proof of the forward function.
The function's behavior is subtly different depending on 
whether the the pointer $p$ lives in the arguments array or in the 
heap itself. The difference lies in lines \ref{dummyref} and \ref{dummyref}, where 
we wish to update $p$ to point to the new forwarded block. 
When $p$ lives in the arguments array, this update is easy to 
reason about since $p$ is $\bigstar$-separated from our heap. 
When $p$ is itself in the heap, this update itself constitutues a
write to the heap. In the decorated proof, we show the second 
case. To this end, we assume in line \ref{dummyref} that p is (todo). 

\input{forward_listing.tex}

\subsection{Issues}
\label{sec:gccsemantics}
\paragraph{Double-Bounded Pointer Comparisons.}
\paragraph{Pointer Subtraction.}
\paragraph{Block Alignment}

%\input{boundary.tex}