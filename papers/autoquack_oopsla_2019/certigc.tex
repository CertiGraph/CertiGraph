Our certification of a garbage collector (GC) for the 
CertiCoq compiler serves to show that our techniques 
scale well beyond short toy programs. 

\hide{The GC is our most complicated example,
and we will discuss some of its key proofs, but the larger
point here is that we completed this certification using 
exactly the framework and principles we have discussed
thus far. 

We enjoyed significant code 
reuse from our prior certifications, and when we stated 
new lemmas for the GC, we filed them away at the appropriate
``layers'' so that they may be reused in the future.
}%end hide

\subsection{Background}
\label{sec:gcbackground}

The CertiCoq compiler \cite{certicoqpaper} takes Gallina code to 
C-light, which it then compiles to assembly using CompCert \cite{leroy:compcert}.
CertiCoq provides garbage collection at
the C-light level in order to support Gallina's presumption of
infinite heap memory. 
Since CertiCoq aims to be end-to-end certified, the GC 
also needs certification.

The $12$-generation collector, written in the spirit of the OCaml GC, 
is relatively realistic and sophisticated, though by no means 
industrial-strength. 
Because CertiCoq borrows OCaml's representation of blocks and 
values \cite{realworldocaml}, the GC must support features such as 
variable-length memory blocks, memory fields that may be boxed 
or unboxed and must be disambiguated at runtime, pointers to places 
outside the GC-managed heap, \note[expand later]{etc.}
The CertiCoq GC's task is a little easier than the OCaml GC's because 
its mutator is purely functional\footnote{Gallina is purely functional, and
the C-light code generated by CertiCoq preserves this behavior.
OCaml is partly imperative.},
meaning it does not mutate data. The mutator maintains an array of 
local variables, and the GC scans this array to 
calculate the root set. When called, the GC collects the first generation 
into the second using Cheney's algorithm \cite{cheney:gc}.
This collection may trigger the collection of the second genertation 
into the third, \emph{etc.}, and the GC completes this potential cascade 
of collections before returning control to the mutator. We put a 
fuller explanation of GC's operation in Appendix \ref{apx:gcstructure}.

The mutator's array of local variables, \code{args}, features large in the specification 
of the GC. The GC must ensure that the memory blocks that the mutator 
could reach by recursively following the fields of \code{args} \emph{before} the 
collection can still be reached, via the same steps, \emph{after} the collection.
This problem can be abstracted into mathematical graphs,
where we must prove graph isomorphism.

\subsection{From C to Mathematical Graphs}
\label{sec:movetomathgraph}
In the code, the information of 12 generations is stored as an
12-element array \texttt{heap}. Each generation, as a memory segment,
is represented as a \texttt{struct} \texttt{space}, which contains
three pointers: \texttt{start} marking the start address of a
generation, \texttt{next} representing the next available address in a
generation, and \texttt{limit} marking the last address of a
generation. The basic unit manipulated by the garbage collector is a
piece of memory called block. The size of a block is stored in its
head and the rest is an array of fields. Each field is either data or
a pointer to another block. Blocks with variant sizes are all stored
in generations without gaps.

From the perspective of the algorithm, the 12 generations can be seen
as a graph $\gamma$. Basically each block can be can be seen as a
vertex and pointers to other other block compose connections among
vertices. More foramlly, we decide to encode each vertex of this graph
as a pair of natural numbers $(v_g, v_i)$ which means the vertex is
the $v_i$th block in the $v_g$th generation. We also encode each edge
as a pair of vertex and index $(v, i)$ which means this edge is from
vectex $v$ and connects to the vertex which the pointer in the $i$th
field of $v$ points to. The source function always satisfies
$d(\gamma, (v, i)) = v$. The destination function $d$ actually stores
the connection information. Each vertex is attached a label which
contains the pure data items and indices of pointers in the
fields. There is also a global label of $\gamma$ which has the
start/limit addresses and number of vertices of each generation. We
can reconstruct the 12 generations in memory from $\gamma$ under this
setting without redundancy. For example, we can count the size of each
vertex according to its label. The sum of the sizes in each generation
is the occupied size of each generation. Adding up the occupied size
to the
\texttt{start} address retrieves the \texttt{next} pointer.

\hide
{\color{red} TODO

The graph model changed not at all. We added label to the whole graph. Quite happy to add this change to our model; it doesn't change the other proofs at all. We are genuinely not isomorphic so this label helps. 

What was challenging:
	- We were very aggressive in dealing with complex C-light code, right at the edge of undefined behavior
	- Interface between C-light and mathgraph... the top level theorems and forward are exploring the graph in a connected way, but do scan is making a linear array survey. We needed proofs about these two views being okay. Complex labels, edges, etc
	- Exposing these proofs to a compiler and making sure that the compiler's own invariants can use the GC. eg: compiler will never take an item from an older gen and point it to a newer gen.
}

\subsection{Forward}
\label{sec:gcforward}
The function \code{forward} is the GC's workhorse.
When correctly given the spaces \code{from} and \code{to} and a pointer 
\code{p} to a memory block in \code{from},
it carries out the atomic task of copying the memory block to the next
available location in the \code{to} space. 
The function is robust: if passed a ``pointer'' argument 
that is actually a data value, or that points outside of 
\code{from}, \note{it behaves appropriately by taking no action.} 
As we will see in \S\ref{sec:gcissues}, these checks are nontrivial. 
The function is also versatile: it is used to collect the 
mutator's \code{args} (which are $*$-separated from the heap) 
and also to collect the blocks \emph{in} the heap that are reachable via 
\code{args}. Its behavior needs to be subtly different in these
two cases.
Figure \ref{fig:forward} shows a decorated proof of \code{forward} 
in the second case, which is more challenging.

TODO: explain highlights of the code in Figure \ref{fig:forward}.

\input{forward_listing_short.tex}

\subsection{Issues} \label{sec:gcissues}

\subsubsection*{Bugs in the GC code.}
We discovered and fixed two bugs in the source code during our verification. 
The first had to do with taking the difference of pointers\footnote{This is commonly calculated by finding the 
raw byte-difference and dividing it by \texttt{\scriptsize wordsize} to get the word-difference.} 
to calculate the size of a space, as below. Pointers \code{start} and \code{limit} 
point at the beginning and end of the \code{i}$^{\text{th}}$ space of the
heap \code{h}. 

%\vspace{-1em}
\begin{lstlisting}[numbers=none]
  int w = h->spaces[i].limit - h->spaces[i].start;
\end{lstlisting}
%\vspace{-1em}

The pointers are known to be in 
the same memory block, so the subtraction is defined in C and C-light, but
we risk overflow in case the difference equals 
or exceeds $2^{31}$. This observation caused the size of the largest generation 
to be reconsidered. Second, we discovered a performance bug: the GC code 
originally executed Cheney's algorithm in an overly conservative manner, 
scanning the entire~\code{to} space for backward pointers into \code{from}. We
showed that scanning a subset of \code{to} suffices.

\subsubsection*{Double-Bounded Pointer Comparisons.}
As mentioned in \S\ref{sec:gcforward}, \code{forward} needs to 
check whether the pointer it is passed is actually in the \code{from}
space. It uses this function: 

%\vspace{-1em}
\begin{lstlisting}[numbers=none]
  int Is_from(value * from_start, value * from_limit, value * v) 
  {  return (from_start <= v && v < from_limit);  }
\end{lstlisting}
%\vspace{-1em}

As before, \code{start} and \code{limit} are in the same 
memory block. If \code{v} is also in the same block, \code{Is{\_}from} 
correctly computes whether it is in bounds.
However, if it is in a different block, the function returns undefined behavior instead of our obvious preference, \code{false}.
\note[needs Aquinas' eyes]{After a discussion with the CompCert team \cite{leroy_email}, we have used CompCert's ``extcall{\_}properties'' to show that the behavior we require 
of \code{Is{\_}from} is defined because the comparison is bounded above and below. 
This means that the function's somewhat delicate semantics will be preserved
by CompCert.}


\subsubsection*{Pointer Alignment}
{\color{red}TODO: leaving for Aquinas}
