%Our certification of a garbage collector (GC) for the
%CertiCoq compiler serves to show that our techniques
%scale well beyond short toy programs.

\hide{The GC is our most complicated example,
and we will discuss some of its key proofs, but the larger
point here is that we completed this certification using
exactly the framework and principles we have discussed
thus far.

We enjoyed significant code
reuse from our prior certifications, and when we stated
new lemmas for the GC, we filed them away at the appropriate
``layers'' so that they may be reused in the future.
}%end hide

\subsection{Background}
\label{sec:gcbackground}

The CertiCoq compiler \cite{certicoqpaper} translates Gallina code to
Clight, which CompCert compiles to assembly~\cite{leroy:compcert}.
CertiCoq's garbage collector (GC) is written in Clight and 
supports Gallina's assumption of infinite memory.
CertiCoq aims to be end-to-end certified, so the GC
must be too.

The $12$-generation collector, written in the spirit of the OCaml GC,
is relatively realistic and sophisticated, though by no means
industrial-strength.
Because CertiCoq borrows OCaml's representation of blocks and
values \cite{realworldocaml}, the GC must support features such as
variable-length memory objects, object fields that may be boxed
or unboxed and must be disambiguated at runtime, pointers to places
outside the GC-managed heap, etc.
The CertiCoq GC's task is a little easier than the OCaml GC's because
its mutator is purely functional\footnote{That is: Gallina is purely functional, and
the Clight code generated by CertiCoq preserves this behavior.}. 
The mutator maintains an \code{args} array of
local variables, which the GC scans to
calculate the root set. When called, the GC collects the first generation
into the second using Cheney's algorithm \cite{cheney:gc}.
This collection may trigger the collection of the second generation
into the third, etc., and the GC completes this potential cascade
before returning control to the mutator. A
fuller explanation of GC's operation is in Appendix \ref{apx:gcstructure}.

The mutator's \code{args} array of local variables is critical in the GC's specification. 
The GC must ensure that all memory objects that the mutator can reach by recursively 
following the fields of \code{args} \emph{before} the collection can still be reached, 
via the same steps, \emph{after} the collection.  This problem can be abstracted into 
mathematical graphs, where we must prove graph isomorphism.

\subsection{From C to Mathematical Graphs}
\label{sec:movetomathgraph}
In the code, the metainformation of the 12 generations is stored as an
12-element array \texttt{heap}. Each generation, as a memory segment,
is represented as a \texttt{struct} \texttt{space}, which contains
three pointers: \texttt{start} marking the start address of a
generation, \texttt{next} representing the next available address in a
generation, and \texttt{limit} marking the last address of a
generation. The basic unit manipulated by the garbage collector is a
chunk of memory called a block. Blocks can be of different sizes;
the size of a particular block is stored in its
header (at offset $-\m{sizeof}(\texttt{void*})$), and the remainder of the block 
is a continuous array of fields. 
Each field is either integer
data or a pointer to another block, disambiguated forcing all integers
to be odd and all pointers to be even.  

From the perspective of the algorithm, the 12 generations can be seen
as a graph $\gamma$. Each block can be can be seen as a
vertex and pointers to other blocks indicate edges between 
vertices. More formally, we decide to encode each vertex of this graph
as a pair of natural numbers $(v_g, v_i)$ which means the vertex is
the $v_i$th block in the $v_g$th generation. We encode each edge
as a pair of vertex and index $(v, i)$ which means this edge is from
vertex $v$ and the associated pointer is in the $i$th field of the
corresponding block.  The source function always satisfies
$\mathsf{src}(\gamma, (v, i)) = v$.
%The destination function $d$ 
%actually stores
%the connection information. 
Each vertex is labeled with the integer data items and the indices of pointers in the
fields. There is also a global label of $\gamma$ which has the
start/limit addresses and number of vertices of each generation. We
can reconstruct the 12 generations in memory from $\gamma$ under this
setting without redundancy. For example, to determine the \texttt{next} pointer of
a generation, we can sum the sizes of each vertex in that generation using its label,
and then add the \texttt{start} address.

\hide
{\color{red} TODO

The graph model changed not at all. We added label to the whole graph. Quite happy to add this change to our model; it doesn't change the other proofs at all. We are genuinely not isomorphic so this label helps.

What was challenging:
	- We were very aggressive in dealing with complex C-light code, right at the edge of undefined behavior
	- Interface between C-light and mathgraph... the top level theorems and forward are exploring the graph in a connected way, but do scan is making a linear array survey. We needed proofs about these two views being okay. Complex labels, edges, etc
	- Exposing these proofs to a compiler and making sure that the compiler's own invariants can use the GC. eg: compiler will never take an item from an older gen and point it to a newer gen.
}

\subsection{Forward}
\label{sec:gcforward}
The function \code{forward} is the GC's workhorse.
When correctly given the spaces \code{from} and \code{to} and a pointer
\code{p} to a memory block in \code{from},
it carries out the atomic task of copying the memory block to the next
available location in the \code{to} space.
The function is robust: if passed a ``pointer'' argument
that is actually a data value, or that points outside of
\code{from}, \note{it behaves appropriately by taking no action.}
As we will see in \S\ref{sec:gcissues}, these checks are nontrivial.
The function is also versatile: it is used to collect the
mutator's \code{args} (which are $*$-separated from the heap)
and also to collect the blocks \emph{in} the heap that are reachable via
\code{args}. Its behavior needs to be subtly different in these
two cases.
Figure \ref{fig:forward} shows a decorated proof of \code{forward}
in the second case, which is more challenging.

TODO: explain highlights of the code in Figure \ref{fig:forward}.

\input{forward_listing_short.tex}

\subsection{Issues} \label{sec:gcissues}

\subsubsection*{Bugs in the GC code.}
We discovered and fixed two bugs in the source code during our verification.
The first was a performance bug we discovered when developing the key invariants.
The original GC code executed Cheney's algorithm too conservatively,
scanning the entire~\code{to} space for backward pointers into \code{from}. We
showed that scanning a subset of \code{to} suffices.  Performance doubled.

The second bug was an overflow when subtracting two pointers
to calculate the size of a space, as below. Pointers \code{start} and \code{limit}
point to the beginning and end of the \code{i}$^{\text{th}}$ space of the
heap \code{h}.
%the difference of pointers\footnote{This is commonly calculated by finding the
%raw byte-difference and dividing it by \texttt{\scriptsize wordsize} to get the word-difference.}
%\vspace{-1em}
\begin{lstlisting}[numbers=none]
  int w = h->spaces[i].limit - h->spaces[i].start;
\end{lstlisting}
%\vspace{-1em}
%The pointers are known to be in
%the same memory block, so 
This subtraction is defined in C and Clight, but
will overflow if the difference equals
or exceeds~$2^{31}$. We adjusted the size of the largest generation to avoid this overflow.

\subsubsection*{Undefined behavior in C} %Double-Bounded Pointer Comparisons.}
We found two places where the semantics of Clight was unable to specify an OCaml-style GC.
The first involved double-bounded pointer comparisons.
As mentioned in \S\ref{sec:gcforward}, \code{forward} needs to
check whether the object it is considering, which it already knows to be a pointer,
is in fact pointing into the \code{from} space. It uses this function:
%\vspace{-1em}
\begin{lstlisting}[numbers=none]
  int Is_from(value * from_start, value * from_limit, value * v)
  {  return (from_start <= v && v < from_limit);  }
\end{lstlisting}
%\vspace{-1em}
Here, the \code{start} and \code{limit} pointers are in the same
memory block. If \code{v} is also in the same block, \code{Is{\_}from}
correctly computes whether it is in bounds.
However, if \code{v} is in a different block, the comparison gets stuck rather than 
returning \code{false}.
Although the Clight code is undefined, we used CompCert's ``extcall{\_}properties''
to prove that CompCert's compiler transformations will preserve the necessary invariants
because the comparison is bounded both above and below (in contrast, single-bounded 
comparisons need not be semantically preserved in CompCert).

\subsubsection*{Pointer Alignment}
{\color{red}TODO: leaving for Aquinas}

the CompCert team \cite{leroy_email}
