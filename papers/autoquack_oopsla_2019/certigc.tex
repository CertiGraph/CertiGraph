%Our certification of a garbage collector (GC) for the
%CertiCoq compiler serves to show that our techniques
%scale well beyond short toy programs.

\hide{The GC is our most complicated example,
and we will discuss some of its key proofs, but the larger
point here is that we completed this certification using
exactly the framework and principles we have discussed
thus far.

We enjoyed significant code
reuse from our prior certifications, and when we stated
new lemmas for the GC, we filed them away at the appropriate
``layers'' so that they may be reused in the future.
}%end hide


The CertiCoq compiler \cite{certicoqpaper} translates Gallina code to
Clight, which CompCert~\cite{leroy:compcert} then compiles to assembly.
Gallina assumes infinite heap memory but Clight has a 
finite heap, so
CertiCoq supports Gallina's assumption via 
memory management at the Clight level.
In particular, the Clight code generated by CertiCoq contains 
calls to a garbage collector (GC), also written in Clight. 
CertiCoq aims to be end-to-end certified, so the GC must also be certified.
We explain the code's operation~(\S\ref{sec:gcbackground}), 
abstract the problem to mathematical graphs~(\S\ref{sec:movetomathgraph}),
explain two key functions from the code~(\S\ref{sec:gcforward},~\S\ref{sec:gcdoscan}),
and review interesting issues we found and resolved~(\S\ref{sec:gcissues}).

\subsection{Overview of the GC Program}
\label{sec:gcbackground}

The $12$-generation GC, written in the spirit of the OCaml GC,
is realistic and sophisticated, though by no means
industrial-strength.
Because CertiCoq uses OCaml's representation of blocks and
values \cite{realworldocaml}, the GC must support features such as
variable-length memory objects, object fields that may be boxed
or unboxed and must be disambiguated at runtime, and pointers to places
outside the GC-managed heap.
That said, its task is easier than the OCaml GC's because
its mutator is purely functional\footnote{That is: Gallina is purely functional, and
the Clight code generated by CertiCoq preserves this behavior.}.
The mutator maintains an array of
local variables called \li{args}, and the GC scans this array to
calculate the root set. The GC collects the first generation
into the second using Cheney's algorithm \cite{cheney:gc}.
This may recursively trigger the collection of the second generation
into the third, \emph{etc.}, following which the GC returns control to the mutator. 
We provide further details about the GC's operation in 
our extended online paper.
% We put a 
% more detailed explanation of the GC's operation in Appendix~\ref{apx:gcstructure}.

The mutator's \li{args} array is critical to the GC's formal specification.
The heap may change dramatically, but all heap memory objects 
that the mutator could reach by recursively
following the fields of \li{args} \emph{before} the collection 
must still be reachable, via similar steps, \emph{after} the collection.  This problem can be abstracted 
into mathematical graphs, where we must prove graph isomorphism.

\subsection{From Clight to Mathematical Graphs}
\label{sec:movetomathgraph}
In the code, a generation is a contiguous memory segment. 
Three pointers capture key metainformation about a generation:
\li{start} marks the first address, \li{limit},
the last address, and \li{next}, the next address available for 
allocation.  
Initially, \li{next~=~start}. 
New memory is added in a contiguous chunk starting 
at \li{next}, and \li{next} is
incremented appropriately. 
The generation is full when \li{next~=~limit}.
Metainformation about all $12$ generations is stored in 
a 12-element array called \li{heap}.
	
The basic unit manipulated by the GC is a
contiguous piece of memory called a \emph{block}, which is a 
$22$-bit header followed by an arbitrary-length array of \emph{fields}.
The length of a block's field array is stored in its header.
Each field is either an unboxed integer data value or a pointer. 
To disambiguate the two,
we follow OCaml's practice of requiring that all integers are odd 
(essentially, are only 31 bits long) and all pointers are even-aligned~\cite{realworldocaml}. Pointers may point either into the GC-controlled heap or at external structures outside the GC's purview.
% to another block, disambiguated forcing all integers
%to be odd and all pointers to be even.

Moving towards a mathematical abstraction, the 12 generations can be seen
as a graph $\gamma$. Blocks are
vertices, and pointers to other blocks are edges to other
vertices. 
Vertices are tuples of the form~$(\m{g}, \m{i})$, meaning the vertex represents the 
the $\m{i}^{\textit{th}}$ block in the $\m{g}^{\textit{th}}$ generation. 
An edge is a tuple~$(\m{v}, i)$, meaning that 
the associated pointer is the $\m{i}^{\textit{th}}$ field of the block
corresponding to vertex~$\m{v}$. 
Each vertex is labeled with its integer data, along with 
metainformation such as whether it has already been forwarded, 
and if so, where its forwarded copy is.
There is also a global label on the entire graph $\gamma$ which has the
start/limit addresses and number of vertices of each generation. 
% \note[is this actually that clever?]{We
% can reconstruct the 12 generations in memory from $\gamma$ under this
% setting without redundancy. For example, to determine the \li{next} pointer of
% a generation, we can sum up the size of each vertex in that generation 
% by reading each vertex's label, and then add this sum to the \li{start} address.}

\hide
{\color{red} TODO

The graph model changed not at all. We added label to the whole graph. Quite happy to add this change to our model; it doesn't change the other proofs at all. We are genuinely not isomorphic so this label helps.

What was challenging:
	- We were very aggressive in dealing with complex C-light code, right at the edge of undefined behavior
	- Interface between C-light and mathgraph... the top level theorems and forward are exploring the graph in a connected way, but do scan is making a linear array survey. We needed proofs about these two views being okay. Complex labels, edges, etc
	- Exposing these proofs to a compiler and making sure that the compiler's own invariants can use the GC. eg: compiler will never take an item from an older gen and point it to a newer gen.
}

\subsection{Forward}
\label{sec:gcforward}
\input{forward_listing.tex}
The function \li{forward} is the GC's workhorse.
When correctly given the spaces \li{from} and \li{to} and a pointer
\li{p} to a memory block in \li{from},
it copies the memory block to the next
available location in the \li{to} space.
The function is robust: if passed a ``pointer'' argument
that is actually a data value, or is a pointer that points outside of
\li{from}, it behaves appropriately by taking no action.
As we will see in \S\ref{sec:gcissues}, these checks are nontrivial.
The function is also versatile: it is used to collect the
mutator's \li{args} (which are $*$-separated from the heap)
and also to collect the blocks \emph{in} the heap that are reachable via
\li{args}. Its behavior needs to be subtly different in these
two cases.
Figure~\ref{fig:forward} shows a decorated proof sketch of \li{forward}
in the latter case, which is harder to verify.

Two abstractions \li{struct} \li{thread\_inf}
and \li{file\_info}---\m{finf} and \m{tinf}---represent the 
graph's metainformation, and together allow us to
extract the \li{args} array. The
proposition \m{compat} encapsulates a series of checks, 
\emph{e.g.} to avoid out-of-bounds issues.
The arguments \li{s}, \li{l}, and \li{n} are straightforwardly
explained on line $1$. 
We are forwarding~\li{p}, 
which denotes the \m{n}th edge of vertex~\m{v}. 
For readability,
we denote the facts known to us in
\emph{e.g.} line~$1$ by $\phi_1$, and then use $\phi_1$
as a fact in later annotations.

Line \ref{code:alreadyforwarded} shows
the case when the block passed to the function was already forwarded.
The block's header is zeroed out and its $0^\textit{th}$ field holds
the address of its
copy\footnote{These guarantees are set up by \texttt{\scriptsize forward} itself.
Refer to lines \ref{code:zeroingheader} and
\ref{code:copyinfirstfield} of Figure~\ref{fig:forward} to see this being done straightforwardly.},
so we simply reroute to the copy. 
Line \ref{code:postconafterredirect} shows that this operation
gives us a new graph, 
$\gamma'~=~\m{upd\_edge}(\gamma, \m{e}, \m{copy}(\gamma, \m{v'}))$.
That is, in $\gamma$, update the edge $e$ to point at
$\m{copy}(\gamma, \m{v'})$. 
This delicate treatment avoids erroneous double-copying
in case a block is reachable from the \li{args} array via different paths.

Moving to the meatier case where we must actually make a copy,
lines \ref{code:copyhead} to \ref{code:copyfields} show
how a block is copied over to the next-available spot in the
\li{to} space. Some of the grungy details having to do with
variable-sized memory blocks begin to show up in the C code,
but the annotation on line~$27$ is relatively clean
thanks to our mathematical graph framework:
this is just the copying of a vertex, and so our new graph after the change is
$\gamma' = \m{copy\_vertex}(\gamma, \m{to}, \m{v'}, \m{v''})$.
Unlike the edit in line~\ref{code:alreadyforwarded}, which was
local to the graph proper, this
change spills over to the graph's metainformation:~\m{tinf'}, 
an alteration to \m{tinf}, explains that additional 
space is now used up in the \li{to} generation of~$\gamma'$. 
The final step (line \ref{code:ridirect}) is to reroute to this
new copy, and this is handled exactly as in line~\ref{code:alreadyforwarded}. 
The resultant graph is $\gamma'' = \m{upd\_edge}(\gamma', \m{e}, \m{v''})$. 
This edit is local to the graph, and so the old metainformation in~\m{tinf'} 
remains compatible with the new graph $\gamma''$.

The postcondition is a little different from those of \li{find}
and \li{mark} seen earlier: it does not provide a relation
saying that \li{forward} has acted in a functionally ``correct'' manner. 
Rather, it uses \m{forward\_relation} to carefully list the possible 
end results of calling
\li{forward} on \m{(v,n)} --- a vertex may be copied, an edge may be redirected, 
no action may be taken, \emph{etc.} --- and check if the graph
$\gamma'$ falls within one of them.
We put the complete definition
of \m{forward\_relation}, with its twelve constructors, 
% in Appendix~\ref{apx:forwardrelation}. 
in the extended online version of our paper.
We have such relations for all the key functions in our GC, 
and our final correctness proof shows that 
composing these relations together yields the high-level 
correctness property---a kind of graph isomorphism---that is required by CertiCoq.

\subsection{Do Scan}
\label{sec:gcdoscan}

To collect \li{from} into \li{to}, 
we first call the function \li{forward\_roots}, which calls \li{forward} 
on each item in the \li{args} array. 
Thus, no field of \li{args} points directly into \li{from}. 
However, the fields of \li{args} may still point into \li{from} \emph{indirectly}, 
via the direct links that we just forwarded into~\li{to}.
We fix this via the function 
\li{do\_scan}, which scans~\li{to} and calls 
\li{forward} on all items that were copied over as part of this collection.
This fixes any backwards pointers from \li{to} into \li{from} by moving
their targets into \li{to} as well.
These steps fully disentangle \li{args} from the 
\li{from} space, which can be reset to free up memory. 

\input{do_scan_listing.tex}

Figure~\ref{fig:doscan} contains a decorated proof sketch of \li{do\_scan}.
The precondition, given on line $1$, is very similar to that of 
\li{forward}. We have \li{st} and \li{li} denoting the boundaries
of the \li{from} space, and \li{nx} denoting the last-used address
in the \li{to} space. The key difference is that instead of a specific
target like~\li{p}, we take the argument \li{sc}, 
which is the place in the \li{to} space from where we must start \li{sc}anning.
Because of the way \li{forward} works, we know that the 
the items recently copied over by \li{forward\_roots} 
have been placed placed contiguously between \li{sc} and \li{nx}. 
Working from \li{sc} upwards, we ignore blocks that are tagged as 
``do not scan'', but otherwise simply call \li{forward} on every field
of each block. We benefit from \li{forward}'s robustness: we can trust it to 
take action only when the field passed to it actually points back into the 
\li{from} space. 
%In its working, \li{forward} is likely to change the \li{nx} 
%pointer, meaning that the guard of the \li{while} loop on 
%line~\ref{code:dswhile} is a moving target. This is intentional: 
%blah blah blah

The only use of \infrulestyle{localize} is when
reading the block header on line \ref{code:dsreadheader}, 
and this is not very different from the read seen in \li{forward}. 
Lines \ref{code:dshasfwdprecon} and \ref{code:dshasfwdpostcon} 
represent exactly the pre- and postconditions of \li{forward}
for some vertex \m{(s, j)}. 
After the for-loop, the entire block represented by~\m{s} has either been
forwarded (line \ref{code:dswholeblockfwded}) or 
ignored (line \ref{code:dswholeblockignored}). 
This may increment \li{nx}, so we continue until \li{sc~=~nx}.

At first glance, this verification may seem quite elementary. 
Its trickiness comes from the fact
that \li{do\_scan} operates exactly on the interface between the Clight code 
and the mathematical graph model introduced in ~\S\ref{sec:movetomathgraph}.
Functions like \li{forward} ignore the Clight memory representation 
of the heap and go about their business in the abstract domain
of mathematical graphs, but \li{do\_scan} cannot do this because grungy 
details such as the index order of runtime-allocated blocks are key to its strategy of a
linear search from \li{sc} to \li{nx}.

% Forward operates on the graph in a graph-theory sense, verices are neighbors and so on.
% Scan navigates it in a more systems-ey sense, ie the graph is basiclaly in malloc order, and neighbors and not necessarily beside each other, etc. Do-scan is navigatingh that boundary

\subsection{Performance and Overflows and Undefined Behaviours, Oh My!} \label{sec:gcissues}
\label{sec:gcissues}

\subsubsection*{Bugs in the GC code.}
We discovered and fixed two bugs in the source code during our verification.
The first was a performance bug we discovered when developing the key invariants.
The original GC code executed Cheney's algorithm too conservatively,
scanning the entire~\li{to} space for backward pointers into \li{from}. We
showed that scanning a subset of \li{to} suffices.  Performance doubled.
The second bug was an overflow when subtracting two pointers
to calculate the size of a space, as below. Here the pointers \li{start} and \li{limit}
point to the beginning and end of the \li{i}$^{\text{th}}$ space of the
heap \li{h}.
%the difference of pointers\footnote{This is commonly calculated by finding the
%raw byte-difference and dividing it by \li{\scriptsize wordsize} to get the word-difference.}
%\vspace{-1em}
\begin{lstlisting}[numbers=none]
  `\hl{int w = h->spaces[i].limit - h->spaces[i].start;}`
\end{lstlisting}
%\vspace{-1em}
%The pointers are known to be in
%the same memory block, so
This subtraction is defined in C and Clight, but
overflows if the difference equals
or exceeds~$2^{31}$. We adjusted the size of the largest generation to avoid this overflow.

\subsubsection*{Undefined behavior in C} %Double-Bounded Pointer Comparisons.}
We found two places where the semantics of Clight is unable to specify an OCaml-style GC such as ours.
The first area of undefined behavior results from our GC's use of the well-established
31-bit integer trick to allow both boxed and unboxed data in block fields~\cite{realworldocaml}.
To distinguish them, \li{forward} calls \li{Is\_block} ({\color{black} line~5}), which
in turn calls the following:
\begin{lstlisting}[numbers=none]
  `\hl{int test\_int\_or\_ptr (value x) \{ return (int)(((intnat)x)\&1); \}}`
\end{lstlisting}
This function aims to return $1$ if \li{x} is an int, and $0$ if it is an aligned pointer.
When \li{x} is an integer, this is indeed well-defined. 
But when \li{x} is a pointer, the code gets stuck because
taking the logical \li{and} of a pointer is undefined in Clight.
The second issue involves double-bounded pointer comparisons.
On line~\ref{code:isfrom} of Figure~\ref{fig:forward}, \li{forward} checks 
whether the object it is considering, which it already knows to be a pointer,
is in fact pointing into the \li{from} space.  The \li{forward} function uses the following:
%\vspace{-1em}
\begin{lstlisting}[numbers=none]
  `\hl{int Is\_from(value * from\_start, value * from\_limit, value * v) \{}`
    `\hl{return (from\_start <= v \&\& v < from\_limit); \}}`
\end{lstlisting}
%\vspace{-1em}
Here, the \li{start} and \li{limit} pointers are in the same
memory block. If \li{v} is also in the same block, \li{Is{\_}from}
correctly computes whether it is in bounds.
However, if \li{v} is in a different block, the comparison gets stuck---both halves 
of the conjunction are undefined---instead of
returning \li{false}.

Although the Clight code is undefined, we used CompCert's ``extcall{\_}properties''
to prove that CompCert's compiler transformations will preserve the necessary invariants
for both operations. Both operations require careful treatment.  The first operation 
requires that the \li{x} pointer is defined and has even offset within its memory block, 
\emph{and} that \li{x+1} is also defined.  This length-two requirement ensures that
\li{x} is not pointing to a stack-allocated local variable of type \li{char},
which CompCert can realign as it assembles the stack frame.  The second operation
is respected by CompCert because the pointer comparison is double-bounded (below by 
\li{from\_start} and above by \li{from\_limit}); in contrast, a single-bounded 
comparison need not be semantically preserved by CompCert.

Other than these two items, the GC is fully defined in Clight---we were even able to
prove that all casts (\emph{e.g.} line~\ref{code:dsreadheader}) are well-defined.
As a concluding thought, Coq itself is written in OCaml with a similar-style garbage 
collector. Thus, our GC is at least as well-defined as Coq itself.
