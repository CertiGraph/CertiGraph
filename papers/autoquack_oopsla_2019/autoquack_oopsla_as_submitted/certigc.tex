%Our certification of a garbage collector (GC) for the
%CertiCoq compiler serves to show that our techniques
%scale well beyond short toy programs.

\hide{The GC is our most complicated example,
and we will discuss some of its key proofs, but the larger
point here is that we completed this certification using
exactly the framework and principles we have discussed
thus far.

We enjoyed significant code
reuse from our prior certifications, and when we stated
new lemmas for the GC, we filed them away at the appropriate
``layers'' so that they may be reused in the future.
}%end hide

\subsection{Background}
\label{sec:gcbackground}

The CertiCoq compiler \cite{certicoqpaper} translates Gallina code to
Clight, which CompCert compiles to assembly~\cite{leroy:compcert}.
CertiCoq's garbage collector (GC) is written in Clight and 
supports Gallina's assumption of infinite memory.
CertiCoq aims to be end-to-end certified, so the GC
must be too.

The $12$-generation collector, written in the spirit of the OCaml GC,
is relatively realistic and sophisticated, though by no means
industrial-strength.
Because CertiCoq borrows OCaml's representation of blocks and
values \cite{realworldocaml}, the GC must support features such as
variable-length memory objects, object fields that may be boxed
or unboxed and must be disambiguated at runtime, pointers to places
outside the GC-managed heap, etc.
The CertiCoq GC's task is a little easier than the OCaml GC's because
its mutator is purely functional\footnote{That is: Gallina is purely functional, and
the Clight code generated by CertiCoq preserves this behavior.}. 
The mutator maintains an \code{args} array of
local variables, which the GC scans to
calculate the root set. When called, the GC collects the first generation
into the second using Cheney's algorithm \cite{cheney:gc}.
This collection may trigger the collection of the second generation
into the third, etc., and the GC completes this potential cascade
before returning control to the mutator. A
fuller explanation of GC's operation is in Appendix \ref{apx:gcstructure}.

The mutator's \code{args} array of local variables is critical in the GC's specification. 
The GC must ensure that all memory objects that the mutator can reach by recursively 
following the fields of \code{args} \emph{before} the collection can still be reached, 
via the same steps, \emph{after} the collection.  This problem can be abstracted into 
mathematical graphs, where we must prove graph isomorphism.

\subsection{From C to Mathematical Graphs}
\label{sec:movetomathgraph}
In the code, the metainformation of the 12 generations is stored as an
12-element array \code{heap}. Each generation, as a memory segment,
is represented as a \code{struct} \code{space}, which contains
three pointers: \code{start} marking the start address of a
generation, \code{next} representing the next available address in a
generation, and \code{limit} marking the last address of a
generation. The basic unit manipulated by the garbage collector is a
chunk of memory called a block. Blocks can be of different sizes;
the size of a particular block is stored in its
header (using 22 bits of the word stored at offset $-\m{sizeof}(\code{void*})$), and the remainder of the block is a continuous array of fields. 
Each field is either an unboxed integer data value, or a pointer, which may be
either within the GC or to external structures.  To disambiguate the two,
we follow OCaml's practice of requiring that all pointers are even-aligned and 
that all integers to be odd (essentially, to be only 31 bits long)~\cite{realworldocaml}.
% to another block, disambiguated forcing all integers
%to be odd and all pointers to be even.  

From the perspective of the algorithm, the 12 generations can be seen
as a graph $\gamma$. Each block can be can be seen as a
vertex and pointers to other blocks indicate edges between 
vertices. More formally, we decide to encode each vertex of this graph
as a pair of natural numbers $(\m{v}_g, \m{v}_i)$ which means the vertex is
the $\m{v}_i$th block in the $\m{v}_g$th generation. We encode each edge
as a pair of vertex and index $(\m{v}, i)$ which means this edge is from
vertex $v$ and the associated pointer is in the $i$th field of the
corresponding block.  The source function always satisfies
$\mathsf{src}(\gamma, (\m{v}, i)) = \m{v}$.
%The destination function $d$ 
%actually stores
%the connection information. 
Each vertex is labeled with the integer data items and the indices of pointers in the
fields. There is also a global label of $\gamma$ which has the
start/limit addresses and number of vertices of each generation. We
can reconstruct the 12 generations in memory from $\gamma$ under this
setting without redundancy. For example, to determine the \code{next} pointer of
a generation, we can sum the sizes of each vertex in that generation using its label,
and then add the \code{start} address.

\hide
{\color{red} TODO

The graph model changed not at all. We added label to the whole graph. Quite happy to add this change to our model; it doesn't change the other proofs at all. We are genuinely not isomorphic so this label helps.

What was challenging:
	- We were very aggressive in dealing with complex C-light code, right at the edge of undefined behavior
	- Interface between C-light and mathgraph... the top level theorems and forward are exploring the graph in a connected way, but do scan is making a linear array survey. We needed proofs about these two views being okay. Complex labels, edges, etc
	- Exposing these proofs to a compiler and making sure that the compiler's own invariants can use the GC. eg: compiler will never take an item from an older gen and point it to a newer gen.
}

\subsection{Forward}
\label{sec:gcforward}
The function \code{forward} is the GC's workhorse.
When correctly given the spaces \code{from} and \code{to} and a pointer
\code{p} to a memory block in \code{from},
it copies the memory block to the next
available location in the \code{to} space.
The function is robust: if passed a ``pointer'' argument
that is actually a data value, or that points outside of
\code{from}, it behaves appropriately by taking no action.
As we will see in \S\ref{sec:gcissues}, these checks are nontrivial.
The function is also versatile: it is used to collect the
mutator's \code{args} (which are $*$-separated from the heap)
and also to collect the blocks \emph{in} the heap that are reachable via
\code{args}. Its behavior needs to be subtly different in these
two cases.
Figure~\ref{fig:forward} shows a decorated proof sketch of \code{forward}
in the latter case, which is harder to verify. 

Two abstractions of \code{struct} \code{thread\_inf}
and \code{file\_info}---\m{finf} and \m{tinf}---together allow us to
extract the mutator's \code{args} array, and The
proposition \m{super\_compatible} encapsulates various checks
about \emph{e.g.} legal bounds that avoid some overflow issues.  For
concision, the facts known to us in
\emph{e.g.} line $1$ are represented by $\phi_1$, and then $\phi_1$ 
can feature as a fact \emph{e.g.} in line $8$. 

Line \ref{code:alreadyforwarded} shows
the case when the block passed to the function was already forwarded.
This may seem strange, but is vital because the same block may be 
reachable from the \code{args} via different paths.
Such a block's header is zeroed out and its $0$th field holds 
the address of its 
copy\footnote{These guarantees are set up by \code{forward} itself. 
Refer to lines \ref{code:zeroingheader} and 
\ref{code:copyinfirstfield} of Figure~\ref{fig:forward} to see this being done.}, 
so we simply reroute to that copy. 
Line \ref{code:postconafterredirect} shows that this operation 
gives us a new graph, $\gamma'=\m{upd\_edge}(\gamma, \m{e}, \m{copy}(\gamma, \m{v'}))$.
This means to reroute the edge $e$ in $\gamma$ and make it point at
$\m{copy}(\gamma, \m{v'})$.

Lines \ref{code:copyhead} to \ref{code:copyfields} show
how a block is copied over to the next-available spot in the 
\code{to} space. Some of the grungy details having to do with
variable-sized memory blocks being to show up in the C code,
but the verification looks relatively clean 
thanks to our mathematical graph framework.
This is just the copying of a vertex, and so our new graph after the change is
$\gamma' = \m{copy\_vertex}(\gamma, \m{to}, \m{v'}, \m{v''})$. 
The final step (line \ref{code:ridirect}) is to reroute to this 
new copy, and this is done just as in line~\ref{code:alreadyforwarded}. The
resultant graph is $\gamma'' = \m{upd\_edge}(\gamma', \m{e}, \m{v''})$.

The postcondition is a little different from those of \code{find}
and \code{mark} seen earlier, in that it does not provide a relation
saying that \code{forward} has been functionally correct. Rather, we
defined the relation to reflect the result of operations
in \code{forward}, such as a vertex is copied, an edge is redirected,
and etc,. For a taste, we put the complete definition
of \m{forward\_relation} in Appendix~\ref{apx:forwardrelation}. We
have relations of this sort for all the key functions in our GC, and
we show that the composition of these correctly corresponds to the C
code of our garbage collector. The final functional correctness is
derived from these relations.

\input{forward_listing_short.tex}

\subsection{Performance and Overflows and Undefined Behaviours, Oh My!} \label{sec:gcissues}

\subsubsection*{Bugs in the GC code.}
We discovered and fixed two bugs in the source code during our verification.
The first was a performance bug we discovered when developing the key invariants.
The original GC code executed Cheney's algorithm too conservatively,
scanning the entire~\code{to} space for backward pointers into \code{from}. We
showed that scanning a subset of \code{to} suffices.  Performance doubled.

The second bug was an overflow when subtracting two pointers
to calculate the size of a space, as below. Pointers \code{start} and \code{limit}
point to the beginning and end of the \code{i}$^{\text{th}}$ space of the
heap \code{h}.
%the difference of pointers\footnote{This is commonly calculated by finding the
%raw byte-difference and dividing it by \texttt{\scriptsize wordsize} to get the word-difference.}
%\vspace{-1em}
\begin{lstlisting}[numbers=none]
  int w = h->spaces[i].limit - h->spaces[i].start;
\end{lstlisting}
%\vspace{-1em}
%The pointers are known to be in
%the same memory block, so 
This subtraction is defined in C and Clight, but
will overflow if the difference equals
or exceeds~$2^{31}$. We adjusted the size of the largest generation to avoid this overflow.

\subsubsection*{Undefined behavior in C} %Double-Bounded Pointer Comparisons.}
We found two places where the semantics of Clight was unable to specify an OCaml-style GC.
The first involved double-bounded pointer comparisons.
As mentioned in \S\ref{sec:gcforward}, \code{forward} needs to
check whether the object it is considering, which it already knows to be a pointer,
is in fact pointing into the \code{from} space. It uses this function:
%\vspace{-1em}
\begin{lstlisting}[numbers=none]
int Is_from(value * from_start, value * from_limit, value * v) {
  return (from_start <= v && v < from_limit); }
\end{lstlisting}
%\vspace{-1em}
Here, the \code{start} and \code{limit} pointers are in the same
memory block. If \code{v} is also in the same block, \code{Is{\_}from}
correctly computes whether it is in bounds.
However, if \code{v} is in a different block, the comparison gets stuck rather than 
returning \code{false}.
Although the Clight code is undefined, we used CompCert's ``extcall{\_}properties''
to prove that CompCert's compiler transformations will preserve the necessary invariants
because the comparison is bounded both above and below (in contrast, single-bounded 
comparisons need not be semantically preserved in CompCert).

The second area of undefined behavior results from our GC's use of the well-established
31-bit integer trick to allow both boxed and unboxed data in block fields~\cite{realworldocaml}.
To distinguish them, \texttt{forward} calls \texttt{Is\_block} ({\color{red} line~5}), which
in turn calls
\begin{lstlisting}[numbers=none]
int test_int_or_ptr (value x) /* returns 1 if int, 0 if aligned ptr */ {
    return (int)(((intnat)x)&1); }
\end{lstlisting}
When \texttt{x} is an int, this is indeed well-defined, but it is undefined to take the
logical and of a pointer, so the code again gets stuck.  Here the situation is messier,
since CompCert does \textbf{not} guarantee that the alignment of a pointer is stable during 
compilation: in particular, stack-allocated local variables of type \texttt{char} may be packed
tightly while assembling the stack frame, thus shifting their alignment.  Informally, of course,
this cannot occur in the GC since we do not store stack-allocated local variables in the GC-managed
heap.  We have discussed this issue with the CompCert team \cite{leroy_email}, and believe that
a stronger specification of the extcall{\_}properties (essentially, guaranteeing that non-\texttt{char} pointers do not change alignment) should allow us to prove that CompCert
will respect \texttt{test\_int\_or\_ptr}'s behavior.  The CompCert team understands the 
issue~{\color{red}\cite{where}} and wants OCaml-style GCs to have defined behavior in Clight.

Other than these two items, the GC is fully defined in Clight---we were even able to 
prove that all casts (\emph{e.g.} {\color{red} line~6}) were well-defined.
As a concluding thought, Coq itself is written in OCaml with a similar-style garbage collector.
Thus, our GC is at least as well-defined as Coq itself.
