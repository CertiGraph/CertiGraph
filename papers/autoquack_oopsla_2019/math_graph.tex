\hide{
In order to verify the functional correctness of graph
algorithms, we need to first reason about mathematical graphs.
Our graph library is powerful and expressive, allowing 
us to verify realistic algorithms that work in an end-to-end
system. One of its strengths is its modularity, 
which allows us to intuitively reuse and compose our proofs when
mechanising our verifications. In this section, we present our 
mathematical graph framework with an emphasis on this modularity. 
{\color{magenta} We continue to use Union-Find from }
} % end hide

When verifying the functional correctness of graph algorithms, 
we intuitively wish to borrow terminology from graph theory to describe
program behavior. Accordingly, an essential component of our
work is a library of formalized graph theory which is powerful and
expressive enough to verify realistic algorithms that 
\note[what do you mean?]{work in an
end-to-end system}. One of its strengths is its modularity, which
allows us to intuitively reuse and compose proofs when mechanising 
verifications. In this section, we present our mathematical graph
framework with an emphasis on this modularity.  
\hide{\color{magenta} We continue to use Union-Find from
\S\ref{sec:orientation} as our motivating example.} % end hide

% saving old version just in case...
\hide{As will be shown in \S\ref{sec:development}, our mathematical
graph constructions comprise a considerable fraction of our
codebase. Indeed, as discussed in \S\ref{sec:related},
25 years of research into mechanized graph theory can
be summarized as ``it is a little tricky''. 
First, as demonstrated in \S\ref{sec:orientation},
our development is expressive and powerful enough to verify realistic
algorithms---that is, it actually works in an end-to-end system.
Second, we have taken considerable care to develop a modular and
general-purpose framework for such mathematical graphs to allow
such verifications to be mechanized without undue pain.
Accordingly, in this section we will present our framework
at a high level to communicate the overall architecture rather
than focusing on the nitty-gritty details.} % end hide

\subsection{Definitions of graphs}\label{sec:mathinfra}

\input{mathgraph_pregraph_combined.tex}
%\input{mathgraph_structure.tex}
%\input{pregraph_figure.tex}

Our first challenge is that graph theory is usually based on 
\emph{set theory} but our formalization in Coq has
to be based on \emph{type theory}. We choose to formalize graph theory
directly in Coq instead of formalizing set theory and then building
graph theory atop it. This allows us to take advantage of Coq's built-in
support for type-related constructions directly for graphs. 
\note[what do you mean?]{Like other
mathematical theories,} our formalized graph theory is developed
around its core concept: graph. To balance the dichotomy between
the generality and the speciality of the library, we divide the
concept of graph into three structures, 
PreGraph, LabeledGraph and GeneralGraph, arranged in a hierarchy. 
Figure~\ref{fig:graphs} shows the
architecture of the library.

\hide{The most basic kind of graph is PreGraph, out of which we build 
LabeledGraph, and which in turn are used
to build GeneralGraphs. Each kind has some lemmas and also inherits the lemmas of the 
previous kind.  The dashed box represents a ``plugin'' system for attaching arbitrary 
properties to LabeledGraphs (\ref{subsec:graphplugins}). %and will be discussed later. 
%We will consider each in turn.
} % end hide

\hide{
\paragraph{PreGraph.} A PreGraph is a hextuple $(VT, ET, V, E, s, d)$, where $VT$ 
and $ET$ are the underlying carrier sets of vertices and edges, and $V$ and $E$, 
subsets $VT$ and $ET$ respectively, introduce the notion of \emph{validity} in the 
graph. In Figure \ref{fig:pregraph}, valid vertices are in $V$ and 
invalid vertices are in $VE \smallsetminus V$. Importantly, 
both kinds of vertices are legally part 
of the PreGraph. Finally, $s$ and $d$ are functions that map 
an edge to its source and destination respectively; 
{\color{orange}this means that PreGraphs model directed graphs.}
With an eye to flexibility, we make no further 
requirements of a legal PreGraph, not even a specific notion 
of how the four sets are related.
Indeed, the PreGraph in Figure \ref{fig:pregraph} contains invalid 
vertices and edges in an arbitrary configuration.
}% end hide

\paragraph{PreGraph.} A PreGraph is a hextuple $(\mathcal{V}, \mathcal{E}, V, 
E, s, d)$, where $\mathcal{V}$ and $\mathcal{E}$ are the underlying
carrier types of vertices and edges, and $V$ and $E$, predicates over
$\mathcal{V}$ and $\mathcal{E}$ respectively, introduce the notion
of \emph{validity} in the graph. Finally, $s$ and $d$ are functions
that map an edge to its $s$ource and $d$estination. With an 
eye to flexibility, we make
no further requirements of a legal PreGraph.

The benefits of introducing validity are twofold. The first is a 
neat resolution of the incompatibility between type theory and set theory. 
In set theory, one
element can belong to multiple sets, \emph{e.g.}\ 
\note[explain a little More?]{to a subset or a superset.} 
Adding or removing vertices or edges is therefore easy: we alter
the set directly to represent the result of the operation. 
In type theory, however, a term can only belong
to one type, which makes it difficult\hide{if not impossible} 
to analogously change the
type to represent the result. As is common practice, we introduce the
predicates $V$ and $E$ to classify vertices and edges as \emph{valid}
(in) or \emph{invalid} (out) of a graph. The equivalent of a superset/subset 
behavior can be replicated by weakening or strengthening the two predicates.

The other benefit is the ability to represent incomplete graphs, which is
convenient in verification.  
\note[fix numbering]{Figure \ref{fig:pregraph}} shows an incomplete graph, 
where vertices $v_0$ and $v_1$
are the source and destination of a valid edge $e_0$. Both 
vertices are in $\mathcal{V}$, but $v_0$ is valid
and $v_1$ is not, meaning $v_1$ is not in the
graph. Drawing $v_1$ in Figure \ref{fig:pregraph} only indicates 
that $d(e_0) = v_1$. 
Incomplete graphs of this sort are needed, \emph{e.g.}, by programs
that traverse selective portions of graphs and manipulate them under 
certain criteria. 
After the traversal, the graph $g$ can be partitioned into two parts: the subgraph
$g_1$, which is composed of vertices and edges processed by the algorithm, 
and the residue $g_2$, which is the difference $g - g_1$. In
the specification of the program, it may be necessary to state that 
$g_2$ is unchanged. However, $g_2$ is not guaranteed to be a ``well-formed''
graph in the conventional sense:
if $g$ is an undirected graph,
$g_2$ is just a collection of \note[disconnected?]{connected} components, 
and if $g$ is a directed graph, then $g_2$ may contain dangling edges or
vertices. PreGraph is accommodating enough to permit reasoning
about~$g_2$ in either case.

We define some primary graph concepts on PreGraphs, 
including structures like \emph{path}, predicates 
such as \emph{is\_cyclic} and \emph{reachable},
operation/functions such as \emph{add\_vertex}
and \emph{remove\_edge}, and relations between PreGraphs such
as \emph{structurally\_identical} and \emph{subgraph}.  These general
concepts, together with derived lemmas (around 750 in total) provide a
solid foundation for more specific theorems needed in concrete
verifications.

\hide{
In {\color{magenta}Figure \ref{fig:pregraph}}, valid vertices satisfy
$V$ and invalid vertices are just of type $VT$ but do not satisfy
$V$. Importantly, both kinds of vertices are legally part of the
PreGraph. Finally, $s$ and $d$ are functions that map an edge to its
source and destination respectively; {\color{orange}this means that
PreGraphs model directed graphs.}  With an eye to flexibility, we make
no further requirements of a legal PreGraph, not even a specific
notion of how the four sets are related.  Indeed, the PreGraph in
Figure \ref{fig:pregraph} contains invalid vertices and edges in an
arbitrary configuration.

Many graph concepts such as \emph{path}, \emph{reachability}, and \emph{subgraph} are 
defined on PreGraphs. In \S\ref{fig:find} we saw \emph{reachable}, written
{\color{orange}
$\m{a} \mathrel{{\stackrel{\gamma~}{\leadsto^{1}}}} \m{b}$. It means that a and b are in $V(\gamma)$ and that there exists an edge (in $E(\gamma)$)
that goes from a to b.}
The reflexive, transitive closure on \emph{reachable} is written 
$\m{a} \mathrel{{\stackrel{\gamma~}{\leadsto^{\star}}}} \m{b}$, and 
$\neg (\m{a} \mathrel{{\stackrel{\gamma~}{\leadsto^{\star}}}} \m{b})$ 
is written $\m{a} \mathrel{{\stackrel{\gamma~}{\not\leadsto^{\star}}}} \m{b}$.

PreGraph's ability to reason about missing vertices and edges is convenient when 
verifying real programs. Suppose some $\gamma$ satisfied some stronger notion of
``well-formed'', in the sense that valid vertices have only valid edges and 
vice versa. Could we then subtract some vertices and edges from it and reason about the 
resulting structure? This is precisely what we needed to do in \ref{fig:find}, where
we argued for a condition of congruence on 
$\gamma \smallsetminus (v \in \gamma \mid \m{x} 
\mathrel{{\stackrel{\gamma~}{\leadsto^{\star}}}} \m{v})$. 
A strong notion of well-formedness may have stopped us short at this point, 
declaring the structure ill-formed because of the dangling edges 
pointing to recently-removed vertices. 
A PreGraph is more accommodating, since
it produces a fresh PreGraph after this selective subtraction 
and then allows us to go ahead and reason about congruence as we need to.
}%end hide

\hide{
For example, consider the difference of two graphs, $\gamma_1
- \gamma_2$.  Even if both of these graphs are ``well-formed'' to begin with, in the 
sense that valid vertices have only valid edges and vice versa, their difference 
may not be since there may be dangling edges pointing to the 
now-removed vertices of $\gamma_2$.} % end hide

\hide
{In \S\ref{sec:spacegraph} we will tie a mathematical graph $\gamma$ to 
a spatial graph predicate
$\p{graph}(x, \gamma)$.   As we will see, a $\p{graph}$ ``owns'' only the
spatial portion of $\gamma$ that is reachable
from $x$ even though $\gamma$ may have other valid vertices.
} % end hide

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Edit 1: Qinxiang's proposal ends
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\vspace{-0.75ex}

\paragraph{LabeledGraph.}
A LabeledGraph is a PreGraph with the addition of \emph{labels} on
vertices, edges, and/or the graph as a whole. The need for such labels
is fairly clear: the bare structure of a graph can only contain so
much information, and many classic graph problems such as graph
coloring, shortest path, and network flow rely on additional
information in the form of labels. Since
LabeledGraph is built on PreGraph, it inherits all lemmas proved about
PreGraph through Coq's \emph{type coercion}. 
In addition, we can prove additional lemmas that use labels,
\emph{e.g.} vertices in the union-find graph have an integer label denoting \emph{rank},
and we prove that running \texttt{find} does not alter any vertex's rank.

%% Anshuman's proposal 
\iffalse
\paragraph{LabeledGraph.}
A LabeledGraph is a PreGraph with the addition of \emph{labels} on 
vertices, edges, and/or the graph as a whole. The need for such labels
is fairly clear; the bare structure of a graph can only 
contain so much information, and many classic graph problems 
such as graph coloring, shortest path, and network flow rely on 
additional information in the form of labels. In our architecture, a
LabeledGraph inherits any lemmas proved about its associated PreGraph. 
In addition, we can define additional lemmas that use labels, 
\emph{e.g.} the union-find graph has an integer label denoting \emph{rank}.
We could prove a lemma that running \texttt{find} does not alter
any vertex's rank. 
\hide{add string labels to edges and reason about a trie.}
\fi
% Anshuman's proposal ends

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Edit 2

\vspace{-0.75ex}
\paragraph{GeneralGraph.}
PreGraphs and LabeledGraphs are quite universal, and allow us to state
and prove useful lemmas that are true by virtue of the way the graphs
were set up. However, when proving the correctness of graph
algorithms, we often need more specificity in our mathematical graphs
so that we may model the real program's restrictions closely. 
For example, the \p{uf\_graph} used in \texttt{find} 
restricted each vertex to having exactly one out-edge.  
These restrictions vary greatly by algorithm, and so should 
not be baked in to the definition of the graph. 
We achieve this using GeneralGraphs, which augment 
LabeledGraphs by adding custom ``soundness conditions'', indicated in
Figure~\ref{fig:graphs} with a dashed border.  
The soundness condition can be arbitrarily
complex, and can thus specify arbitrary restrictions on the graph.
Further, the type coercion we described earlier continues to apply, 
meaning that a GeneralGraph can seamlessly behave like a 
LabeledGraph or a PreGraph, inheriting lemmas from them as usual.
This combination of generality and specificity is 
what makes GeneralGraphs truly versatile. Thankfully, we do
not need to state complicated soundness conditions afresh for
each program that we verify. In the next section, we explain how to
compose these out of smaller, reusable pieces.


\subsection{Composing soundness plugins}
\label{subsec:graphplugins}

\hide{Our entire library of formal 
graph theory is developed around the
three graph structures above. The theorems about the first two 
are universal, while some theorems about GeneralGraph
are developed on demand because soundness conditions vary by
algorithm.} 
Soundness conditions often need to be custom-designed 
for each algorithm, but they feature some recurring themes.
We take advantage of this by preparing some simple atomic 
\emph{soundness plugins}, along with related lemmas, in advance, 
and then combining them to create the soundness condition we need.
When proving lemmas about the resultant combination, we can use known
facts about the separate plugins. 
We use Coq's typeclass system to manage our soundness plugins
smoothly, benefiting from the \emph{compositionality} of the system.
Consider the following oft-used graph properties:

\begin{itemize}
\vspace{-1ex}
\item \p{FiniteGraph}: the valid vertices and edges are finite
%\vspace{-1ex}
\item \p{MathGraph}: invalid nodes are allowed to be destinations
of valid edges, thus allowing null values to represent unused nodes
\hide{More subtly, consider that many real data structures use special null values to 
represent unused nodes.  The  property introduces this concept---
\emph{i.e.} some special invalid nodes are allowed to appear as 
destinations for valid edges.} % end hide
%\vspace{-1ex}
\item \p{BiGraph}: there are exactly two outgoing edges per node
\item \p{LstGraph}: the graph is list-like; loops are forbidden and 
nodes have one outgoing edge each
\end{itemize}

\hide{As a first step, we can prove many general, reusable lemmas
about these properties. However, these properties are still 
too general to model a real program. The next step is to compose 
these plugins to arrive at a more specific set of restrictions 
that more closely models our particular graph.} 
We can compose 
\p{LstGraph}, \p{MathGraph}, and \p{FiniteGraph} 
together into a new plugin called \p{LiMaFin}, which, incidentally, is
the soundness condition of mathematical \p{uf\_graph} 
we used to verify \texttt{find} in
Figure~\ref{fig:find}.  In our verification of \texttt{mark} in
Figure~\ref{fig:markgraph}, we use a similar soundness condition
\p{BiMaFin}, which uses \p{BiGraph} instead of \p{LstGraph}. 
The commonalities and differences between \p{LiMaFin} 
and \p{BiMaFin} are readily apparent from their construction.
Composing plugins in this way is much more elegant than creating a
custom plugin for each new algorithm as it promotes the natural reuse of graph 
properties across algorithms.

\iffalse
\marginpar{\tiny \color{blue} Maybe move this somewhere.} 
{\color{magenta}Coq also handles our notion of inherited 
lemmas seamlessly: in our verfication of Find, we 
work directly with a \p{LiMaFin} GeneralGraph, but, as 
we saw, we still use properties such as reachability 
and operations such as selective subtraction, which are defined on the 
embedded PreGraph, not the GeneralGraph. 
Coq handles the appropriate coercions with 
remarkable elegance.}
\fi

%% We can apply our framework to define related structures such as DAGs and trees.
%% For example, a DAG has the additional property that for any $x$ and $y$,
%% if $x$ is reachable from $y$, then $x = y$ or $y$ is not reachable
%% from $x$.
%  Similarly, we define tree by saying that for any reachable node $n$ there is
%a unique path from the root to $n$.
\iffalse
\subsection{Reasoning about relations between graphs} %Using our framework to reasonApplication of the framework}

\marginpar{\color{blue} \tiny Needs revised examples based on new Orientation.}

{\color{magenta} In Figure~\ref{fig:markgraph} we defined the relation 
$\m{mark}(\gamma, \tx x, \gamma')$
for the graph marking algorithm.  Similarly, we define $\m{span}$ for the 
spanning tree program
and $\m{copy}$ for the graph copy program.
These relations all capture how the graph has changed from before to after the program
execution.  By specifying $\m{copy}$ relationally
rather than functionally we avoid explicitly modeling how the memory 
allocator works, a major advantage.

As previously mentioned, we reuse $\m{mark}$ and its
related lemmas to prove facts about spanning tree and graph copy
because the latter two programs mark nodes as they work.
Accordingly, we can reuse facts such as the following:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Edit 4
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Edit 4: Qinxiang's proposal starts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{@{}l@{}}
\text{if } \gamma(x)=(0, v_1, \dots,v_n), \m{mark1}(\gamma, x, \gamma_1),
\text{ and } \forall i, \m{mark}(\gamma_i,v_i,\gamma_{i+1}) \text{ then } \m{mark}(\gamma,x,\gamma_{n+1}).
\end{array}
\]
}
\fi
%We prove this theorem sound for any LabeledGraph, not just
%\p{BiGraph}s (\emph{i.e.}, we do not assume only two neighbors).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Edit 4: Qinxiang's proposal ends
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
