We have long been interested in
the verification of graph-manipulating programs written in~C~\cite{ramify}.
More recently, we have fortified our techniques to handle realistic (CompCert~\cite{CompCert})~C
to a machine-checked level of rigour~\cite{localize}.  The present result extends
our previous work in that it uses a adjacency matrices to represent the graph in
memory and involves non-trivial edge labels; both are new for us.

We are investigating techniques to increase the automation of such verifications.  Although
we benefit from some automation at the Hoare-logic level provided by the Verified Software
Toolchain~\cite{VST}, building these proofs is still highly labor intensive.  We see potential
for automation in four areas: (A) the Hoare level; (B) the spatial level; (C) the mathematical level; and (D) the interface between the spatial and the mathematical levels.  Our ongoing work
on these challenges include improved tactics for VST for common cases we encounter in graph
algorithms (A); an expanded library of existing graph constructions and associated lemmas (B);
better lemmas about common mathematical graph patterns, investigations into reachability techniques
such as those presented by Backhouse and Carre~\cite{backhouse} as well as those by Tarjan~\cite{tarjan} and Dolan~\cite{dolan} (C); improved modularity in our constructions and
automation of common cases, \emph{e.g.} we often compare C pointers to heap-represented graph
nodes for equality, and due to the nature of our representations this equality check will be
well-defined in~C when the associated nodes are present in the mathematical graph.  Generally
speaking, the advantage of having worked end-to-end machine-checked examples such as
the one we presented above is that they guide the automation efforts by providing precise goals
that are known to be strong enough to complete a real verification.

\paragraph{Related work by others.}
Other Dijkstra.  Other graph algorithms.

\paragraph{Conclusion.}
Blah.
