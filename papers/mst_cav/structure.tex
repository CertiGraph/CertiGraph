%\subsection{Modularity of library and VST verification}
In previous work by both VST and our team, the C functions and algorithms we have implemented and verified are isolated with little to no dependency on each other. Even the garbage collector verified by Wang et al was its own, independent of the other verified code in the library. This work is the first step our team has taken in verifying code that uses \textit{previously} verified C code, as mentioned during the discussion of Kruskal's algorithm. We found it a necessity to further re-organise the internal hierarchies in our library, providing a clearer separation between mathematical lemmas, VST specifications and proofs.
\newline\newline
INSERT PIC HERE
\newline\newline
Previously, we described CertiGraph as having three layers: The mathematical layer which contains "pure Coq" mathematical models and lemmas; the spatial layer to represent graphs in Verifiable C; and the verification layer, for specifications and verifications of C code, whose ASTs were retrieved from CompCert's \textit{clightgen} utility. We further separate this third layer into specifications and verifications. This allows re-use of a previous specification by another system without being burdened by the verification, as illustrated above. The development and verification of components can then be performed in parallel.
\newline\newline
In addition, we have worked to improve on the modularity of the mathematical layer. While we have highlighted differences between directed and undirected graphs, as well as in the graphs in different representations, we have worked to ensure that the same lemmas can be used by them with little need for repetition, to reduce the code base in CertiGraph. Our new contributions to CertiGraph include: ~2000 lines of lemmas of undirected graph properties; ~200 lines to link unionfind properties with undirected graph properties; ~1500 lines for the symmetric matrix graph and ~900 lines for the edgelist graph; ~1800 lines for the verification of Prim's and Kruskal's algorithms each, including the mathematical proof of the resultant forest's minimality.