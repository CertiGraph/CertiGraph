Verifying real code is meaningfully harder than verifying toy implementations.  On top of such challenges, verifying graph algorithms requires a significant amount of mathematical machinery: there are many plausible ways to define basic notions such as reachability, but not all of them can handle the challenges of verifying real code~\cite{shengyi:thesis}.  Moreover, we would like our mathematical, spatial, and verification machinery to be generic and reusable.

All of the above suggests that it is important to work within existing formal proof developments due a strong desire to not reinvent very large wheels (the existing proof bases we work with contain hundreds of thousands of lines of formal proof).  We chose to work with the CompCert certified compiler~\cite{leroy:compcert}; the Verified Software Toolchain~\cite{appel:programlogics}, which provides significant tactic support for separation logic-based deductive verification of CompCert~C programs; and the CertiGraph framework~\cite{DBLP:journals/pacmpl/WangCMH19}, which provides much pure and spatial reasoning support for verifying graph-manipulating programs within VST.  We did so because these frameworks can handle the challenges of real code and because the CertiGraph included several fully verified implementations of union-find that we wished to reuse in our verification of Kruskal's algorithm.

Modular formal proof development involves major software engineering challenges~\cite{DBLP:journals/corr/abs-2003-06458}.
Accordingly, we took care factoring our extensions to CertiGraph into generic and reusable pieces.  This factoring allows us to reuse machinery between verifications, including in the mathematical, spatial, and verification levels, so \emph{e.g.} we share significant pure and spatial machinery between Dijkstra, Prim, and Kruskal.  Moreover, we maintain good separation between pure and spatial reasoning, so \emph{e.g.} both our Dijkstra and Prim verifications can handle multiple spatial variants of adjacency matrices without significant change.

On the other hand, working within existing developments involves some challenges, primarily in that some design decisions have been already made and are hard to change.  Moreover, our verifications tickled numerous bugs within VST, including: overly-aggressive automatic entailment simplifying, poor error messages, improper handling of~C~\texttt{struct}s, and performance issues.  We have been fortunate that the VST team has been willing to work with us to fix such bugs, although some work still remains.  Performance remains one area of focus: for example, checking our verification of Kruskal with a 3.7GHz processor and 32gb of memory takes more than 22 minutes even after all of the generic pure and spatial reasoning has been checked, \emph{i.e.} approximately 7 seconds per line of~C~code (including whitespace and comments).  This performance is unviable for verifying an industrial-sized application of equivalent difficulty: \emph{e.g.}, it would take 13 years for Coq to check the proof for 1,000,000 lines of~C.  Before some optimizations to our proof structure, the time was significantly longer still.

%\subsection{Working within large existing frameworks}




%\subsection{Structure of graph library}
\label{sec:structure}

%\subsection{Modularity of library and VST verification}
%In previous work by both VST and CertiGraph, the C functions and algorithms implemented and verified are isolated programs with little to no dependency on each other. Even the garbage collector verified by Wang et al was independent of the other verified algorithms in the library. VST has noted the importance of having a client for a verified program, to judge whether the actual utility of the verified specifications\cite{DBLP:conf/iwmm/AppelN20}. Our work on Kruskal's algorithm is the first step in verifying code that uses \textit{previously} verified C code. To make use of Wang's verified union-find, we reorganised the internal hierarchies in his CertiGraph library, providing a clearer separation between mathematical lemmas, VST specifications and proofs.

%\includegraphics[scale=0.50]{structure_placeholder.jpg} %Please check in this file.

%We reorganised CertiGraph into three layers: The mathematical layer which contains ``pure Coq" mathematical models and lemmas; the spatial layer to represent graphs in Verifiable C; and the verification layer, for specifications and verifications of C code, whose ASTs were retrieved from CompCert's \textit{clightgen} utility. We further separate this third layer into specifications and verifications. This allows reuse of a previous specification by another system without being burdened by the verification, as illustrated above. The development and verification of components can then be performed in parallel.

%In addition, we have worked to improve on the modularity of the mathematical layer, ensuring that similar graph properties and lemmas can be reused by different proofs with little need for repetition.

Our contributions to CertiGraph include pieces that are reused
repeatedly and pieces that are more bespoke. Below, we give a sense of both the
size of our development (lines of formal Coq proof) and the mileage we get out of our own work via reuse.
Items ``added with $+$'' are very similar (within 1\%) of each other; Prim \#4 is the version that does not set the root, \emph{i.e.} on the right in figure~\ref{fig:prims}.

\[
\begin{array}{@{}c@{}|@{}c@{}}
\begin{minipage}{0.51\textwidth}
\[
\begin{array}{@{}l@{\qquad}c@{\quad}r@{\quad}r@{\quad}l@{}}
\text{Name} & \text{Used} & \text{LoC} \\
\hline
\text{MathAdjMat} & \text{6x} & \text{165} \\
\text{Undirected} & \text{5x} & \text{2,139} \\
\text{MathUAdjMat} & \text{3x} & \text{1,024} \\
\text{SpaceAdjMat1+2+3} & \text{6x} & \text{499} \\
\text{EdgeListGraph} & \text{1x} & \text{911} \\
\text{MathDijkGraph} & \text{3x} & \text{165} \\
\text{DijkPureProof} & \text{3x} & \text{2,124} \\
\text{UndirectedUF} & \text{1x} & \text{183} \\
\text{BinaryHeapModel} & \text{1x} & \text{1,870} \\
\hline
\text{Total (pure/spatial)} & & \text{9,080} \\
\end{array}
\]
\end{minipage} &
\begin{minipage}{0.48\textwidth}
\[
\begin{array}{@{~\quad}l@{\qquad}r@{\quad}r@{\quad}r@{\quad}l@{}}
\text{Name} &  \text{LoC} \\
\hline
\text{DijkSpec1+2+3} & \text{301} \\
\text{VerifDijk1+2+3} & \text{3,554} \\

\text{PrimSpec1+2+3+4} & \text{508} \\
\text{VerifPrim1+2+3+4} & \text{7,455} \\
\text{KruskalSpec} & \text{302} \\
\text{VerifKruskal} & \text{1,606} \\
\text{VerifHeapSort} & \text{568} \\
\text{VerifBasicBinaryHeap} & \text{777} \\
\text{VerifAdvBinaryHeap} & \text{2,253} \\
\hline
\text{Total (verifications)} & \text{17,234} \\
\end{array}
\]
\end{minipage}
\end{array}
\]

In total we have 26,314 novel lines of Coq proof to verify 1,155 lines of~C~code divided among 12 files, including 3 variants of Dijkstra, 4 variants of Prim, 1 of Kruskal (which includes its \texttt{heapsort}), and 2 binary heaps. 