\subsection{Overlaying undirected graphs on top of a directed graph library}

\begin{lstlisting}
Record PreGraph {EV: EqDec Vertex eq} {EE: EqDec Edge eq} := {
	vvalid : Ensemble Vertex;
	evalid : Ensemble Edge;
	src : Edge -> Vertex;
	dst : Edge -> Vertex
}.
\end{lstlisting}
In CertiGraph, every graph has the four following basic functions: $vvalid$ which determines which vertices are valid in the graph; $evalid$ which determines which edges are valid in the graph, and $src$ and $dst$ map each edge to vertices. For example, an edge $e$ in graph $g$ pointing from vertex $u$ to $v$ will have $src$ $g$ $e$ $=$ $u$ and $dst$ $g$ $e$ $=$ $v$. What these functions actually are, is defined during the actual construction of a graph.

As a result of this definition, all graphs defined by CertiGraph are directed - each edge in the graph has a clear direction defined by the $src$ and $dst$ functions. This makes sense in most use cases, especially when reasoning about C pointers.

How then to reason about undirected graphs in a directed graph library? A naive idea is to consider undirected edges as a separate category from directed edges, by introducing new \texttt{Ensemble}s for undirected edges. This has the benefit of reasoning with mixed graphs that contains both directed and undirected edges. However, the graphs we wish to study are either directed or undirected, so it will be unwieldy for a graph to have to maintain ensembles for both kinds of edges, when it will never use one kind. Furthermore, it requires us to recreate many fundamental operations for manipulating edges, ignoring the already robust suite of lemmas Wang et al already have for $evalid$, $src$ and $dst$.

Instead, we decided to rely on the observation that \textit{every directed graph can be treated as an undirected graph} by simply ignoring the directions of the edges, thus holds certain undirected graph properties. This is backed by our observation that undirected graph properties are largely mathematical in nature, and depending on the representation, have few to no spatial requirements in separation logic. It also allows us to use CertiGraph's rich set of lemmas about the addition and removal of edges.

\subsection{Undirected graph properties}

Here we give a quick explanation of the main undirected definitions and properties we're interested in. Our definitions are largely based on CLRS~\cite{clrs}.

Let $g$ be a graph. A valid edge $e$ in $g$ is an adjacent edge (or \textit{adj\_edge} for short) of valid vertices $u$ and $v$ if those are its $src$ and $dst$. $u$ and $v$ are \textit{adjacent} if such an edge exists in $g$.
\begin{lstlisting}
Definition adj_edge (g: PreGraph V E) (e: E) (u v: V) :=
	strong_evalid g e /\
	((src g e = u /\ dst g e = v) \/ (src g e = v /\ dst g e = u)).

Definition adjacent (g: PreGraph V E) (u v: V) :=
	exists e: E, adj_edge g e u v.
\end{lstlisting}
A similar approach is proposed in Halsbeck~\cite{DBLP:journals/afp/HaslbeckLB19}.

A valid undirected path, or \textit{upath}, in $g$ is a list of vertices such that each vertex in the list is adjacent with the subsequent vertex. An empty path, $nil$, is by default a valid $upath$. A singleton path $[v]$ is also a valid $upath$ if $v$ is a valid vertex.
\begin{lstlisting}
Fixpoint valid_upath (g: PreGraph V E) (p: upath) : Prop :=
match p with
| nil => True
| u :: nil => vvalid g u
| u :: ((v :: _) as p') => adjacent g u v /\ valid_upath g p'
end.
\end{lstlisting}
Two vertices $u$ and $v$ are \textit{connected by p} if $p$ is a valid $upath$ in $g$ with the head vertex $u$ and last vertex $v$. They are \textit{connected} if such a $upath$ exists. By the above, every valid vertex in $g$ is trivially connected to itself.
\begin{lstlisting}
Definition connected_by_path (g: PreGraph V E) (p: upath) (n : V) :=
	fun n' => valid_upath g p /\
		hd_error p = Some n /\ last_error p = Some n'.

Definition connected (g: PreGraph V E) (n : V) :=
	fun n' => exists p, connected_by_path g p n n'.
\end{lstlisting}
An undirected cycle, or $ucycle$, is a $upath$ whose first and last vertices are the same. A $simple$ $upath$ is a valid $upath$ that has no duplicate vertices - no vertex is visited twice. A $simple$ $ucycle$ is a cycle whose tail has no duplicate vertices - the only ``duplicates" in the cycle are the first and last vertices.

Note that the definition of path varies between textbooks and papers. For example, \textit{Discrete Mathematics and its Applications}~\cite{rozen} defines paths as a sequence of edges with an implicit sequence of vertices, whereas CLRS, which we have followed, defines it as a sequence of vertices with an implicit sequence of edges.

\subsection{Defining forests before trees}

CLRS defines a tree as ``a (connected) graph with no simple undirected cycles" - in other words, a connected, acyclic graph. We use the same definition:
\begin{lstlisting}
Definition uforest g:=
	(forall e, evalid g e -> strong_evalid g e) /\
	(forall p l, $\neg$ simple_ucycle g p l).
\end{lstlisting}
Our definition contains two propositions. The first constrains a forest to have no excess, ``dangling" edges. Although CertiGraph was designed to reason about such edges, we do not want to tolerate them in our forests. The second is the key ``no simple undirected cycles".
\begin{figure}[H]
	\begin{tikzpicture} [auto, node distance =1.5 cm and 1.5cm ,on grid, semithick, state/.style ={ circle}]
		\node[state] (V0) {$\m{v_0}$};
		\node[state] (V1) [right=of V0] {$\m{v_1}$};
		\node[state] (V2) [below=of V0] {$\m{v_2}$};
		\node[state] (?1) [above=of V0] {$?$};
		\node[state] (?2) [right=of V1] {$?$};
		\node[state] (?3) [below right=of ?2] {$?$};
		\path (V0) edge node[above=0.15 cm] {$5$} (V1);
		\path (V0) edge node[left=0.15 cm] {$6$} (V2);
		\path (V0) edge node[left=0.15 cm] {$-1$} (?1);
		\path (?2) edge node[above right=0.15 cm] {$2$} (?3);
	\end{tikzpicture}
	\caption{The above is not a forest, due to the ``dangling" edges leading to invalid vertices (? being a placeholder)}
\end{figure}
We also highlight a difference in our definition compared to mathematical textbooks. Prim's and Kruskal's algorithms are presented as minimum-spanning \textit{tree} algorithms, and often have the implicit assumption that the graph is fully connected. They may or may not discuss forests - CLRS does not, while \textit{Discrete Mathematics} informally defines forests as ``containing no simple circuits that are not necessarily connected [...] and have the property that each of their connected components is a tree." In short, these sources define forests from ``bottom-up" using trees. We define them ``top-down" instead, recognising forests as acyclic graphs and trees as connected forests. This definition was also used by Lammich et al~\cite{DBLP:journals/afp/LammichN19}.
\begin{lstlisting}
Definition connected_graph (g: PGraph) :=
	forall u v, vvalid g u -> vvalid g v -> connected g u v.

Definition utree g := uforest g /\ connected_graph g.
\end{lstlisting}