\subsection{Edge list representation, multi-graph trimming, and subtle differences of graphs in different representations}
Kruskal's algorithm differs from Prim's in that it directly operates on the edges of the input graph, rather than Prim's vertex-based approaches. Consequently, in C implementations it is useful to pass the graph in as a list of graph edges, rather than an adjacency matrix or list. This also simplifies the sorting necessary in Kruskal's.

We define a simple edge list representation in C below, and observe mathematical differences between the graphs that can be represented by an edge list and an adjacency-matrix representation. As mentioned in the Prim's section, in a symmetric adjacency matrix, $g[u][v])$ and $g[v][u]$ are considered the same edge; however, this is not true for an edge list, where every edge is effectively an ordered pair due to the memory positions of the data. As a result, this edge list can contain multiple edges between two vertices whereas a 2D adjacency matrix cannot. Further, we prove that Kruskal's algorithm can handle such inputs and still return a minimal spanning forest.
\newline
\begin{lstlisting}
struct edge {
	int weight;
	int src;
	int dst;
};

struct graph {
	int V; //number of vertices {0...V-1}
	int E; //number of edges in the edgelist
	struct edge *edge_list;
};
//Consider a graph with edges {weight=1,src=0,dst=1}
//	and {weight=2,src=1,dst=0}
\end{lstlisting}
\begin{figure}
\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={ circle}]
	\node[state] (V0) {$\m{v_0}$};
	\node[state] (V1) [right=of V0] {$\m{v_1}$};
	\path (V0) edge [bend left] node[above=0.15 cm] {$\{1,\m{v_0},\m{v_1}\}$} (V1);
	\path (V1) edge [bend left] node[below=0.15 cm] {$\{2,\m{v_1},\m{v_0}\}$} (V0);
\end{tikzpicture}
\caption{Example of one kind of multi-graph representable by the above C edge-list implementation, which Kruskal's algorithm is able to prune.}
\end{figure}

\subsection{Reusing previously verified union-find} %%why is there such an absurdly large space?
Kruskal's algorithm requires a union-find data structure to keep track of the state of connectedness in the partial forest. Since CertiGraph had published several verified union-find implementations, we decide to make use of them. However, as these implementations had no client using them until now, we discovered that the postconditions of the union-find calls were difficult to use for Kruskal's verification. The union-find implementations were verified prior to our introduction of undirected graph properties, thus were not designed with connectedness in mind.

To that end, we have extended lemmas about the results of union-find operations as an analog to connectivity. We are pleased to say that no change was required for Wang's existing union-find definitions, lemmas, specifications and verification. Instead, we proved that their existing postconditions mathematically imply an analog to connectivity in undirected graphs. In other words, Wang's verified postconditions were \textit{not} incorrect or poor, they just required mathematical translation into what we wanted in the context of Kruskal's.

We mention this to emphasise the modularity and buildability of VST and CertiGraph infrastructure - that we were able to use previously, independently proven code in a bigger system later. The internal details and verification of the union-find system are independent from that of Kruskal's, whose proof only required the preconditions and postconditions of whichever union-find implementation we decide to use.