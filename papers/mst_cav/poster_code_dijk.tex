
\begin{figure}[t]

\begin{lstlisting}[mathescape=true,showlines=true]
void dijkstra (int **g, int src, int *dist, 
               int *prev, int size, int inf {
$\color{OliveGreen}//~\braces{\p{AdjMat}(\texttt{g},\gamma) *
\mathsf{array}(\texttt{dist}, \_) * \mathsf{array}(\texttt{prev}, \_)}$
 Item* temp = (Item*) mallocN(sizeof(Item));
 int* keys = mallocN (size * sizeof (int));
 PQ* pq = pq_make(size); int i, j, u, cost;
 for (i = 0; i < size; i++) 
 { dist[i] = inf; prev[i] = inf; keys[i] = pq_push(pq, inf, i); }
 dist[src] = 0; prev[src] = src; pq_edit_pri(pq, keys[src], 0);
$\color{OliveGreen}//~\braces{{\color{red}\exists \m{dist}, \m{prev}, \m{popped}, \m{keys},\m{heap}}.~\p{AdjMat}(\texttt{g},\gamma) * {\color{red}\p{PQ}(\texttt{pq},\m{heap})} * \mathsf{array}(\texttt{dist},{\color{red}\m{dist}}) * \null \\
\mathsf{array}(\texttt{prev}, {\color{red}\m{prev}}) * 
{\color{red}\mathsf{array}(\texttt{keys}, \m{keys}}) * 
{\color{red}\mathsf{Item}(\texttt{temp}, \_)} /| \null \\
{\color{red}\m{dijk\_correct}(\gamma,\texttt{src},\m{popped},\m{prev},\m{dist})}}$ $\label{code:whileinv}$
 while (pq_size(pq) > 0) {
  pq_pop(pq, temp); u = temp->data; $\label{code:pop}$
$\color{OliveGreen}//~\braces{{\color{red}\exists \m{dist'}, \m{prev'}, \m{popped'}, \m{heap'}, \m{i}, \texttt{u}_{key}, \texttt{u}_{pri}}.~\p{AdjMat}(\texttt{g},\gamma) * \p{PQ}(\texttt{pq},{\color{red}\m{heap'}}) * \null \\
\mathsf{array}(\texttt{dist},\m{\color{red}dist'}) * 
\mathsf{array}(\texttt{prev}, \m{\color{red}prev'}) * 
\mathsf{array}(\texttt{keys}, \m{keys}) * \null \\
\mathsf{Item}(\texttt{temp}, \m{\color{red}(\texttt{u}_{key}, \texttt{u}_{pri}, \texttt{u})}) /| 
\m{\color{red}min(\texttt{u}, \m{heap'})} /| \null \\
{\color{red}\m{dijk\_correct\_weak}(\gamma, \texttt{src}, \m{popped'}, \m{prev'}, \m{dist'}, \m{i}, \texttt{u})}}$ $\label{code:forinv}$
  for (i = 0; i < size; i++) {
   cost = getCell(g, u, i); $\label{code:cost}$
   if (cost < inf) {
    if (dist[i] > dist[u] + cost) { $\label{code:overflow}$
     dist[i] = dist[u] + cost; prev[i] = u; $\label{code:update1}$ 
     pq_edit_pri(pq, keys[i], dist[i]); $\label{code:update2}$
  }}} $\color{OliveGreen}//~\braces{{\color{red}\exists \m{dist''}, \m{prev''},\m{heap''}}.~\p{AdjMat}(\texttt{g},\gamma) * \p{PQ}(\texttt{pq},\m{\color{red}heap''}) *
  \mathsf{array}(\texttt{dist},\m{\color{red}dist''}) * \null \\
  \mathsf{array}(\texttt{prev}, \m{\color{red}prev''}) *
  \mathsf{array}(\texttt{keys}, \m{keys}) *
  \mathsf{Item}(\texttt{temp}, \m{(\texttt{u}_{key}, \texttt{u}_{pri}, \texttt{u})}) /| \null \\
  \m{min(\texttt{u}, \m{heap'})} /|
  {\m{\color{red}dijk\_correct}(\gamma, \texttt{src}, \m{popped'}, \m{\color{red}prev''}, \m{\color{red}dist''})}}$ $\label{code:caughtup}$
 } $\color{OliveGreen}//~\braces{{\color{red}\exists \m{dist^{\circ}}, \m{prev^{\circ}}, \m{popped^{\circ}}, \m{heap^{\circ}}}.~\p{AdjMat}(\texttt{g},\gamma) * \p{PQ}(\texttt{pq},\m{\color{red}heap^{\circ}}) * \null \\
 \mathsf{array}(\texttt{dist},\m{\color{red}dist^{\circ}}) * 
 \mathsf{array}(\texttt{prev}, \m{\color{red}prev^{\circ}}) *
 \mathsf{array}(\texttt{keys}, \m{keys}) * 
 {\mathsf{Item}(\texttt{temp}, \_)} /| \null \\
{\color{red}\forall \m{dst}.~0 \le \m{dst} < \texttt{size} -> \m{inv\_popped}}(\gamma, \m{src}, \m{\color{red}popped^{\circ}}, \m{\color{red}prev^{\circ}}, \m{\color{red}dist^{\circ}}, \m{dst})}$ $\label{code:end}$
 freeN (temp); pq_free (pq); freeN (keys); return; 
}
\end{lstlisting}
\vspace{-1em}
\caption{Clight code and proof sketch for Dijkstra's Algorithm.}
\vspace{-1em}
\label{fig:decorated}
\end{figure} 