{\color{red}Dijkstra's eponymous shortest-path algorithm~\cite{DBLP:journals/nm/Dijkstra59} finds
the cost-minimal paths from a distinguished \emph{source} vertex
source to all reachable vertices in a finite directed graph. Prim's and Kruskal's algorithms return minimal spanning trees for finite undirected graphs.
These three algorithms are classic and ubiquitous, appearing widely in textbooks~\cite{clrs} in real routing protocol libraries. Many textbooks and classic lecture notes discuss their proofs in pen and paper. Further, the algorithms have been in
use for over $60$ years, suggesting that for all practical purposes
their safety and correctness have been verified by decades of application.

%Recent efforts [cite Mizar, cite ACL2, cite Coq] have implemented the algorithm
%in proof assistants and formally proved claims about its behavior.
%However, because they operate entirely within idealized formal checkers,
%these works inadvertently gloss over certain classes of issues
%that routinely crop up in real-world settings.

Here we verify a~C~implementation of Dijkstra's one-to-all shortest path algorithm.
We implement textbook~C~code~\cite{clrs} in CompCert~C~\cite{leroy:compcert} so that
we can use the Verified Software Toolchain~\cite{appel:programlogics} and
Wang~\emph{et al.}'s recent framework for verifying graph algorithms~\cite{DBLP:journals/pacmpl/WangCMH19} to state and prove the full functional
correctness of the code using the Coq proof assistant~\cite{coq}.}

We discuss two observations. First, in spite of the many pen-and-paper proofs of these algorithms, we expose a subtle overflow issue in Dijkstra's~C~code and make a nontrivial refinement to the precondition of the algorithm so that users know when the code will calculate the correct paths. In addition, we disprove an informal but common notion that Prim's algorithm cannot work on disconnected graphs. We demonstrate that it can return a minimum spanning forest, and further that the root parameter is unnecessary.

The remainder of this paper is organized as follows:
\begin{itemize}
    \item[\S\ref{sec:dijkstra}] We briefly present and explain
    our~C~implementation of Dijkstra's algorithm and the key loop invariants
    we use to certify its specification.
    \item[\S\ref{sec:overflow}] We explain how overflow can occur and give a
    refinement to the precondition of the function that restricts edge weights
    and the standard \texttt{INF} definition
    appropriately in a way that prevents said overflow.
    \item[\S\ref{sec:undirected}] We explain how our undirected graph and forest definitions within the context of a fundamenetally directed graph library to enable verification of Prim's and Kruskal's algorithms
    \item[\S\ref{sec:prim}] We present Prim's algorithm and discuss our findings on its ability to operate on disconnected graphs by simply dissociating a vertex's membership in the priority queue from its weight.
    \item[\S\ref{sec:kruskal}] We present Kruskal's algorithm and discuss the nuances between different graph representations, as well as the reuse of previously independently verified programs.
    \item[\S\ref{sec:structure}] We discuss modularity within the graph library as a follow-up from Kruskal's, demonstrating VST's and CertiGraph's ability to build incrementally larger systems.
    \item[\S\ref{sec:conclusion}] We conclude by putting this result in the context of our
    previous and ongoing work. We discuss related work in certifying the three graph algorithms, and revisit standard algorithms textbook presentations.
\end{itemize} 

\noindent Our code is available at \url{https://github.com/anshumanmohan/CertiGraph}.
