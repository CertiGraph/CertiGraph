Dijkstra's eponymous shortest-path algorithm~\cite{DBLP:journals/nm/Dijkstra59} finds
the cost-minimal paths from a distinguished \emph{source} vertex
to all reachable vertices in a directed graph. Prim's~\cite{prim2:prim} and Kruskal's~\cite{kruskal} algorithms return minimal spanning trees for undirected graphs.  Binary heaps are the first priority queue one typically encounters.
These algorithms/structures are classic and ubiquitous, appearing widely in textbooks~\cite{clrs,DBLP:books/daglib/0022194,heineman2008algorithms,rozen,kepnergilbert,sedgewick} and in real routing protocol libraries.

In addition to decades of use and textbook analysis, recent efforts have verified one or more of these algorithms in proof
assistants and formally proved claims about their behavior \cite{chen2003dijkstra,Moore2005,arthur,DBLP:journals/afp/LammichN19,DBLP:conf/ictac/Guttmann16}.  A reasonable person might think that all
that can be said, has been.  However, we have found that
textbook code glosses over a cornucopia
of issues that routinely crop up in real-world settings: under/overflows, integration with performant data structures, manual memory (de-)allocation,
error handling, casts, memory alignment, \emph{etc.} Further, previous verification efforts with formal checkers often operate
within idealized formal environments, which likewise leads them to ignore the same kinds of issues.

In our work, we provide~C~implementations of each of these algorithms/data structures, and prove in Coq~\cite{Coq} the functional correctness of the same with respect to the formal semantics of CompCert~C~\cite{leroy:compcert}.  By ``functional correctness'' we mean complex pre/post specifications, rather than \emph{e.g.} resource bounds.  Although our~C~code is developed from standard textbooks, we uncover several subtleties
that are absent from the algorithmic and formal methods literature:

\begin{itemize}
\item[\S\ref{sec:dijkoverflow}] an overflow in Dijkstra's algorithm whose avoidance requires a nontrivial refinement to the algorithm's precondition to bound edge weights;
\item[\S\ref{sec:primforest}] that the specification of Prim's algorithm can be improved to apply to disconnected graphs without any change to textbook (pseudo-)code;
\item[\S\ref{sec:primforest}] the presence of a wholly unneeded line of (pseduo-)code in Prim's algorithm, and an associated unneeded function argument;
\item[\S\ref{sec:binheap}] several potential overflows in binary heaps equipped with Floyd's linear-time build-heap function and an edit-priority operation.
\end{itemize}

We wish to develop general and reusable techniques for verifying graph-manipulating programs written in real programming languages.  This is a significant challenge, and so we choose to leverage and/or extend three large existing proof developments to state and prove the full functional correctness of our code in Coq: CompCert; the Verified Software Toolchain~\cite{appel:programlogics} (VST) separation logic~\cite{o2001local} deductive verifier; and our own previous efforts~\cite{DBLP:journals/pacmpl/WangCMH19}, hereafter dubbed the CertiGraph project.  Our primary extensions are to the third, and include:
\begin{enumerate}
\item[\S\ref{sec:adjmatpure}] pure/abstract reasoning for graphs with edge labels,
(\emph{e.g.}, a distinguished edge-label value for ``infinity'' that indicates invalid/absent edges);
\item[\S\ref{sec:newspatial}] spatial representations and associated reasoning for edge-labeled graphs (several flavors of adjacency matrices as well as edge lists);
\item[\S\ref{sec:newundirected}] pure reasoning for undirected graphs (\emph{e.g.}, notions of connectedness).
\end{enumerate}
We prove that our pure machinery and our spatial machinery are well-isolated from each other by verifying several implementations (of each of Dijkstra and Prim) that represent graphs differently in memory but reuse the entire pure portion of the proof.  Likewise, we show that our spatial reasoning is generic by reusing graph representations across Dijkstra and Prim.  Our verification of Kruskal proves that we can reason about two graphs simultaneously: a directed graph with vertex labels for union-find and an undirected graph with edge labels for which we are building a spanning forest.
In addition to our verification of Dijkstra, Prim, and Kruskal, we develop increased lemma support for the preexisting CertiGraph union-find example~\cite{DBLP:journals/pacmpl/WangCMH19}.  Our extension to ``base VST'' (\emph{e.g.}, verifications without graphs) primarily consists of our verified binary heap.

% Many textbooks and classic lecture notes discuss their proofs in pen and paper. Further, the algorithms have been in
%use for over $60$ years, suggesting that for all practical purposes
%their safety and correctness have been verified by decades of application.

\hide{
Here we verify a~C~implementation of Dijkstra's one-to-all shortest path algorithm.
We implement textbook~C~code~\cite{clrs} in CompCert~C~ so that
we can use  and
Wang~\emph{et al.}'s recent framework for verifying graph algorithms .

We discuss two observations. First, in spite of the many pen-and-paper proofs of these algorithms, we expose a subtle overflow issue in Dijkstra's~C~code and make a nontrivial

 so that users know when the code will calculate the correct paths. In addition, we disprove an informal but common notion that Prim's algorithm cannot work on disconnected graphs. We demonstrate that it can return a minimum spanning forest, and further that the root parameter is unnecessary.
}

The remainder of this paper is organized as follows:
\begin{itemize}
    \item[\S\ref{sec:extensions}] We explain our extensions to CertiGraph:
    edge-labeled graphs, spatial representations of such graphs, and
    undirected graphs.
%    \item[\S\ref{sec:structure}] We discuss modularity within the graph library as a follow-up from Kruskal's, demonstrating VST's and CertiGraph's ability to build incrementally larger systems.
    \item[\S\ref{sec:dijkstra}] We explain our verification of Dijkstra's algorithm in some detail, discuss a potential overflow, and refine the precondition to avoid it. %~implementation of  and the key loop invariants we use to certify its specification.
%    \item[\S\ref{sec:overflow}] We explain how overflow can occur and give a refinement to the precondition of the function that restricts edge weights and the standard \texttt{INF} definition appropriately in a way that prevents said overflow.
    \item[\S\ref{sec:mst}] We overview our verifications of the Minimum Spanning Tree/Forest algorithms of Prim and Kruskal, focusing on high-level points such as our improved novel specification of Prim's.
%    's algorithm and discuss our findings on its ability to operate on disconnected graphs by simply dissociating a vertex's membership in the priority queue from its weight.
%    \item[\S\ref{sec:kruskal}] We present 's algorithm and discuss the nuances between different graph representations, as well as the reuse of previously independently verified programs.
    \item[\S\ref{sec:binheap}] We overview our verification of binary heaps, including a discussion of Floyd's bottom-up heap construction and the \texttt{edit\_priority} operation.
    \item[\S\ref{sec:stats}] We briefly discuss engineering, \emph{e.g.} statistics for our formal development.
    \item[\S\ref{sec:conclusion}] We discuss related work, outline future research directions, and conclude.
%    putting this result in the context of our previous and ongoing work. We discuss related work in certifying the three graph algorithms, and revisit standard algorithms textbook presentations.
\end{itemize}

\noindent Our results are completely machine-checked in Coq and publicly available~\cite{anonrepo}.%  Our code is available at \url{https://github.com/anshumanmohan/CertiGraph}.
