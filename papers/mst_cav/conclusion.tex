\subsection{Related work}

We have already discussed work directly related to Dijkstra's (\S\ref{sec:relworkdijkstra}), Prim's (\S\ref{sec:relworkprim}), and Kruskal's (\S\ref{sec:relworkkruskal}) algorithms in detail, including work from both the algorithms and formal methods literature.  Summarizing briefly to the point of unreasonableness, our observations about Dijkstra's overflow and Prim's specification are novel, and existing formal proofs focus on code working within idealized environments rather than handling the real-world considerations that we do.  We have also already discussed the three formal developments we
build upon and extend: CompCert, VST, and CertiGraph (\S\ref{sec:stats}).  Our goal now is to discuss mechanized graph reasoning and verification more broadly.

\paragraph{Reasoning about mathematical graphs.}
There is a 30+ year history of mechanizing graph theory, beginning at least with Wong~\cite{wong1991} and Chou~\cite{chou1994formal} and continuing to the present day; Wang discusses many such efforts~\cite[\S3.3]{shengyi:thesis}.  The two abstract frameworks that seem closest to ours are those by Noschinski~\cite{Noschinski2015}; and by Lammich and Nipkow~\cite{DBLP:journals/afp/LammichN19}.  The latter is particularly related to our work, because they too start with a directed graph library and must extend it to handle undirected graphs so that they can verify Prim's algorithm.

\paragraph{More-automated verification.}
Broadly speaking, mechanized verification of software falls in a spectrum between more-automated-but-less-precise verifications and less-automated-but-more-precise verifications.  Although VST contains some automation, we fall within the latter camp.  In the former camp, landmark initial separation logic~\cite{reynolds2002separation} tools such as Smallfoot~\cite{berdine:smallfoot} have grown into Facebook's industrial-strength Infer~\cite{calcagno2015moving}.  Other notable relatively-automated separation logic-based tools include HIP/SLEEK~\cite{chin:hipsleek}, Bedrock~\cite{chlipala:bedrock}, VerCors~\cite{DBLP:conf/fm/BlomH14}, and Viper~\cite{MuellerSchwerhoffSummers16}.  More-automated solutions that use techniques other than separation logic include Boogie~\cite{barnett2005boogie}, \textsc{Blast}~\cite{DBLP:journals/sttt/BeyerHJM07}, Dafny~\cite{leino10}, and KeY~\cite{DBLP:series/lncs/10001}.  In \S\ref{sec:relworkdijkstra} we discuss how some of these more-automated approaches have been applied to verify Dijkstra's algorithm. Petrank and Hawblitzel's Boogie-based verification of a garbage collector~\cite{gcexample2} gives another more-automated verification of a graph algorithm.  M\"uller and Schaefer verified \emph{binomial} (not binary) heaps in Viper, although their implementation did not support an edit-priority function~\cite{Mueller18}.

We are not confident that more-automated tools would be able to replicate our work easily.  We prove full functional correctness, whereas many more-automated tools prove only more limited properties.  Moreover, our full functional correctness results rely upon a meaningful amount of domain-specific knowledge about graphs, which automated tools usually lack.  Even if we restrict ourselves to more limited domains such as overflows, several more automated efforts did not uncover the overflow that we described in \S\ref{sec:relworkdijkstra}.  The proof that certain bounds on edge weights and \texttt{inf} suffice depends on an intimate understanding of Dijkstra's algorithm (in particular, that it explores one edge beyond the optimum paths); overall the problem seems challenging in highly-automated settings.  The more powerful specification we discover for Prim's algorithm in \S\ref{sec:primforest} is likewise not something a tool is likely to discover: human insight appears necessary, at least given the current state of machine learning techniques.

In contrast, several of the potential overflows in our binary heap might be uncovered by more-automated approaches, especially those related to the \texttt{PARENT} and \texttt{LEFT\_CHILD} macros from \S\ref{sec:heapinsertremove}.  Although the arithmetic involves both addition/subtraction and multiplication/division, we suspect a tool such as Z3~\cite{moura2008} could handle it. \hide{; the multiplication/division always has the constant \texttt{2u} for an operand.}  Moreover, a sufficiently-precise tool would probably spot the necessity of forcing the internal constants into \texttt{unsigned int}.  The issue of sound key generation described in~\S\ref{sec:modpri} might be a bit trickier.  On the one hand, \texttt{unsigned int} overflow is defined in~C, so real code sometimes relies upon it.  Accordingly, merely observing that the counter could overflow does not guarantee that the code is necessarily buggy.  On the other hand, some tools might flag it anyway out of caution (\emph{i.e.} right answer, wrong reason).

\paragraph{Less-automated verification.}
Although as discussed above some more-automated tools have been applied to verify graph algorithms, the problem domain is sufficiently complex that many of the verifications discussed in \S\ref{sec:relworkdijkstra}, \S\ref{sec:relworkprim}, and \S\ref{sec:relworkkruskal} use less-automated techniques.  Two basic approaches are popular.  The ``shallow embedding'' approach is to write the algorithm in the native language of a proof assistant.  The ``deep embedding'' approach is to write the algorithm in another language whose semantics has been precisely defined in the proof assistant.  VST uses a deep embedding, and so we do too; one of VST's more popular competitors in the deep embedding style is ``Iris Proof Mode''~\cite{DBLP:conf/popl/KrebbersTB17}.  In contrast, Lammich \emph{et al.} have produced a series of results verifying a variety of graph algorithms using a shallow embedding~(\emph{e.g.},~\cite{DBLP:conf/itp/Lammich14,DBLP:journals/afp/LammichN19,DBLP:journals/afp/HaslbeckLB19,DBLP:journals/jar/LammichS19,DBLP:conf/itp/LammichS16}).  From a bird's-eye view Lammich \emph{et al.}'s work is the most related to our results in this paper: they verify all three algorithms we do and are able to extract fully-executable code, even if sometimes their focus is a bit different, \emph{e.g.} on novel purely-functional data structures such as a  priority queue with \texttt{edit\_priority}.  %In particular, Lammich \emph{et al.} are able to ; others such as Guttmann provide only relational program descriptions and so probably cannot~\cite{DBLP:conf/ictac/Guttmann16,DBLP:journals/jlp/Guttmann18}.

%we note that Lammich has an ``approach B'' (deep embedding, in the sense that he generates LLVM code) verification of Introsort, which combines quicksort, heapsort, and insertion sort.

\paragraph{Pen-and-paper verification of graph algorithms.}

We use separation logic~\cite{reynolds2002separation} as our base framework.  Initial work on graph algorithms in separation logic was minimal; Bornat \emph{et al.} is an early example~\cite{bornat:aliasing04}.  Hobor and Villard developed the technique of ramification to verify graph algorithms~\cite{hobor:ramification}, using a particular ``star/wand'' pattern to express heap update.  Wang \emph{et al.} later integrated ramification into VST as the CertiGraph project we use~\cite{DBLP:journals/pacmpl/WangCMH19}.  Krishna \emph{et al.}~\cite{krishna2017go} have developed a flow algebraic framework to reason about local and global properties of \textit{flow graphs} in the program heap; their flow algebra is mainly used to tackle local reasoning of global graphs in program heaps.
Flow algebras should be compatible with existing separation logics; implementation and integration with the Iris project appears to be work in progress~\cite{DBLP:conf/esop/KrishnaSW20}.

Krishna \emph{et al.} are interested in concurrency~\cite{krishna2017go}; Raad \emph{et al.} provide another example of pen-and-paper reasoning about concurrent graph algorithms~\cite{DBLP:conf/aplas/RaadHVG16}.

%\vspace*{-0.25em}

\subsection{Future work}

%\vspace*{-0.25em}

We see several opportunities for decreasing the effort and/or increasing the automation in our approach.  At the level of Hoare tuples, we see opportunities for improved VST tactics to handle common cases we encounter in graph algorithms.  At the level of spatial predicates, we can continue to expand our library of graph constructions, for example for adjacency lists.  We also believe there are opportunities to increase modularity and automation at the interface between the spatial and the mathematical levels, \emph{e.g.} we sometimes compare~C~pointers to heap-represented graph
nodes for equality, and due to the nature of our representations this equality check will be
well-defined in~C~when the associated nodes are present in the mathematical graph, so this check should pass automatically.

We believe that more automation is possible at the level of mathematical graphs: for example reachability techniques based on regular expressions over matrices and related semirings~\cite{backhouse,DBLP:journals/jacm/Tarjan81a,dolan2013fun}.  We are also intrigued by the recent development of various specialized graph logics such as by Costa \emph{et al.}~\cite{costa:graphlogic} and hope that these kinds of techniques will allow us to simplify our reasoning.
The key advantage of having end-to-end machine-checked examples such as the ones we presented above is
that they guide the automation efforts by providing precise goals that are known to be strong
enough to verify real code.

%\vspace*{-0.25em}
\subsection{Conclusion}
%\vspace*{-0.25em}

We extend the CertiGraph library to handle undirected graphs and several flavours of graphs with edge labels, both at the pure and at the spatial levels.  We verify the full functional correctness of the three classic graph algorithms of Dijkstra, Prim, and Kruskal.  We find nontrivial bounds on edge costs and infinity for Dijkstra and provide a novel specification for Prim.  We verify a binary heap with Floyd's \texttt{heapify} and \texttt{edit\_priority}.
All of our code is in CompCert~C~and all of our proofs are machine-checked in Coq.

\paragraph{Acknowledgements.}  We thank Shengyi Wang for his help and support. %helpful early discussions some help with understanding the CertiGraph implementation, as well as a useful initial discussion about understanding the program invariants of Dijkstra's algorithm.

%The existing library of CertiGraph verifications contains a treasure trove of \emph{precisely} what lemmas are needed to verify real graph code, which should help to guide the development of automated techniques.

%; and (D) improved modularity in our constructions and
%automation of common cases

% such as the adjacency-matrix representation used in this result, as well as associated lemmas;

%are interested in increasing the amount of automation in our approach.

%\paragraph{Verifying graph algorithms}

%mention Iris?

%Brotherston

%Automated graph work / future work

%\note{Being in pseudocode and , these works do not need to discuss the application of the algorithms on "strange", non-simple graph inputs. Our C implementation does account for such inputs to a small extent, such as the edge list containing multiple edges between two vertices in Kruskal's.}

%\paragraph{Other graph proof libraries.}

%\cite{DBLP:conf/esop/KrishnaSW20}

%, tackling similar issues to Wang et al ~\cite{DBLP:journals/pacmpl/WangCMH19}, but in this paper, local reasoning is not required.
%In a related vein, Paulin and Filli\^atre verified Floyd's algorithm in Coq~\cite{paulin}
%
%\subsection{Previous work} We have long been interested in
%the verification of graph-manipulating programs written in~C~.
%We fortified our techniques to handle realistic (CompCert~\cite{leroy:compcert})~C~to a machine-checked level of rigour~\cite{DBLP:journals/pacmpl/WangCMH19}.  Novel features of the present result include a previously-untried adjacency matrices spatial graph representation as well as non-trivial edge labels between graph nodes. % for the first time. %, used to represent cost. %; both are new for us.
%
%\subsection{Ongoing and future work}
%{\color{red}We are investigating techniques to increase the automation of such verifications.  Although
%we benefit from some automation at the Hoare-logic level provided by the Verified Software
%Toolchain~\cite{appel:programlogics}, building these proofs is still highly labor intensive.  We see potential
%for automation in four areas: (A) the Hoare level; (B) the spatial level; (C) the mathematical level; and (D) the interface between the spatial and the mathematical levels.  Our ongoing work
%on these challenges include (A)  (B)
%(C) }

%@misc{paulin,
%title={The {C}oq proof assistant},
%author={{C}oq development team},
%url={https://coq.inria.fr/}, journal={The Coq Proof Assistant}}
%C. and J.C. Filli\^atre
%http://pauillac.inria.fr/cdrom/www/coq/contribs/floyd.html
%.11. R.Sumners.Corre
%tne


\hide{
\paragraph{Conclusion.}
We described a machine-checked proof of correctness for Dijkstra’s
shortest-path algorithm written in real~C from classic textbook code.
We showed this code suffers from an overflow bug and described a precise
precondition on edge weights to avoid it.  We put this result
in the context of our ongoing work.
} 