\subsection{Previous work} We have long been interested in
the verification of graph-manipulating programs written in~C~\cite{hobor:ramification}.
We fortified our techniques to handle realistic (CompCert~\cite{leroy:compcert})~C~to a machine-checked level of rigour~\cite{DBLP:journals/pacmpl/WangCMH19}.  Novel features of the present result include a previously-untried adjacency matrices spatial graph representation as well as non-trivial edge labels between graph nodes. % for the first time. %, used to represent cost. %; both are new for us.

\subsection{Ongoing and future work}
{\color{red}We are investigating techniques to increase the automation of such verifications.  Although
we benefit from some automation at the Hoare-logic level provided by the Verified Software
Toolchain~\cite{appel:programlogics}, building these proofs is still highly labor intensive.  We see potential
for automation in four areas: (A) the Hoare level; (B) the spatial level; (C) the mathematical level; and (D) the interface between the spatial and the mathematical levels.  Our ongoing work
on these challenges include (A) improved tactics for VST for common cases we encounter in graph
algorithms; (B) an expanded library of existing graph constructions such as the adjacency-matrix representation used in this result, as well as associated lemmas;
(C) better lemmas about common mathematical graph patterns, investigations into reachability techniques
based on regular expressions over matrices and related semirings~\cite{backhouse,DBLP:journals/jacm/Tarjan81a,dolan2013fun,krishna2017go}; and (D) improved modularity in our constructions and
automation of common cases, \emph{e.g.} we often compare~C~pointers to heap-represented graph
nodes for equality, and due to the nature of our representations this equality check will be
well-defined in~C~when the associated nodes are present in the mathematical graph.  The key
advantage of having end-to-end machine-checked examples such as the one we presented above is
that they guide the automation efforts by providing precise goals that are known to be strong
enough to verify real code.}

\subsection{Related work}

\paragraph{Other verifications of shortest-path.}
Chen verified Dijkstra in Mizar~\cite{chen2003dijkstra}, Gordon \emph{et al.} formalized the reachability property in HOL~\cite{gordon2003executing}, Moore and Zhang verified it in ACL2~\cite{Moore2005}, Mange and Kuhn verified it in Jahob~\cite{mange2007verifying}, and Klasen verified it in KeY~\cite{klasen2010verifying}.  Liu \emph{et al.} took an alternative SMT-based approach to verify a Java implementation of Dijkstra~\cite{6200101}.  In general the above work operates within
idealized formal environments and thus gloss over certain real-world issues, and so, as best we
can tell, do not \emph{e.g.} handle the overflow issue we identified.

%However, because they operate entirely within ,
%these works inadvertently gloss over certain classes of issues
%that routinely crop up in real-world settings.


\paragraph{Shortest-path in algorithms textbooks.}
We were not able to find a standard textbook that gives a robust, precise,
and full description of the overflow issue we describe in~\S\ref{sec:overflow}.
The landmark CLRS~\cite{clrs} does not address overflow, although---arguably---this is unnecessary in pseudocode.  Sedgewick's book on graph algorithms in~C~\cite{sedgewick} likewise does not address overflow, and moreover gives~C~code
that contains exactly the bug we identify.  Skiena's \emph{Algorithm Design Manual} likewise
glosses over the issue, both
in pseudocode and~C~\cite{DBLP:books/daglib/0022194}.
To its credit, Heineman \emph{et al.}'s \emph{Algorithms in a Nutshell}~\cite{heineman2008algorithms} mentions overflow as a possibility and
proposes casting certain computations to \texttt{long} to avoid them in~C.  However, Heineman
\emph{et al.} do not give a
nontrivial bound on the input edge weights, leaving users in the fog for exactly when the algorithm works.

\paragraph{Other verifications of minimum-spanning algorithms}In 2019, Lammich et al provided a verification of Prim's and Dijkstra's algorithms~\cite{DBLP:journals/afp/LammichN19}. Haslbeck et al, with Lammich in the same team, verified Kruskal's algorithm in a separate paper~\cite{DBLP:journals/afp/HaslbeckLB19}. The main highlights of their papers are writing efficient data structures in Isabelle/HOL and extracting them to executable code. In Lammich et al, their Prim's implementation explicitly expects a connected graph, and they do not reason about the disconnected case.

Guttman formalised and proved the correctness of Prim's algorithm using Stone relation and Kleene algebras in Isabelle/HOL~\cite{DBLP:conf/ictac/Guttmann16}. They later generalised minimum spanning tree algorithms using Stone relation algebras~\cite{DBLP:journals/jlp/Guttmann18}, and provided a verified proof of Kruskal's algorithm formatted in their algebra. Working in an idealized formal environment, they do not require the development of explicit data structures such as priority-queues and union-find, as these are captured as equivalence relations in their algebra.

Guttman stated in their second paper that their earlier proof of Prim's assumed "every~finite~graph has~a~minimum~spanning~forest". Guttman later proved this by relying on their proof of Kruskal's. We use the same assertion in our proof of Prim's, but in our case, Kruskal's is defined in the spatial layer of our library, not the mathematical-layer, and it would be unwieldy to bring it back up. Instead, we show in the mathematical layer that every finite graph has a finite, nonempty list of spanning forests. Thus there exists a minimum spanning forest by simply taking the minimal-weight forest in this list.

\paragraph{Prim's in algorithms textbooks.} The textbooks we reviewed did not recognise Prim's ability to return forests. CLRS does not discuss disconnected graphs and spanning forests. \textit{Discrete Mathematics and Its Applications}~\cite{rozen} leaves modifying Prim's to return forests as an exercise to the reader. \textit{The Algorithm Design Manual, Second Edition}~\cite{DBLP:books/daglib/0022194} suggests Boruvka’s algorithm, and a combination with Prim's for complexity. \textit{Graph Algorithms in the Language of Linear Algebra}~\cite{kepnergilbert} recommends running Prim's on each component of the disconnected graph.

\textit{Algorithms in a Nutshell}~\cite{heineman2008algorithms} provides a C++ example that aligns with our C implementation. They push their version of \texttt{INF} into the priority queue during the setup, and do not perform any explicit rejections of \texttt{INF}, simply popping from the priority queue at the \texttt{EXTRACT-MIN} step. However, they do not discuss minimum spanning forests, hence this observation is not recorded.

Being in pseudocode and idealized environments, these works do not need to discuss the application of the algorithms on "strange", non-simple graph inputs. Our C implementation does account for such inputs to a small extent, such as the edge list containing multiple edges between two vertices in Kruskal's.

\paragraph{Other graph proof libraries.} Krishna et al~\cite{DBLP:conf/esop/KrishnaSW20} has developed a flow algebraic framework to reason about local and global properties of \textit{flow graphs} in the program heap. Their flow algebra is designed to mainly tackle local reasoning of global graphs in program heaps, tackling similar issues to Wang et al ~\cite{DBLP:journals/pacmpl/WangCMH19}, but in this paper, local reasoning is not required. Their flow algebra is said to be compatible with existing separation logics, although actual implementation and integration with SL tools appears to be an ongoing progress.
%In a related vein, Paulin and Filli\^atre verified Floyd's algorithm in Coq~\cite{paulin}

%@misc{paulin,
%title={The {C}oq proof assistant},
%author={{C}oq development team},
%url={https://coq.inria.fr/}, journal={The Coq Proof Assistant}}
%C. and J.C. Filli\^atre
%http://pauillac.inria.fr/cdrom/www/coq/contribs/floyd.html
%.11. R.Sumners.Corre
%tne


\hide{
\paragraph{Conclusion.}
We described a machine-checked proof of correctness for Dijkstra’s
shortest-path algorithm written in real~C from classic textbook code.
We showed this code suffers from an overflow bug and described a precise 
precondition on edge weights to avoid it.  We put this result 
in the context of our ongoing work.
}