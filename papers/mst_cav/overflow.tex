Dijkstra's algorithm clearly cannot work when a path
cost is more than \texttt{INT\_MAX}.  A reasonable-looking restriction
is to bound edge costs by
$\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}-1}\right\rfloor$, since
the longest optimal path has $\texttt{size}-1$ links and so the
most expensive possible path costs no more than \texttt{INT\_MAX}.
However, this has two flaws.  First, since we are writing real code in~C,
rather than pseudocode in an idealized setting, we must reserve some
concrete \texttt{int} value \texttt{inf} for ``infinity'', with
the semantics that if the best-known distance to a vertex~\m{x}
is \texttt{inf}, then~\m{x} is as-yet unreachable.
A consequence of this is that reachable destination vertices cannot have a
path cost of \texttt{inf}: if they did, this would be logged in the
\texttt{dist} array and create an ambiguity.
Second, even though the best-known distances start at \texttt{inf}
(see line~\ref{code:assigninf}) and only ever decrease from there, the code can
overflow on lines~\ref{code:overflow}~and~\ref{code:update1}.

\begin{figure}[t]
\centering
\begin{tikzpicture}[x=0.3cm, y=0.3cm,
  vert/.style={circle, line width=1pt, draw, fill=red}]
  \node[vert] (A) at (0,0) {\color{white}A};
  \node[vert] (B) [right = 8 of A] {\color{white}B};
  \node[vert] (C) [right = 8 of B] {\color{white}C};
  \draw [->,line width=1pt,arrows={-Stealth}] (A) -- (B);
  \draw [->,line width=1pt,arrows={-Stealth}] (B) -- (C);
  \draw [->,line width=1pt,arrows={-Stealth}] (C.south) .. controls ++(0, -2) .. (B);
  \node at (5,0.6) {5};
  \node at (15,0.6) {5};
  \node at (16,-2.4) {6};
\end{tikzpicture}
\caption{A graph that will result in overflow on a 4-bit machine.}
\label{fig:overflow}
\end{figure}

Consider applying Dijkstra's algorithm on a hypothetical 4-bit unsigned machine to
the graph in figure~\ref{fig:overflow}.  The \texttt{size} of the graph is 3 nodes, and so the na\"ive edge-weight upper bound is $\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}-1}\right\rfloor = \left\lfloor\frac{15}{3-1}\right\rfloor = 7$, for example as in the graph pictured in figure~\ref{fig:overflow}.  Indeed, a glance at the figure is enough to tell that the true distance from the source~A~to vertices~B~and~C~are~5~and~10 respectively---both of which are representable with 4 bits, and so na\"ively all seems well.  %Unfortunately, Dijkstra's algorithm does not exactly work like that.
Indeed, after processing vertices~A~and~B, 5~and~10~\emph{are} the costs reflected in the \texttt{dist} array for~B~and~C respectively---\emph{but unfortunately vertex~C~is still in the priority queue}.  After vertex~C~is popped on line~\ref{code:pop}, we fetch its neighbors in the \texttt{for} loop; the cost from C~to~B~(6)~is fetched on line~\ref{code:cost}.  On line~\ref{code:overflow} the currently optimal cost to~B~(5) is compared with the sum of the optimal cost to~C~(10) plus the just-retrieved cost of the edge from~C~to~B~(6).  Since $10+6$ overflows in 4-bit arithmetic, the comparison is not between~5~and~16 but in fact between~5~and~0!  Thus the code decides that a new cheaper path from~A~to~B~exists (in particular, A$\leadsto$B$\leadsto$C$\leadsto$B) and then trashes the \texttt{dist} and \texttt{prev} arrays on line~\ref{code:update1}.

Our code uses signed \texttt{int} rather than \texttt{unsigned int} so we have undefined behavior rather than defined-but-wrong behavior, but the essence of the overflow is identical.
Our solution is twofold.  First, we restrict the maximum edge cost to $\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}}\right\rfloor - 1$, which in the 4-bit setting just described forces an edge cost of no more than~4.  Consider modifying figure~\ref{fig:overflow} to
have edge weights of~4~rather than~5s~and~6s.  After processing vertices~A~and~B, the distances to~B~and~C are no more than~4~and~8 respectively.  When we process vertex~C, the comparison on line~\ref{code:overflow} is thus between the previous best cost to~B~(4) and the candidate best cost to~B~via~C~(12); there is no overflow and the code behaves as advertised.

The second part of our solution is that we require in the function precondition that $\left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor - 1 < \texttt{inf} \le \texttt{INT\_MAX} - \left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor + 1$.  As long as $\texttt{size} > 1$, this is perfectly realizable  by setting \texttt{inf} to $\texttt{INT\_MAX} - \left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor + 1$, \emph{i.e.} in the 4-bit machine we set \texttt{inf} to $11$.  It may be surprising that infinity has a nontrivial upper bound.  The reason is that line~\ref{code:overflow} implicitly assumes that $\infty + \texttt{cost} = \infty$, which certainly is not true for machine integers!
Lastly, when $\texttt{size} = 1$, the range bound on infinity collapses and \texttt{inf} becomes unrealizable.
Our verification is thus not applicable to single-vertex graphs, a special case for which the shortest-path problem is, in any event, rather uninteresting.

\subsection{Related work on Dijkstra in algorithms and formal methods}
\label{sec:relworkdijkstra}
  %The above bound is novel, and discussion of the potential for overflow in Dijkstra's algorithm largely nonexistant.
We were not able to find a reference that gives a robust, precise,
and full description of the overflow issue we describe above.
Dijkstra's original paper ignores the issue~\cite{DBLP:journals/nm/Dijkstra59}, as does the landmark algorithms textbook CLRS~\cite{clrs}. %does not address overflow. %, although---arguably---this is unnecessary in pseudocode
Sedgewick's book on graph algorithms in~C~\cite{sedgewick} sidesteps the overflow in line~\ref{code:overflow} by requiring weights be in \texttt{double}, which \emph{does} have a well-defined positive infinity value.  However, Sedgewick's sidestep entails enduring the inevitable round-off intrinsic to floating-point arithmetic, and so his algorithm computes approximate optimal costs rather than exact ones.  Sedgewick does not specify any bounds on input edge weights, and accordingly does not (and cannot) provide any bound on this accumulated error.  Sedgewick is silent on how to handle an \texttt{int}-weighted input graph.  Skiena's \emph{Algorithm Design Manual}~\cite{DBLP:books/daglib/0022194} contains exactly the bug we identify: he sets \texttt{inf} to \texttt{INT\_MAX}, so his code will overflow on
line~\ref{code:overflow} when adding $\texttt{inf} + \texttt{cost}$.
To its credit, Heineman \emph{et al.}'s \emph{Algorithms in a Nutshell}~\cite{heineman2008algorithms} takes \texttt{int} edge weights as inputs and mentions overflow as a possibility.  To avoid this overflow, Heineman \emph{et al.} performs the arithmetic in line~\ref{code:overflow} in \texttt{long} to avoid this overflow.  However, Heineman does not give any bounds on edge weights, and when the cumulative edge weights are too high then his code fails silently. %; readers are left in the dark. % for the precondition needed to run the algorithm. %, leaving users in the fog.

%; this cast avoids the problem of $\texttt{inf} + \texttt{cost}$ being less than \texttt{cost} due to overflow

%\emph{et al.} do not bound the input edge weights, so overflow can still occur .
%, and users are left in the fog of confusion for knowing exactly when the algorithm works.

Chen verified Dijkstra in Mizar~\cite{chen2003dijkstra}, Gordon \emph{et al.} formalized the reachability property in HOL~\cite{gordon2003executing}, Moore and Zhang verified it in ACL2~\cite{Moore2005}, Mange and Kuhn verified it in Jahob~\cite{mange2007verifying}, and Klasen verified it in KeY~\cite{klasen2010verifying}.  Liu \emph{et al.} took an alternative SMT-based approach to verify a Java implementation of Dijkstra~\cite{6200101}.  The most recent effort (2019) is by Lammich \emph{et al.}, working within Isabelle/HOL, although they simply return the weight of the shortest path rather than the path itself~\cite{DBLP:journals/afp/LammichN19}.
In general the existing mechanized proofs on Dijkstra verify code defined within idealized formal environments, \emph{e.g.} with unbounded integers rather than machine \texttt{int}s and a distinguished non-integer value for infinity.  None of the previous formal work mentions the overflow we uncover.

% and thus glosses over certain real-world issues, including, as best we
%can tell, the overflow issue we identified. 
