\subsection{Overflow in Dijkstra's algorithm}
\label{sec:dijkoverflow}

Dijkstra's algorithm clearly cannot work when a path
cost is more than \texttt{INT\_MAX}.  A reasonable-looking restriction
is to bound edge costs by
$\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}-1}\right\rfloor$, since
the longest optimal path has $\texttt{size}-1$ links and so the
most expensive possible path costs no more than \texttt{INT\_MAX}.
However, this has two flaws.

First, since we are writing real code in~C,
rather than pseudocode in an idealized setting, we must reserve some
concrete \texttt{int} value \texttt{inf} for ``infinity''.  Suppose we 
set $\texttt{inf}=\texttt{INT\_MAX}$, and that $\texttt{size}-1$ divides \texttt{INT\_MAX}.  Now the longest path can have cost $(\texttt{size}-1)\cdot\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}-1}\right\rfloor = \texttt{INT\_MAX} = \texttt{inf}$.  This creates an unpleasant ambiguity: we cannot tell if the farthest vertex is unreachable, or if it is reachable with legitimate cost \texttt{INT\_MAX}.  We need to adjust our maximum edge weights to leave room for \texttt{inf}; using $\left\lfloor\frac{\texttt{INT\_MAX}-1}{\texttt{size}-1}\right\rfloor$ solves this first issue.

%A consequence of this is that reachable destination vertices cannot have a
%path cost of \texttt{inf}: if they did, this would be logged in the
%\texttt{dist} array and create an ambiguity.  Since Dijkstra assumes a connected
%graph as input, none of the vertices have distance \texttt{inf} once Dijkstra terminates.

\begin{figure}[t]
\centering
\begin{tikzpicture}[x=0.3cm, y=0.3cm,
  vert/.style={circle, line width=1pt, draw, fill=red}]
  \node[vert] (A) at (0,0) {\color{white}A};
  \node[vert] (B) [right = 8 of A] {\color{white}B};
  \node[vert] (C) [right = 8 of B] {\color{white}C};
  \draw [->,line width=1pt,arrows={-Stealth}] (A) -- (B);
  \draw [->,line width=1pt,arrows={-Stealth}] (B) -- (C);
  \draw [->,line width=1pt,arrows={-Stealth}] (C.south) .. controls ++(0, -2) .. (B);
  \node at (5,0.6) {$2^{31}-1$};
  \node at (15,0.6) {$2^{31}-1$};
  \node at (15,-2.4) {$2^{31}-1$};
\end{tikzpicture}
\vspace*{-1.25em}
\caption{A graph that will result in overflow on a 32-bit machine.}
\label{fig:overflow}
\vspace*{-1.75em}
\end{figure}

Second, even though the best-known distances start at \texttt{inf}
(see line~\ref{code:assigninf}) and only ever decrease from there, the code can
overflow on lines~\ref{code:overflow}~and~\ref{code:update1}.
Consider applying Dijkstra's algorithm on a 32-bit unsigned machine to
the graph in figure~\ref{fig:overflow}.  The \texttt{size} of the graph is 3 nodes, and the proposed edge-weight upper bound is $\left\lfloor\frac{\texttt{INT\_MAX}-1}{\texttt{size}-1}\right\rfloor = \left\lfloor\frac{(2^{32}-1)-1}{3-1}\right\rfloor = 2^{31}-1$, for example as in the graph pictured in figure~\ref{fig:overflow}.  A glance at the figure is enough to tell that the true distance from the source~A~to vertices~B~and~C~are~$2^{31}-1$~and~$2^{32}-2$ respectively. Both values are representable with 32 bits, and neither is $\texttt{inf}=2^{32}-1$, so na\"ively all seems well. Unfortunately, Dijkstra's algorithm does not exactly work like that.

After processing vertices~A~and~B, $2^{31}-1$~and~$2^{32}-2$~\emph{are} the costs reflected in the \texttt{dist} array for~B~and~C respectively---\emph{but unfortunately vertex~C~is still in the priority queue}.  After vertex~C~is popped on line~\ref{code:pop}, we fetch its neighbors in the \texttt{for} loop; the cost from C~to~B~($2^{31}-1$)~is fetched on line~\ref{code:cost}.  On line~\ref{code:overflow} the currently optimal cost to~B~($2^{31}-1$) is compared with the sum of the optimal cost to~C~($2^{32}-2$) plus the just-retrieved cost of the edge from~C~to~B~($2^{31}-1$).  Since $(2^{32}-2)+(2^{31}-1)$ overflows in 32-bit arithmetic, the comparison is not between~$2^{31}-1$~and~$3 \cdot 2^{31} - 3$, but in fact between~$2^{31}-1$~and~$2^{31}-3$!  Thus the code decides that a new cheaper path from~A~to~B~exists (in particular, A$\leadsto$B$\leadsto$C$\leadsto$B) and then trashes the \texttt{dist} and \texttt{prev} arrays on line~\ref{code:update1}.

Our code uses signed \texttt{int} rather than \texttt{unsigned int} so we have undefined behavior rather than defined-but-wrong behavior, but the essence of the overflow is identical.  We must ensure that the ``probing edge'' does not overflow by restricting the maximum edge cost further, to $\left\lfloor\frac{\texttt{INT\_MAX}-1}{\texttt{size}}\right\rfloor$.  In our unsigned 32-bit setting, edge weights are bounded by $\left\lfloor\frac{(2^{32}-1)-1}{3}\right\rfloor=1,431,655,764$; call this value $w$.  Now vertex~B~has distance $w$ and~C~has distance $2 \cdot w$.  When we remove~C~from the priority queue, the comparison on line~\ref{code:overflow} is between the known best cost~to~B~($w$) and the candidate best cost to~B~via~C~($3 \cdot w$, that is $2^{32} - 4$).  There is no overflow and the code behaves as advertised.

We place these new restrictions into Dijktra's precondition as $\mathsf{DijkAdjMat}$, which inherits from $\mathsf{AdjMat}$ in~\S\ref{sec:adjmatpure}.
In addition to the bounds discussed above, we require that: edge costs be non-negative, as is typical for Dijkstra; $4 \cdot \texttt{size} \le \texttt{INT\_MAX}$, to ensure that the multiplication in the \texttt{malloc} on line~\ref{code:dijkmalloc} does not overflow; and that $\left\lfloor \frac{\texttt{INT\_MAX} - 1}{\texttt{size}}\right\rfloor \cdot \texttt{size} < \texttt{inf}$, so no valid path has cost \texttt{inf}.  All restrictions are satisfiable with $\texttt{inf} \defeq \texttt{INT\_MAX}$ whenever $0 < 4 \cdot \texttt{size} \le \texttt{INT\_MAX}$.

%, in addition to the standard restrictions we inherit from \texttt{SoundAdjMat} ().

%Our solution is twofold.  First, we restrict the maximum edge cost to , which in the 4-bit setting just described forces an edge cost of no more than~4.  Consider modifying figure~\ref{fig:overflow} to
%have edge weights of~4~rather than~5s~and~6s.  After processing vertices~A~and~B, the distances to~B~and~C are no more than~4~and~8 respectively.  When we process vertex~C, the 
% the previous best cost to~B~(4) and the candidate best cost to~B~via~C~(12); there is no overflow and 

%\note[connected?]{The second part of our solution is that we require in the function precondition that $\left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor - 1 < \texttt{inf} \le \texttt{INT\_MAX} - \left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor + 1$.  As long as $\texttt{size} > 1$, this is perfectly realizable  by setting \texttt{inf} to $\texttt{INT\_MAX} - \left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor + 1$, \emph{i.e.} in the 4-bit machine we set \texttt{inf} to $11$.  It may be surprising that infinity has a nontrivial upper bound.  The reason is that line~\ref{code:overflow} implicitly assumes that $\infty + \texttt{cost} = \infty$, which certainly is not true for machine integers!
%Lastly, when $\texttt{size} = 1$, the range bound on infinity collapses and \texttt{inf} becomes unrealizable.
%Our verification is thus not applicable to single-vertex graphs, a special case for which the shortest-path problem is rather uninteresting. }

\subsection{Related work on Dijkstra in algorithms and formal methods}
\label{sec:relworkdijkstra}
  %The above bound is novel, and discussion of the potential for overflow in Dijkstra's algorithm largely nonexistant.
We were not able to find a reference that gives a robust, precise,
and full description of the overflow issue we describe above.
Dijkstra's original paper ignores the issue~\cite{DBLP:journals/nm/Dijkstra59}, as do the standard textbooks \emph{Introduction to Algorithms} (\emph{a.k.a.} CLRS) by Cormen \emph{et al.}~\cite{clrs} and \emph{Algorithm Design} by Kleinberg and Tardos~\cite{DBLP:books/daglib/0015106}.
% the standard algorithms textbooks by CLRS. %does not address overflow. %, although---arguably---this is unnecessary in pseudocode
Sedgewick's book on graph algorithms in~C~\cite{sedgewick} sidesteps the overflow in line~\ref{code:overflow} by requiring weights be in \texttt{double}, which \emph{does} have a well-defined positive infinity value and cannot overflow in the traditional sense; Sedgewick and Wayne's \emph{Algorithms} textbook in Java does the same~\cite{DBLP:books/daglib/0029345}.  However, Sedgewick's sidestep entails enduring the inevitable round-off intrinsic to floating-point arithmetic, and so his algorithm computes approximate optimal costs rather than exact ones.  Sedgewick does not specify any bounds on input edge weights, and accordingly does not (and cannot) provide any bound on this accumulated error.  Sedgewick is silent on how to handle an \texttt{int}-weighted input graph.  Skiena's \emph{Algorithm Design Manual}~\cite{DBLP:books/daglib/0022194} contains code with exactly the bug we identify: he uses integer weights and does not specify any bounds.  Heineman \emph{et al.}'s \emph{Algorithms in a Nutshell}~\cite{heineman2008algorithms} takes \texttt{int} edge weights as inputs and mentions overflow as a possibility.  Heineman \emph{et al.} hustle their way around this overflow by performing the arithmetic in line~\ref{code:overflow} in \texttt{long}.  However, this cast does not really handle the problem in a fundamental way: if edge weights are given in \texttt{long} rather than \texttt{int}, then it would be necessary to cast to \texttt{long long}; if edge weights are given in \texttt{long long}, then Heineman's hustle breaks as there is no bigger type to which to cast.  Moreover, Heineman \emph{et al.} do not bound edge weights, so when the cumulative edge weights are too high then their code fails silently. %; readers are left in the dark. % for the precondition needed to run the algorithm. %, .leaving users in the fog:

%; this cast avoids the problem of $\texttt{inf} + \texttt{cost}$ being less than \texttt{cost} due to overflow

%\emph{et al.} do not bound the input edge weights, so overflow can still occur .
%, and users are left in the fog of confusion for knowing exactly when the algorithm works.

Chen verified Dijkstra in Mizar~\cite{chen2003dijkstra}, Gordon \emph{et al.} formalized the reachability property in HOL~\cite{gordon2003executing}, Moore and Zhang verified it in ACL2~\cite{Moore2005}, Mange and Kuhn verified it in Jahob~\cite{mange2007verifying}, and Klasen verified it in KeY~\cite{klasen2010verifying}.  Liu \emph{et al.} took an alternative SMT-based approach to verify a Java implementation of Dijkstra~\cite{6200101}.  The most recent effort (2019) is by Lammich \emph{et al.}, working within Isabelle/HOL, although they simply return the weight of the shortest path rather than the path itself~\cite{DBLP:journals/afp/LammichN19}.
In general the existing mechanized proofs on Dijkstra verify code defined within idealized formal environments, \emph{e.g.} with unbounded integers rather than machine \texttt{int}s and a distinguished non-integer value for infinity.  None of the previous formal work mentions the overflow we uncover.

% and thus glosses over certain real-world issues, including, as best we
%can tell, the overflow issue we identified.

