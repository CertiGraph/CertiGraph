Dijkstra's algorithm clearly cannot work when a path
cost is more than \texttt{INT\_MAX}.  A reasonable-looking restriction
is to bound edge costs by
$\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}-1}\right\rfloor$, since
the longest optimal path has $\texttt{size}-1$ links and so the
most expensive possible path costs no more than \texttt{INT\_MAX}.
However, this has two flaws.  First, since we are writing real code in~C,
rather than pseudocode in an idealized setting, we must reserve some
concrete \texttt{int} value \texttt{inf} for ``infinity'', with 
the semantics that if the best-known distance to a vertex~\m{x}
is \texttt{inf}, then~\m{x} is as-yet unreachable.
A consequence of this is that reachable destination vertices cannot have a
path cost of \texttt{inf}: if they did, this would be logged in the
\texttt{dist} array and create an ambiguity.
Second, even though the best-known distances start at \texttt{inf}
(see line~\ref{code:assigninf}) and only ever decrease from there, the code can
overflow on lines~\ref{code:overflow}~and~\ref{code:update1}.

\begin{figure}[t]
\centering
\begin{tikzpicture}[x=0.3cm, y=0.3cm,
  vert/.style={circle, line width=1pt, draw, fill=red}]
  \node[vert] (A) at (0,0) {\color{white}A};
  \node[vert] (B) [right = 8 of A] {\color{white}B};
  \node[vert] (C) [right = 8 of B] {\color{white}C};
  \draw [->,line width=1pt,arrows={-Stealth}] (A) -- (B);
  \draw [->,line width=1pt,arrows={-Stealth}] (B) -- (C);
  \draw [->,line width=1pt,arrows={-Stealth}] (C.south) .. controls ++(0, -2) .. (B);
  \node at (5,0.6) {5};
  \node at (15,0.6) {5};
  \node at (16,-2.4) {6};
\end{tikzpicture}
\caption{A graph that will result in overflow on a 4-bit machine.}
\label{fig:overflow}
\end{figure}

Consider applying Dijkstra's algorithm on a hypothetical 4-bit unsigned machine to
the graph in figure~\ref{fig:overflow}.  The \texttt{size} of the graph is 3 nodes, and so the na\"ive edge-weight upper bound is $\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}-1}\right\rfloor = \left\lfloor\frac{15}{3-1}\right\rfloor = 7$, for example as in the graph pictured in figure~\ref{fig:overflow}.  Indeed, a glance at the figure is enough to tell that the true distance from the source~A~to vertices~B~and~C~are~5~and~10 respectively---both of which are representable with 4 bits, and so na\"ively all seems well.  %Unfortunately, Dijkstra's algorithm does not exactly work like that.
Indeed, after processing vertices~A~and~B, 5~and~10~\emph{are} the costs reflected in the \texttt{dist} array for~B~and~C respectively---\emph{but unfortunately vertex~C~is still in the priority queue}.  After vertex~C~is popped on line~\ref{code:pop}, we fetch its neighbors in the \texttt{for} loop; the cost from C~to~B~(6)~is fetched on line~\ref{code:cost}.  On line~\ref{code:overflow} the currently optimal cost to~B~(5) is compared with the sum of the optimal cost to~C~(10) plus the just-retrieved cost of the edge from~C~to~B~(6).  Since $10+6$ overflows in 4-bit arithmetic, the comparison is not between~5~and~16 but in fact between~5~and~0!  Thus the code decides that a new cheaper path from~A~to~B~exists (in particular, A$\leadsto$B$\leadsto$C$\leadsto$B) and then trashes the \texttt{dist} and \texttt{prev} arrays on line~\ref{code:update1}.

Our code uses signed \texttt{int} rather than \texttt{unsigned int} so we have undefined behavior rather than defined-but-wrong behavior, but the essence of the overflow is identical.
Our solution is twofold.  First, we restrict the maximum edge cost to $\left\lfloor\frac{\texttt{INT\_MAX}}{\texttt{size}}\right\rfloor - 1$, which in the 4-bit setting just described forces an edge cost of no more than~4.  Consider modifying figure~\ref{fig:overflow} to
have edge weights of~4~rather than~5s~and~6s.  After processing vertices~A~and~B, the distances to~B~and~C are no more than~4~and~8 respectively.  When we process vertex~C, the comparison on line~\ref{code:overflow} is thus between the previous best cost to~B~(4) and the candidate best cost to~B~via~C~(12); there is no overflow and the code behaves as advertised.

The second part of our solution is that we require in the function precondition that $\left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor - 1 < \texttt{inf} \le \texttt{INT\_MAX} - \left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor + 1$.  As long as $\texttt{size} > 1$, this is perfectly realizable  by setting \texttt{inf} to $\texttt{INT\_MAX} - \left\lfloor \frac{\texttt{INT\_MAX}}{\texttt{size}} \right\rfloor + 1$, \emph{i.e.} in the 4-bit machine we set \texttt{inf} to $11$.  When $\texttt{size} = 1$, this inequality is not realizable; our verification is thus not applicable to single-vertex graphs, a special case for which the shortest-path problem is in any event rather uninteresting.

