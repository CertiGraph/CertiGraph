\subsection{Speed of loop invariants}
The recommended tactic to solve invariants and ENTAIL goals in VST is \textit{entailer!}. However, we observed that our invariants contained a significiant number of mathematical statements, encoded by VST as PROPs, that were difficult to solve with VST's \textit{entailer!} tactic. As a result, \textit{entailer!} often took a long time to solve or reduce the invariant. To overcome this, we had to pre-solve every PROP in the invariant and preformat the SEP clauses. In the most significant case, an \textit{entailer!} call that took 446 seconds and still returned a large number of unsolved PROPs, was reduced to 36 seconds at the fastest recorded. (Tested on a VirtualBox Lubuntu 18.04 machine assigned 8GB RAM and 2 processors)

That the tactic could not solve many of our invariant \texttt{PROP}s by itself was expected and reasonable, as they were often complex properties of graphs. However, we were surprised that several solved \texttt{PROP}s took a significant amount of time despite being trivial at first glance. This is especially noticed in PROPs with preconditions of elements in empty lists. Thus, an immediate suggestion to the \textit{entailer!} tactic is to test "\textit{try contradiction}" as early as possible.
\begin{lstlisting}
assert (Hinv_10: forall u v : V,
	In u (nil (A:=V)) -> In v (nil (A:=V)) ->
	connected g u v <-> connected edgeless_graph' u v). {
		intros. contradiction.
}
\end{lstlisting}
The above Coq assertion in our loop precondition, which was easily solved by two basic tactics, cost an additional 50s when left to \textit{entailer!} to prove.
\newline\newline
Given the possibility that invariants carry PROPs on abstract graph properties that we do not expect \textit{entailer!} to solve, a thought is to provide a reduced version of \textit{entailer!} that does not reason about PROPs at all, but leaves them to the user to solve, and focuses on more VST-specific issues such as SEP and LOCAL clauses. This will be useful for verification of functions that implement abstract models.

\subsection{Shared clightgen issue with libraries.} It is obvious that one must include the dependencies of the program when compiling C code. However, we observe an issue of the opposite nature in VST and CompCert - that when running \textit{clightgen} for a program, one must include all programs using the same dependency to properly regenerate the AST file of said dependency. Failure to do so results in the proof of the other program failing to run.

For instance, in the above figure, both Dijkstra's and Prim's implementations are dependent on the same verified priority queue. When running clightgen for Prim's, we include the priority queue's C implementation to regenerate the AST tree. However, without including Dijkstra's in the same command, the existing verification of Dijkstra's experiences an error over the priority queue's newly regenerated AST file.

This is a hindrance to the modular design we aspire to, and we believe is worth looking into, to see if the error is caused by a trivial matter in CompCert's clightgen or worse.