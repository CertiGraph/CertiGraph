\subsection{Speed of loop invariants}
The recommended tactic to solve invariants and ENTAIL goals in VST is \textit{entailer!}. However, we observed that our invariants contained a significiant number of mathematical statements, encoded by VST as PROPs, that were difficult to solve with VST's \textit{entailer!} tactic. As a result, \textit{entailer!} often took a long time to solve or reduce the invariant. To overcome this, we had to pre-solve every PROP in the invariant and preformat the SEP clauses. In the most significant case, an \textit{entailer!} call that took 446 seconds and still returned a large number of unsolved PROPs, was reduced to 36 seconds at the fastest recorded. (Tested on a VirtualBox Lubuntu 18.04 machine assigned 8GB RAM and 2 processors)

That the tactic could not solve many of our invariant \texttt{PROP}s by itself was expected and reasonable, as they were often complex properties of graphs specific to CertiGraph. However, we were surprised that several solved \texttt{PROP}s took a significant amount of time despite being trivial at first glance.
\begin{lstlisting}
assert (Hinv_10: forall u v : V,
	In u (nil (A:=V)) -> In v (nil (A:=V)) ->
	connected g u v <-> connected edgeless_graph' u v). {
		intros. contradiction.
}
\end{lstlisting}
The above Coq goal in our loop's precondition cost an additional 50s when left to \textit{entailer!}, when it can be manually asserted and solved with two basic tactics.
\newline\newline
Given that the invariants of graph algorithms carry PROPs on abstract graph properties that we do not expect \textit{entailer!} to solve, a thought is to provide a reduced version of \textit{entailer!} that does not reason about PROPs at all, but leaves them to the user, and focuses on more VST-specific issues such as SEP and LOCAL clauses. This will be useful for verification of functions that implement abstract models.

\subsection{Shared clightgen issue with libraries} It is obvious that one must include the dependencies of the program when compiling C code. However, we observe an issue of the opposite nature in VST and CompCert - that when running \textit{clightgen} for a program, one must include all programs using the same dependency to properly regenerate the AST file of said dependency. Failure to do so results in the proof of the other program failing to run.

For instance, in the above figure, both Dijkstra's and Prim's implementations are dependent on the same verified priority queue. When running \textit{clightgen} for Prim's, we include the priority queue's C implementation to regenerate the AST tree. However, without including Dijkstra's in the same command, the existing verification of Dijkstra's experiences an error over the priority queue's newly regenerated AST file.

This is a hindrance to the modular design we aspire to, and we believe it is worth looking into, to see if the error is caused by a trivial matter in CompCert's \textit{clightgen} or worse.

%\subsection{Slowdown from direct access of struct fields}
\subsection{Sorting for Kruskal's: VST's CBench quicksort}

During the verification of Kruskal's, we looked into existing verified sorts. In particular, we found that VST has verified a simple version of quicksort for the CBench\cite{DBLP:journals/corr/abs-1904-01009} challenge. Originally, we opted to modify their code and proof for struct sorting, when we observed the following.

\begin{lstlisting}
Definition quicksort_spec :=
	DECLARE _quicksort
	WITH gv : globals, m: int, n: int, before: list val,
		al: list val, after: list val
		PRE  [ tint, tint] 
			PROP(if zlt (Int.signed m) (Int.signed n)
				then   (Zlength before = Int.signed m 
				/\ Zlength after = N-(Int.signed n+1)
				/\ Zlength al = Int.signed n+1- Int.signed m)
				else al=nil;
				Forall def_float al)
			PARAMS(Vint m; Vint n) GLOBALS (gv)
			SEP(data_at Ews (tarray tdouble N) 
				(before ++ al ++ after) (gv _a))
		POST [ tvoid ]
		EX bl: list val,
			PROP(Permutation al bl; sorted (f_cmp Cle) bl) 
			LOCAL ()
			SEP(data_at Ews (tarray tdouble N)
			(before ++ bl ++ after) (gv _a)).
\end{lstlisting}
The if-else $PROP$ caught our attention when using the. In particular, we realised that to use this specification, we need to split the proof into two cases whenever the C code calls \texttt{quicksort()} and feed in separate parameters to the \texttt{forward\_call} tactic. One when $m~<~n$ which is the typical case; and the latter where $m~\geq~n$, which means we're sorting a $0-or-1-length$ subsection of the array. In the latter case, we have to provide $al$ as $nil$ in the $forward\_call$ tactic and push the last tactic. The following snippets were taken from \url{https://github.com/cverified/cbench-vst}, commit 2c140bb78fa4497966e55b831f3d2a19afe8d750.

\begin{lstlisting}
//qsort1.c
void
quicksort(int m, int n)
{
	...
	quicksort(m, j);
\end{lstlisting}
\begin{lstlisting}
//verif_qsort1.v
Lemma body_quicksort:
	semax_body Vprog Gprog f_quicksort quicksort_spec.
...
destruct (zlt m j).
* ...
forward_call (gv,Int.repr m, Int.repr j,before,
	sublist 0 (j+1-m) bl, (sublist (j+1-m) (n+1-m) bl)++after).
...
* ...
forward_call (gv, Int.repr m, Int.repr j, before,
	@nil val, bl ++ after).
\end{lstlisting}

From VST's above proof, the proof has to be split and reasoned with two \texttt{forward\_call}s containing different parameters, for the function call in the C code. The latter state happens when \textbf{quicksort operates on a subsection with one element}, which is a natural state that can be reached by quicksorting an array of odd length. However we have to force that one-element into \texttt{bl} and tell the proof to use \texttt{nil} as \texttt{al} instead. We believe the change of \texttt{zlt} to \texttt{zle} will allow the use of a single \texttt{foward\_call} for the single \texttt{quicksort()} C call, without supplying an arbitrary \texttt{nil} into \texttt{al}. To avoid conflicting with VST, who developed this proof against a benchmark, we opted to verify our own sort instead in \texttt{kruskal/verif\_sort.v}.
%\subsection{Malloc}