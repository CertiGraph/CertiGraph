We verify a standard C implementation of Dijkstra's algorithm.
First, we sketch our proof in some detail with an emphasis on our loop invariants,
before uncovering and handling a subtle overflow bug.

\subsection{Verified Dijkstra's algorithm in C}
\label{sec:dijkoverview}

Figure~\ref{fig:decorated} shows the code and proof
sketch of Dijkstra's algorithm.
{\color{red}Red} text in an annotation indicates changes compared to the
annotation immediately prior.
Our code is implemented exactly
as suggested by CLRS~\cite{clrs}, so we refer readers there for a
general discussion of the algorithm.
The adjacency-matrix-represented graph~$\gamma$ of \texttt{size} vertices
is passed as the parameter \texttt{g} along with the source vertex \texttt{src}
and two allocated arrays \texttt{dist} and \texttt{prev}.
The spatial predicate $\mathsf{array}(\texttt{x},\vec{v})$, which connects
an array pointer \texttt{x} with its contents $\vec{v}$, is standard and unexciting.
$\mathsf{PQ}(\texttt{pq},\m{heap})$ is the spatial
representation of our priority queue (PQ) and
$\mathsf{Item}(\texttt{i},\m{(key, pri, data)})$
lays out a struct that we use to interact with the PQ;
we leave the management of the PQ to the operations described in~\S\ref{sec:binheap}.
Of greater interest is $\mathsf{AdjMat}(\texttt{g},\gamma)$, which
links the concrete memory values of~\texttt{g} to an abstract mathematical
graph~$\gamma$, which in turn exposes an interface in the
language of graph theory (vertices, edges, labels, \emph{etc.}).
As discussed in \S\ref{blah}, we develop three variations of
adjacency-matrix representation.
Thanks to some careful engineering, the C code and
the Coq verification are both almost completely agnostic to
the form of representation. The only variation between implementations
is when reading a cell (line~\ref{code:cost}), so we
refactor this out into a straightforward helper method and
verify it separately.

\input{poster_code_dijk.tex}


\hide{In general, these spatial representations are simple enough
that they pose no special
challenge in the proof. Therefore, in our discussion below, we
will not focus on issues such as making sure an array dereference is in bounds.
} %hide

Dijkstra's algorithm uses a PQ to greedily choose the
cheapest unoptimized vertex on line~\ref{code:pop}. The
best-known distances to vertices are expected to improve as
various edges are relaxed, and such improvements need to be logged in the PQ:
Dijkstra's algorithm implicitly assumes that its~PQ supports the additional
operation \texttt{decrease\_priority}.
Our ``advanced''~PQ~(\S\ref{sec:modpri})
supports this operation in logarithmic time with the
\texttt{pq\_edit\_priority} function\footnote{Because
\texttt{decrease\_priority} is relatively complex to implement,
several popular~\cite{blah,blah,blah}
workarounds use simpler PQs at the cost
of decreased performance.}.
% each \texttt{pop\_min} now takes $\bigO(n)$ time.

%Note that \texttt{dist} already tracks the best-known cost
%to any vertex (line~\ref{code:update1}). Maintain a list of
%vertices that have been optimized.
%Find the cheapest unoptimized vertex by
%iterating over \texttt{dist} while rejecting optimized items.
%Neat, but far too slow.

The first nine lines are standard setup. 
The \emph{keys} array, assigned on line~\ref{code:assigninf}, 
is thereafter a mathematical constant.
The pure predicate \m{linked\_correctly} contains the plumbing connecting the 
various mathematical arrays.
The verification turns on the loop
invariants on lines~\ref{code:whileinv} and~\ref{code:forinv}.  The pure \texttt{while} invariant $\m{dijk\_correct}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist})$ essentially unfolds into:
\[
\begin{array}{l}
\forall \m{dst}.~\texttt{0} \le \m{dst} < \texttt{size} -> \m{inv\_popped}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst}) /| \null \\
\hspace{10.7em}\m{inv\_unpopped}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst}) /| \null \\
\hspace{10.7em}\m{inv\_unseen}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst})
\end{array}
\]
That is, a destination vertex $\m{dst}$ falls into one of three
categories:
\begin{enumerate}
\item $\m{inv\_popped}$: $\m{dst}$ has been fully processed and
popped from the PQ.
Either \m{dst} is unreachable, meaning that there exists no finite-cost path from
\m{src}~to~\m{dst}, or \m{dst} is reachable, meaning that a globally optimal
path from $\m{src}$~to~$\m{dst}$ exists, the cost of this path is logged in
\m{dist}, all vertices visited by the path are also popped,
and the links of the path are logged in~\m{prev}.
\item $\m{inv\_unpopped}$: $\m{dst}$ is reachable in
one step from a popped vertex \m{mom}.
This route is locally optimal: we cannot
improve the cost via an alternate popped vertex.
\m{prev} logs
\m{mom} as the best-known way to reach $\m{dst}$, and \m{dist}
logs the path cost via \m{mom} as the best-known cost.
\item $\m{inv\_unseen}$: no finite-cost path exists from any popped vertex to
$\m{dst}$.
\end{enumerate}
After line~\ref{code:pop},
the above invariant is no longer true: a minimum-cost item~\m{u} has been
popped from the PQ, and so the \m{dist} and \m{prev} arrays need to be
updated to account for this pop. The \texttt{for} loop does exactly this repair work.
Its pure invariant
$\m{dijk\_correct\_weak}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{u}, \m{i})$ essentially unfolds into:
\[
\begin{array}{l}
\forall \m{dst}.~\texttt{0} \le \m{dst} < \texttt{size} -> \m{inv\_popped}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst}) /| \null \\
\forall \m{dst}.~\texttt{0} \le \m{dst} < \m{i} -> \m{inv\_unpopped}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst}) /| \null \\
\hspace{9em}\m{inv\_unseen}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst}) /| \null \\
\forall \m{dst}.~\m{i} \le \m{dst} < \texttt{size} -> \m{inv\_unpopped\_weak}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst}, \m{u}) /| \null \\
\hspace{10.6em}\m{inv\_unseen\_weak}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{dst}, \m{u})
\end{array}
\]
We now have five cases, many of which are familiar from $\m{dijk\_correct}$:
\begin{enumerate}
\item $\m{inv\_popped}$: $\m{dst}$ has been fully processed and
popped from the PQ.  For all ``previously-popped vertices'' (\emph{i.e., }except for~\m{u}),
this is trivial from $\m{dijk\_correct}$. For~\m{u} itself, we reach the heart of Dijkstra's correctness:
the locally-optimal path to the cheapest unpopped vertex is
\emph{globally} optimal.
%the cost to the unpopped vertex with minimum cost cannot be further improved.  %The associated entailment is not trivial.
\item $\m{inv\_unpopped}$ (less than \m{i}): $\m{dst}$ is reachable in
one hop from a popped vertex \m{mom}. Initially this is trivial since $\m{i}=0$, and we restore it as \m{i} increments by updating costs when they can be improved, as on lines~\ref{code:update1}~and~\ref{code:update2}.
\item $\m{inv\_unseen}$ (less than \m{i}): no finite-cost path exists from any popped vertex to $\m{dst}$. As above, this is restored as \m{i} increments.
\item $\m{inv\_unpopped\_weak}$ (between \m{i} and \texttt{size}):
$\m{dst}$ is reachable in one hop from a previously-popped vertex \m{mom},
with further improvements possible via~\m{u}.
This fact is key: as~$\m{i}$ increments, we strengthen it
into $\m{inv\_unpopped}$ after considering whether routing via
\m{u} improves the best-known cost to~\m{dst}.
\item $\m{inv\_unseen\_weak}$ (between \m{i} and \texttt{size}):
no finite-cost path exists from any previously-popped vertex to
$\m{dst}$, but there may be one from~\m{u}.
As~$\m{i}$ increments, we consider whether routing via~\m{u}
reveals a finite-cost path to~\m{dst}.
This is strengthened into
$\m{inv\_unpopped}$ if so, and into
$\m{inv\_unseen}$ if not.
\end{enumerate}
At the end of the \texttt{for} loop
the fourth and fifth cases fall away
(\texttt{\m{i}~=~size}), and the PQ and the \m{dist} and \m{prev} arrays
finish ``catching up'' to the pop on line~\ref{code:pop}.
This allows us to infer
the \texttt{while} invariant $\m{dijk\_correct}$,
and thus continue the \texttt{while} loop.
The \texttt{while} loop itself breaks when all vertices have been popped
and processed. The second and third clauses of the \texttt{while} loop invariant
$\m{dijk\_correct}$ then fall away, as seen on line \ref{code:end}:
all vertices satisfy \m{inv\_popped}, and are either optimally reachable or altogether unreachable.
We are done.

\hide{

While loop's invariant, which is stated on line
and explained further in Figure~\ref{fig:defns}.


This three-part invariant is trivially true before the while loop.
On line~\ref{code:pop}, the minimal vertex from the priority queue is popped,
thus breaking the invariant.

First, we must show that the minimal vertex $\m{u}$
obeys $\m{inv\_popped}$. \emph{i.e.}, show that the locally
optimal path to $\m{u}$ is, in fact, globally optimal.
This comes from blah blah blah

\newcommand{\s}{11}
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[x=0.3cm, y=0.3cm,
      popped/.style={rounded corners=5pt, line width=1pt, draw, fill=MidnightBlue},
      fringe/.style={rounded corners=5pt, line width=1pt, draw, fill=ProcessBlue},
      popping/.style={rounded corners=5pt, line width=1pt, draw, dashed, fill=pink},
      unseen/.style={rounded corners=5pt, line width=1pt, draw}]
    \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
    \draw[fringe] (1.5,1.5) -- (9.5,1.5) -- (9.5,9.5) -- (1.5,9.5) -- cycle;
    \draw[popped] (3,3) -- (8,3) -- (6,6) -- (3,8) -- cycle;
    \node at (1.4,1) {dst$_3$};
    \node at (2.9,2.5) {dst$_2$};
    \node at (4.4,4) {\color{white}dst$_1$};
    \node at (6.6,7) {u};
    \tikzset{shift={(13.5,0)}}

    \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
    \draw[fringe] (1.5,1.5) -- (9.5,1.5) -- (9.5,9.5) -- (1.5,9.5) -- cycle;
    \draw[popping] (3,3) -- (8,3) -- (8,8) -- (3,8) -- cycle;
    \draw[popped] (3,3) -- (8,3) -- (6,6) -- (3,8) -- cycle;
    \node at (1.4,1) {dst$_3$};
    \node at (2.9,2.5) {dst$_2$};
    \node at (4.4,4) {\color{white}dst$_1$};
    \node at (6.6,7) {u};

    \tikzset{shift={(13.5,0)}}

    \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
    \draw[fringe] (1.5,1.5) -- (9.5,1.5) -- (9.5,9.5) -- (1.5,9.5) -- cycle;
    \draw[popped] (3,3) -- (8,3) -- (8,8) -- (3,8) -- cycle;
    \node at (1.4,1) {dst$_3$};
    \node at (2.9,2.5) {dst$_2$};
    \node at (4.4,4) {\color{white}dst$_1$};
    \node at (6.6,7) {\color{white}u};
  \end{tikzpicture}
  \caption{Popping $\m{u}$}
\end{figure}

Next, we must account for the ripple effect that popping
$\m{u}$ could have had on the other vertices.
In particular, it is possible that a vertex obeying $\m{inv\_unpopped}$ can
improve its cost via $\m{u}$, and that an unreachable vertex
obeying $\m{inv\_unseen}$ can now be reached via $\m{u}$.
The for loop repairs these breakages by
checking if a path via $\m{u}$ is an improvement for such vertices, and, if so,
edits both arrays and the priority queue as seen on line~\ref{code:update}.

The for loop's invariant is similar to that of the while loop---$\m{inv\_unseen}$
and $\m{inv\_popped}$ are preserved as-is, modulo the popping of
$\m{u}$ as discussed above. The key edit is in $\m{inv\_unpopped}$. blah blah blah

}

\subsection{Overflow in Dijkstra's algorithm}
\label{sec:dijkoverflow}
\input{overflow.tex}




