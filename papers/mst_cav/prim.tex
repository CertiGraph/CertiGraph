\begin{figure}
\begin{BVerbatim}[baseline=c]
MST-PRIM(G,w,r)
for each u in G.V
  u.key = INF
  u.parent = NIL
r.key = 0
Q = G.V
while Q < 0
  u = EXTRACT-MIN(Q)
  for each v in G.Adj[u]
    if v in Q and w(u,v) < v.key
      v.pi = u
      v.key = w(u,v)
\end{BVerbatim}
\quad\quad
\begin{BVerbatim}[baseline=c]
MST-NOROOT-PRIM(G,w)
for each u in G.V
  u.key = INF
  u.parent = NIL

Q = G.V
while Q < 0
  u = EXTRACT-MIN(Q)
  for each v in G.Adj[u]
    if v in Q and w(u,v) < v.key
      v.pi = u
v.key = w(u,v)
\end{BVerbatim}
\caption{Left: abstract Prim's algorithm from CLRS~\cite{clrs}. Right: the algorithm omitting the root, which is unnecessary. Note that CLRS does not explicitly define \texttt{EXTRACT-MIN}}
\end{figure}
\subsection{Undirected adjacency matrix representation}

We chose a symmetrical matrix representation for the undirected graph to be used in Prim's algorithm. This bears similarities to the adjacency matrix used in Dijkstra's, allowing us to reuse many properties about adjacency matrices.

We observe one quirk about a symmetric undirected matrix. In our abstract graphs, which are fundamentally directed, the abstract edges $(u,v)$ and $(v,u)$ where $u \neq v$ are clearly distinct from each other. However, in a symmetric matrix both $g[u][v]$ and $g[v][u]$ will be marked, thus it is unclear which edge is in the graph. To disambiguate, we impose the following condition: If $g[u][v]$ and $g[v][u]$ is marked, and $u \leq v$, then we consider $(u,v)$ to be the valid edge; if $v \textless u$, then $(v,u)$ is the valid edge.

\subsection{Base algorithm of Prim's returning a forest}

Textbook discussions of Prim's algorithm are often limited to the case where the input graph is a connected graph. This is reasonable, as their purpose is to teach the concept of minimum-spanning \textit{tree} algorithms. However, they seldom expand on the subject of spanning forests for disconnected graphs. For example, CLRS does not mention the case of disconnected graphs. \textit{Discrete Mathematics and Its Applications}~\cite{rozen} leaves it as an exercise to the reader, while \textit{Graph Algorithms in the Language of Linear Algebra}~\cite{kepnergilbert} suggests running Prim's on each component of the disconnected graph to obtain a minimum spanning forest. The last appears to be the most common solution, with lectures and practical implementations suggesting this.

We observed that our code is able to return a minimum spanning forest when the input graph is disconnected \textit{in a single run}. The reason for this is: We treat a vertex of weight \texttt{INF} and a vertex's membership in the priority queue as \textit{separate} matters. A vertex can be in the priority queue with weight \texttt{INF}, represented by \texttt{key[u] = INF}, and this indicates that \texttt{u} is \textit{not} connected to any previously popped vertex; otherwise its weight would have been previously lowered. However, our priority queue does not care about its items having specific weights, only that the item it pops is always the one with the lowest weight. Thus, when a vertex \texttt{u} is returned, it is possible that \texttt{u} has weight \texttt{INF} - the scenario where all vertices remaining in the queue has weight \texttt{INF}, indicating all of them are disconnected from the current forest.

\begin{figure}[H]
\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
\node[state] (V0) {$\m{v_0}$};
\node[state] (V1) [right=of V0] {$\m{v_1}$};
\node[state] (V2) [below=of V0] {$\m{v_2}$};
\node[state] (V3) [below right=of V0] {$\m{v_3}$};
\node[color=green] (V4) [right=of V3] {$\m{v_3}$};
\node[color=green] (V5) [right=of V4] {$\m{v_5}$};
\draw[color=red] (V0) edge [ultra thick] node[above=0.15 cm] {$5$} (V1);
\path (V0) edge node[left=0.15 cm] {$6$} (V2);
\path (V0) edge [thin] node[above right=0.05 cm] {$5$} (V3);
\path[color=red] (V1) edge [ultra thick] node[right=0.15 cm] {$5$} (V3);
\path[color=red] (V2) edge [ultra thick] node[below=0.15 cm] {$4$} (V3);
\path (V4) edge node[below=0.15 cm] {$1$} (V5);
\end{tikzpicture}
\caption{Figure of a partial Prim's execution with root $\m{v_0}$. A spanning tree for the left component has been found as indicated in red, while $\m{v_4}$ and $\m{v_5}$ are in the priority queue with weight \texttt{INF}. As our \texttt{EXTRACT-MIN} tolerates \texttt{INF}, our implementation will pop them from the priority queue and proceed as usual, instead of terminating with only the left tree.}
\end{figure}

From the above figure, we demonstrate that our simple priority queue will always pop vertices regardless of its weight. If the popped vertex has weight \texttt{INF}, its parent will also be at its default invalid value, indicating that no edge was added to the graph. We then continue the algorithm as usual, updating the weights of adjacent vertices. As a result, our Prim implementation can return a minimal spanning forest without ``premature termination".

Is our assumption that \texttt{EXTRACT-MIN} can pop \texttt{INF} weight vertices reasonable? We argue that it is, because the abstract algorithm in CLRS makes no claim what to do with weight \texttt{INF} during the algorithm. As the algorithm pushes the vertices into queue with weight \texttt{INF}, it is reasonable to say the priority queue can tolerate items with weight \texttt{INF}. Doing so simplifies \texttt{EXTRACT-MIN} to a pop operation using the priority queue's API, without requiring additional lines of code to further check for specific weights.

Consequently, our code allows a simple implementation of Prim's to return a forest for a disconnected input graph, in a single run of the algorithm without needing to identify the disconnected components beforehand. It is important to note that we do not explicitly define ``components", nor do we tag \texttt{u} as a``new root". It is sufficient to prove that the loop invariant is satisfied whether \texttt{key[u]~< INF} or \texttt{key[u] = INF}.

Note that the priority queue used for this verification is still tied to \texttt{INF}, and thus in the verification our argument is weakened to ``\texttt{INF} is a valid weight in the priority queue" rather than ``membership in the priority queue is independent of \texttt{INF}". Work on a stronger priority queue which completely dissociates from \texttt{INF} was to be delivered by Aquinas Hobor since May 2020.

A further observation is that in this version, the input root required by Prim's is no longer necessary. The root's key is artificially set to 0 in Prim's, which kickstarts the main loop. However, since our emptiness check and \texttt{EXTRACT-MIN} implementation can return vertices with \texttt{INF} weight, the loop will proceed as long as there are un-popped vertices. Thus, we suggest it is possible to remove the \texttt{rt} parameter. Doing so simplifies the proof, because we do not have to reason about the artificially weighted \texttt{key[rt]}. The noroot-variant is in Figure 4 at the beginning of this section, while the verified implementation of Prim's without root is in \texttt{noroot\_prim.c}.