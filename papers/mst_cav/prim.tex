Here we discuss our verifications of the classic MST algorithms Prim and Kruskal.  Although our machine-checked proofs are about real~C~code, in this section we take a higher-level approach than we did in \S\ref{sec:dijkstra}, focusing on our key algorithmic findings and overall experience.  Accordingly, we only provide pseudocode for Prim's algorithm rather than a decorated program and do not show any code for Kruskal's.  Our development contains our~C~code and formal proofs~\cite{anonrepo}.

%\vspace*{-0.25em}

\subsection{Prim's Algorithm}
\label{sec:prim}

%\vspace*{-0.25em}

\begin{figure}[t]
\[
\begin{array}{@{}l@{~~}|@{~~}l@{}}
\begin{minipage}{0.475\textwidth}
\begin{lstlisting}
MST-PRIM(G,w,r):
 for each u in G.V
  u.key = INF
  u.parent = NIL $\hide{code:primsetinitparent}$
 r.key = 0 $\label{code:primsetroot}$
 Q = G.V
 while Q $\neq$ $\emptyset$
  u = EXTRACT-MIN(Q) $\hide{code:primextractmin}$
  for each v in G.Adj[u]
   if v $\in$ Q and w(u,v) $<$ v.key
    v.parent = u
    v.key = w(u,v) $\hide{code:primeditpri}$
\end{lstlisting} \end{minipage} &
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}[numbers=none]
MST-NOROOT-PRIM(G,w):
 for each u in G.V
  u.key = INF
  u.parent = NIL

 Q = G.V
 while Q $\neq$ $\emptyset$
  u = EXTRACT-MIN(Q)
  for each v in G.Adj[u]
   if v $\in$ Q and w(u,v) $<$ v.key
    v.parent = u
    v.key = w(u,v)
\end{lstlisting}
\end{minipage}
\end{array}
\]
%\vspace*{-1.25em}
\caption{Left: Prim's algorithm from CLRS~\cite{clrs}. Right: the same omitting line 5.}
%\vspace*{-1.25em}
\label{fig:prims}
\end{figure}

We put the pseudocode for Prim's algorithm in figure~\ref{fig:prims}; the code on the left-hand side is directly from CLRS, whereas the code on the right omits line 5 and will be discussed in~\S\ref{sec:primforest}.  Note that line 12 contains an implicit call to the PQ's \texttt{edit\_priority}.  Since the pseudocode only compares \texttt{key}s (\emph{i.e.}, edge weights) rather than doing arithmetic on them \emph{\`a la} Dijkstra, there are no potential overflows and it is reasonable to set \texttt{INF} to \texttt{INT\_MAX} in~C.

Indeed, our initial verifications of~C~code were largely ``turning the crank'' once we had the definitions and associated lemma support for pure/abstract undirected graphs, forests, \emph{etc.} discussed in \S\ref{sec:newundirected}.  Accordingly, our initial contribution was a demonstration that this new graph machinery was sufficient to verify real code.  We also proved that our extensions to CertiGraph from~\S\ref{sec:extensions} were generic rather than verification-specific by reusing much pure and spatial reasoning that had been originally developed for our verification of Dijkstra.

%\vspace*{-0.25em}

\subsection{Prim's Algorithm handles multiple components out of the box}
\label{sec:primforest}

%\vspace*{-0.25em}

Textbook discussions of Prim's algorithm are usually limited to single-component input graphs (\emph{a.k.a.} connected graphs), producing a minimum spanning tree.  It is widely believed that Prim's is not directly applicable to graphs with multiple components, which should produce a minimum spanning forest.  For example, both Rozen~\cite{rozen} and Sedgewick \emph{et al.}~\cite{sedgewick,DBLP:books/daglib/0029345} leave the extension to multiple components as an formal exercise for the reader, whereas Kepner and Gilbert suggest that multiple-component graphs should be handled by first finding the components and then running Prim on each component~\cite{kepnergilbert}.  This appears to be the standard solution, appearing in numerous lectures and implementations\footnote{Another standard solution is to use Kruskal's \hide{or Boruvka's~\cite{boruuvka1926jistem}} algorithm instead.}. %CLRS does not mention the case of disconnected graphs

After we completed our initial verification, a close examination of our formal invariants showed us that the algorithm \emph{exactly as given by standard textbooks} will properly handle multi-component graphs \textit{in a single run}.  The confusion starts because, in a fully connected graph, any vertex $\texttt{u}$ removed from the PQ on line~8 must have $\texttt{u.key} < \texttt{INF}$; \emph{i.e.}, $\texttt{u}$ must be immediately reachable from the spanning tree that is in the process of being built.  However, nothing in the code relies upon this connectedness fact!  All we need is that $\texttt{u}$ is the ``closest vertex'' to the ``current component.''  If $\texttt{u.key}=\texttt{INF}$ \emph{and} \texttt{u} is a minimum of the PQ, then it simply means that the ``previous component'' is done, and we have started spanning tree construction on a new unconnected component ``rooted'' at \texttt{u}, yielding a forest.  The node $\texttt{u}$'s parent will remain \texttt{NIL}, at it was after the setup loop on line~4, indicating that it is the root of a spanning tree.  Its \texttt{key} will be $\texttt{INF}$ rather than $0$, but the \texttt{key}s are \emph{internal to Prim's algorithm}: clients only get back the spanning forest as encoded in the \texttt{parent} pointers\footnote{The \texttt{key}s simply record the edge-weight connecting a vertex to its candidate parent; recall that line~12 is really a call to the PQ's \texttt{edit\_priority}.  If a client wishes to know this edge weight, it can simply look up the edge in the graph.}.

Having made this discovery, we updated our proofs to support the new weaker precondition, which is what we currently formally verify in Coq~\cite{Coq}.
A little further thought led to the realization that since Prim can handle arbitrary numbers of components, the initialization of the root's \texttt{key} in line~5 is in fact unnecessary.  Accordingly, if we remove this line and the associated function argument \texttt{r} from \texttt{MST-PRIM} (\emph{i.e.}, the code on the right half of figure~\ref{fig:prims}), the algorithm still works correctly.  Moreover, \emph{the program invariants become simpler} because we no longer need to treat a specified vertex (\texttt{r}) in a distinguished manner.  Our formal development verifies this version of the algorithm as well~\cite{anonrepo}.

\subsection{Related work on Prim in algorithms and formal methods}
\label{sec:relworkprim}

Prim's algorithm was in fact first developed by the Czech mathematician Vojt\v{e}ch Jarn\'{i}k in 1930~\cite{prim1:jarnik} before being rediscovered by Robert Prim in 1957~\cite{prim2:prim} and a third time by Edsger~W.~Dijkstra in 1959~\cite{prim3:dijkstra}.  Both Prim's and Dijkstra's treatment explicitly assumes a connected graph; although we cannot read Czech, some time with Google translate suggests that Jarn\'{i}k's treatment probably does the same.  The textbooks we surveyed \cite{kepnergilbert,sedgewick,DBLP:books/daglib/0029345,rozen,DBLP:books/daglib/0022194,clrs,DBLP:books/daglib/0015106} seem to derive from Prim's and/or Dijkstra's treatment.
More casual references such as Wikipedia~\cite{prim:wiki} and innumerable lecture slides are presumably derived from the textbooks cited.  We have not found any references that state that Prim's algorithm \emph{without modification} applies to multi-component graphs, even when executable code is provided: \emph{e.g.}, Heineman \emph{et al.} provide C++ code that aligns closely with our C code~\cite{heineman2008algorithms}, but do not mention that their code works equally well on multi-component graphs.  Indeed, many sources promulgate the false proposition that modifications to the algorithm are needed to handle multi-component graphs (\emph{e.g.},~\cite{kepnergilbert,sedgewick,DBLP:books/daglib/0029345,rozen,prim:wiki}).  Likewise, we have found no reference that removes the initialization step (line~5~in figure~\ref{fig:prims}) from the standard algorithm.

Prim's algorithm has been the focus of a few previous formalization efforts.  Guttman formalised and proved the correctness of Prim's algorithm using Stone-Kleene relation algebras in Isabelle/HOL~\cite{DBLP:conf/ictac/Guttmann16}.  He works in an idealized formal environment that does not require the development of explicit data structures; his code does not appear to be executable.  Lammich \emph{et al.} provided a verification of Prim's algorithm~\cite{DBLP:journals/afp/LammichN19}.  Lammich \emph{et al.} also work within the idealized formal environment of Isabelle/HOL, but in contrast to Guttman develop efficient purely functional data structures and extract them to executable code.  Both Guttman and Lammich explicitly require that the input graph be connected. % and produce a tree.

%axiomatizes
%his second paper that their earlier proof of Prim's assumed "".



%  We make two immediate observations on CLRS's pseudocode: first, that they do not give an explicit definition for

% Note that  does not explicitly define \texttt{EXTRACT-MIN}

%are often limited to the case where the input graph is a connected graph. This is reasonable, as their purpose is to teach the concept of minimum-spanning \textit{tree} algorithms. However, they seldom expand on the subject of spanning forests for disconnected graphs. For example, . \textit{Discrete Mathematics and Its Applications} leaves it as an exercise to the reader, while \textit{Graph Algorithms in the Language of Linear Algebra}~\cite{kepnergilbert} suggests running Prim's on each component of the disconnected graph to obtain a minimum spanning forest. The last appears to be the most common solution, with suggesting this.


\hide{
\begin{figure}[H]
\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
\node[state] (V0) {$\m{v_0}$};
\node[state] (V1) [right=of V0] {$\m{v_1}$};
\node[state] (V2) [below=of V0] {$\m{v_2}$};
\node[state] (V3) [below right=of V0] {$\m{v_3}$};
\node[color=green] (V4) [right=of V3] {$\m{v_3}$};
\node[color=green] (V5) [right=of V4] {$\m{v_5}$};
\draw[color=red] (V0) edge [ultra thick] node[above=0.15 cm] {$5$} (V1);
\path (V0) edge node[left=0.15 cm] {$6$} (V2);
\path (V0) edge [thin] node[above right=0.05 cm] {$5$} (V3);
\path[color=red] (V1) edge [ultra thick] node[right=0.15 cm] {$5$} (V3);
\path[color=red] (V2) edge [ultra thick] node[below=0.15 cm] {$4$} (V3);
\path (V4) edge node[below=0.15 cm] {$1$} (V5);
\end{tikzpicture}
\caption{Figure of a partial Prim's execution with root $\m{v_0}$. A spanning tree for the left component has been found as indicated in red, while $\m{v_4}$ and $\m{v_5}$ are in the priority queue with weight \texttt{INF}. As our \texttt{EXTRACT-MIN} tolerates \texttt{INF}, our implementation will pop them from the priority queue and proceed as usual, instead of terminating with only the left tree.}
\end{figure}

From the above figure, we demonstrate that our simple priority queue will always pop vertices regardless of its weight. If the popped vertex has weight \texttt{INF}, its parent will also be at its default invalid value, indicating that no edge was added to the graph. We then continue the algorithm as usual, updating the weights of adjacent vertices. As a result, our Prim implementation can return a minimal spanning forest without ``premature termination".

Is our assumption that \texttt{EXTRACT-MIN} can pop \texttt{INF} weight vertices reasonable? We argue that it is, because the abstract algorithm in CLRS makes no statement about \texttt{INF} beyond the initialization. As the algorithm pushes the vertices into queue with weight \texttt{INF}, it is reasonable to say the priority queue can tolerate items with weight \texttt{INF}. Doing so simplifies \texttt{EXTRACT-MIN} to a \texttt{popMin} operation using the priority queue's API, without requiring additional lines of code to further check for specific weights.

Consequently, our code allows a simple implementation of Prim's to return a forest for a disconnected input graph, in a single run of the algorithm without needing to identify the disconnected components beforehand. It is important to note that we do not explicitly define ``components", nor do we tag \texttt{u} as a``new root". It is sufficient to prove that the loop invariant is satisfied whether \texttt{key[u]~< INF} or \texttt{key[u] = INF}.

Note that the priority queue used for this verification is still tied to \texttt{INF}, and thus in the verification our argument is weakened to ``\texttt{INF} is a valid weight in the priority queue" rather than ``membership in the priority queue is independent of \texttt{INF}". Work on a stronger priority queue which completely dissociates from \texttt{INF} was to be delivered by Aquinas Hobor since May 2020.
}

%  If they wish to determine the edge cost from a node to its parent, they can look it up in the graph, with the special case

%We observed that our code is able to return a minimum spanning forest when the input graph is disconnected, . The reason for this is: We treat a vertex of weight \texttt{INF} and a vertex's membership in the priority queue as \textit{separate} matters. A vertex can be in the priority queue with weight \texttt{INF}, represented by \texttt{key[u] = INF}, and this indicates that \texttt{u} is \textit{not} connected to any previously popped vertex; otherwise its weight would have been previously lowered. However, our priority queue does not care about its items having specific weights, only that the item it pops is always the one with the lowest weight. Thus, when a vertex \texttt{u} is returned, it is possible that \texttt{u} has weight \texttt{INF} - the scenario where all vertices remaining in the queue has weight \texttt{INF}, indicating all of them are disconnected from the current forest.

%Rather than start with a distinguished root vertex, we simply start with zero components, and the first vertex we extract (chosen arbitrarily by the PQ) becomes the root of the initial

%A further observation is that if we dissociate \texttt{INF} and the priority queue, then the input root required by Prim's is no longer necessary. The root's key is artificially set to 0 in Prim's, which kickstarts the main loop. However, since our emptiness check and \texttt{EXTRACT-MIN} implementation can return vertices with \texttt{INF} weight, the loop will start as long as there are un-popped vertices. Thus, we suggest it is possible to remove the \texttt{rt} parameter. Doing so simplifies the proof, because we do not have to reason about the artificially weighted \texttt{key[rt]}. The noroot-variant is in Figure 4 at the beginning of this section, while the verified implementation of Prim's without root is in \texttt{noroot\_prim.c}.

%They push their version of \texttt{INF} into the priority queue during the setup, and do not perform any explicit rejections of \texttt{INF}, simply popping from the priority queue at the \texttt{EXTRACT-MIN} step. However, they do not discuss minimum spanning forests, hence this observation is not recorded.
