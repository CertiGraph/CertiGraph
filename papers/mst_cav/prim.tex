\texttt{MST-PRIM}(\textit{G},\textit{w},\textit{r})
\newline
for each \textit{u} $\in$ \textit{G.V}
\newline
$\hspace*{4mm}$\textit{u.key} = \texttt{INF}
\newline
$\hspace*{4mm}$\textit{u.}$\pi$ = \texttt{NIL}
\newline
\textit{r.key} = 0
\newline
\textit{Q} = \textit{G.V}
\newline
while \textit{Q} $\neq$ 0
\newline
$\hspace*{4mm}$\textit{u} = \texttt{EXTRACT-MIN}(\textit{Q})
\newline
for each \textit{v} $\in$ \textit{G.Adj[u]}
\newline
$\hspace*{4mm}$if \textit{v} $\in$ \textit{Q} and \textit{w(u,v)} $<$ \textit{v.key}
\newline
$\hspace*{8mm}$\textit{v.}$pi$ = \textit{u}
\newline
$\hspace*{8mm}$\textit{v.key} = \textit{w(u,v)}
\begin{center}Abstract Prim's algorithm from CLRS~\cite{clrs}. Note that \texttt{EXTRACT-MIN} is not explicitly defined
\end{center}

\subsection{Undirected adjacency matrix representation}

We chose a symmetrical matrix representation for the undirected graph to be used in Prim's algorithm. This bears similarities to the adjacency matrix used in Dijkstra's, allowing us to reuse many properties about adjacency matrices.
\newline\newline
We observe one quirk about a symmetric undirected matrix. In our abstract graphs, which are fundamentally directed, the abstract edges $(u,v)$ and $(v,u)$ where $u \neq v$ are clearly distinct from each other. However, in a symmetric matrix both $g[u][v]$ and $g[v][u]$ will be marked, thus it is unclear which edge is in the graph. To disambiguate, we impose the following condition: If $g[u][v]$ and $g[v][u]$ is marked, and $u \leq v$, then we consider $(u,v)$ to be the valid edge; if $v \textless u$, then $(v,u)$ is the valid edge.

\subsection{Modification (or lack thereof) to return a forest}

Textbook discussions of Prim's algorithm are often limited to the case where the input graph is a connected graph. This is reasonable, as the primary purpose is to introduce the concept of minimum-spanning \textit{tree} algorithms. However, they seldom expand on the subject of spanning forests for disconnected graphs. CLRS does not mention the case of disconnected graphs. \textit{Discrete Mathematics and Its Applications}~\cite{rozen} leaves it as an exercise to the reader. \textit{The Algorithm Design Manual, Second Edition}~\cite{DBLP:books/daglib/0022194} suggests Boruvkaâ€™s algorithm, and a combination with Prim's for complexity. \textit{Graph Algorithms in the Language of Linear Algebra}~\cite{kepnergilbert} suggests running Prim's on each component of the disconnected graph to obtain a minimum spanning forest. The last appears to be the most common solution, with lectures and practical implementations suggesting this.
\newline\newline
We observed that our code is able to return a minimum spanning forest when the input graph is disconnected \textit{in a single run}. The reason for this is: We treat a vertex of weight \texttt{INF} and a vertex's membership in the priority queue as \textit{separate} matters. A vertex can be in the priority queue with weight \texttt{INF}, represented by \texttt{key[u] = INF}, and this indicates that \texttt{u} is \textit{not} connected to any previously popped vertex; otherwise its weight would have been previously lowered. However, our priority queue does not care for its items having specific weights, only that the item it pops is always minimum weight. This means that, in our proof which makes no assumptions about the input graph's connectedness, there is a scenario where the priority queue can return a \texttt{u} with weight \texttt{INF}.

\newline
\begin{center}
\begin{tikzpicture} [auto, node distance =2 cm and 2cm ,on grid, semithick, state/.style ={circle}]
\node[state] (V0) {$V0=r$};
\node[state] (V1) [right=of V0] {$V1$};
\node[state] (V2) [below=of V0] {$V2$};
\node[state] (V3) [below right=of V0] {$V3$};
\node[color=green] (V4) [right=of V3] {$V4$};
\node[color=green] (V5) [right=of V4] {$V5$};
\draw[color=red] (V0) edge [ultra thick] node[above=0.15 cm] {$5$} (V1);
\path (V0) edge node[left=0.15 cm] {$6$} (V2);
\path (V0) edge [thin] node[above right=0.05 cm] {$5$} (V3);
\path[color=red] (V1) edge [ultra thick] node[right=0.15 cm] {$5$} (V3);
\path[color=red] (V2) edge [ultra thick] node[below=0.15 cm] {$4$} (V3);
\path (V4) edge node[below=0.15 cm] {$1$} (V5);
\end{tikzpicture}
\newline
Figure of a partial Prim's execution with root $r = V0$. At this point, a spanning tree for the left component has been found as indicated in red, while $V4$ and $V5$ are in the priority queue with weight \texttt{INF}. As our \texttt{EXTRACT-MIN} tolerates \texttt{INF}, our implementation will pop $V4$ from the priority queue and proceed as usual, instead of terminating and requesting a second run of Prim's on the right component.
\newline
\end{center}
From the above figure, we demonstrate that our simple priority queue will always pop vertices regardless of its weight. The parent of \texttt{u} remains at its default invalid value, indicating that no edge was added to the graph - and then having popped \texttt{u}, we update the weights of its adjacent vertices, continuing the algorithm as usual. As a result, our Prim implementation can return a minimal spanning forest without ``premature termination".
\newline\newline
Is our assumption that \texttt{EXTRACT-MIN} can pop \texttt{INF} weight vertices reasonable? We argue that it is, because the abstract algorithm in CLRS makes no claim what to do with weight \texttt{INF} during the algorithm. As the algorithm pushes the vertices into queue with weight \texttt{INF}, it is reasonable to say the priority queue can tolerate items with weight \texttt{INF}. Doing so simplifies \texttt{EXTRACT-MIN} to a pop operation using the priority queue's API, without requiring additional lines of code to further check for specific weights.
\newline\newline
Consequently, our code allows a simple implementation of Prim's to return a forest for a disconnected input graph, in a single run of the algorithm without needing to identify the disconnected components beforehand. It is important to note that we do not explicitly define ``components", nor do we tag u as a``new root". It is sufficient to prove that the loop invariant is satisfied whether \texttt{key[u] < INF} or \texttt{key[u] = INF}.
\newline\newline
In our review of textbook graph algorithms, we observe that \textit{Algorithms in a Nutshell}~\cite{heineman2008algorithms} provides a C++ example that aligns with our C implementation. They push their version of \texttt{INF} into the priority queue during the setup, and do not perform any explicit rejections of \texttt{INF}, simply popping from the priority queue at the \texttt{EXTRACT-MIN} step. However, they do not discuss minimum spanning forests, hence this observation is not recorded.
\newline\newline
Note that the priority queue used for this verification is still tied to \texttt{INF}, and thus in the verification our argument is weakened to ``\texttt{INF} is a valid weight in the priority queue" rather than ``membership in the priority queue is independent of \texttt{INF}". Work on a stronger priority queue which completely dissociates from \texttt{INF} was being done by our supervisor, and remains incomplete as of the submission of this paper.
\newline\newline
A further observation is that in this version, the input root required by Prim's is no longer necessary. The root's key is artificially set to 0 in Prim's, which kickstarts the main loop. However, since our emptiness check and \texttt{EXTRACT-MIN} implementation can return vertices with \texttt{INF} weight, the loop will proceed as long as there are un-popped vertices. Thus, we suggest it is possible to remove the \texttt{rt} parameter. Doing so slightly simplifies the proof, because we do not have to reason about the artificially weighted \texttt{key[rt]}, as shown in \texttt{noroot\_prim.v}.
\newline\newline
	\texttt{MST-PRIM-NOROOT}(\textit{G},\textit{w})
	\newline
	for each \textit{u} $\in$ \textit{G.V}
	\newline
	$\hspace*{4mm}$\textit{u.key} = \texttt{INF}
	\newline
	$\hspace*{4mm}$\textit{u.}$\pi$ = \texttt{NIL}
	\newline
	\textit{Q} = \textit{G.V}
	\newline
	while \textit{Q} $\neq$ 0
	\newline
	$\hspace*{4mm}$\textit{u} = \texttt{POP-MIN}(\textit{Q})
	\newline
	for each \textit{v} $\in$ \textit{G.Adj[u]}
	\newline
	$\hspace*{4mm}$if \textit{v} $\in$ \textit{Q} and \textit{w(u,v)} $<$ \textit{v.key}
	\newline
	$\hspace*{8mm}$\textit{v.}$pi$ = \textit{u}
	\newline
	$\hspace*{8mm}$\textit{v.key} = \textit{w(u,v)}
	\begin{center}Example abstract Prim's algorithm without root, and relying on Q's \texttt{POP-MIN}
	\end{center}