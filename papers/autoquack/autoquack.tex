%
% LaTeX template for prepartion of submissions to PLDI'15
%
% Requires temporary version of sigplanconf style file provided on
% PLDI'15 web site.
%
\documentclass[pldi]{sigplanconf-pldi15}

%
% the following standard packages may be helpful, but are not required
%

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[tbtags]{amsmath} %\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{listings}          % format code
\usepackage{stmaryrd}
\usepackage{relsize}
\usepackage{setspace}
\usepackage[small,compact]{titlesec}

\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{wasysym}
%% \usepackage{SIunits}            % typset units correctly
\usepackage{courier}            % standard fixed width font
\usepackage[scaled]{helvet} % see www.ctan.org/get/macros/latex/required/psnfss/psnfss2e.pdf
\usepackage{url}                  % format URLs
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink
\usepackage{tikz}
%\usetikzlibrary{arrows.meta}
\usepackage{fancybox}
\usepackage{multicol}
\usepackage{semantic}
\newcommand{\triple}[3]{\{#1\}\,#2\,\{#3\}}
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}   % print a hyperlinked DOI
\usepackage{mathtools}

%\input mathlig

%\usepackage{common}
%\usepackage{seplog}

\lstset{%
  language=C,
  morecomment=[n][{\color{red!80!black}}]{/*}{*/},
  morecomment=[l][{\color{red!80!black}}]{//},
  sensitive=true,
  mathescape=true,
  showlines=true,
  basicstyle=\normalfont\smaller\tt,
  keywordstyle=\color{blue},
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  boxpos=t,
}


%\lstset{language=C,basicstyle=\small,mathescape=true,columns=fullflexible}

\newcommand{\scon}{\mathbin{\varstar}}
\newcommand{\ocon}{%
  \mathbin{\mbox{$\mathrlap{\cup}\hspace*{.15em}
      \raisebox{.01em}[0ex][0ex]{$\scon$}$\hspace*{.07em}}}}
\newcommand{\wand}{%
 \mathrel{\mbox{$\hspace*{-0.03em}\mathord{-}\hspace*{-0.66em}
     \mathord{-}\hspace*{-0.36em}\mathord{\scon}$\hspace*{-0.005em}}}}
\newcommand{\defeq}{\mathbin{\stackrel{\Delta}{=}}}

\begin{document}

%
% any author declaration will be ignored  when using 'plid' option (for double blind review)
%

%\title{The Ramifications of Mechanizing Verification}
\title{The Ramifications of Mechanized Localizations within Data Structures}
\authorinfo{Shengyi Wang$^{*}$ \qquad Qinxiang Cao$^{+}$ \qquad Asankhaya Sharma$^{*}$ \qquad Aquinas Hobor$^{\dagger,*}$}
{}
{School of Computing$^{*}$ and Yale-NUS College$^{\dagger}$, National University of Singapore; Princeton University$^{+}$}

\maketitle

\begin{abstract}
We show how to mechanically verify programs manipulating data structures with intrinsic sharing such as heap-represented graphs.  We upgrade the theory of ramification to better support modified program variables and existential quantifiers in assertions.  We develop a modular and general setup for reasoning about mathematical graphs and show
how to connect this setup to a general theory for graphs in separation logic.  We connect our theories to two verification tools with different levels of automation and use them to verify several canonical graph algorithms. Our proofs are entirely machine-checked in Coq.
\end{abstract}

\newcommand\hide[1]{}

\section{Introduction}
Over the last fifteen years great strides have been made in automating verifications of programs that manipulate
tree-like data structures using separation logic CITE CITE CITE.  Unfortunately, verifying programs that manipulate
graph-like data structures (e.g. structures with \emph{intrinsic sharing}) has been far more challenging.
Indeed, verifying such programs was formidable enough that a number of the early landmark results in separation logic
devoted substantial efforts to verify single examples such as Schorr-Waite~\cite{hongseok:phd} and XXX CITE with pen and
paper---avoiding entirely the additional challenges inherent in machine-assisted reasoning.

In recent years, Hobor and Villard introduced the concept of \emph{ramification} as a kind of proof pattern or framework
to verify graph-manipulating programs with pen and paper~\cite{hobor:ramification}, but left open the question of how such proofs could
be incorporated in a machine-assisted setting.  In this paper, we show how this can be done, and demonstrate the
value of our approach by adding ramification to two rather sizeable---albeit quite differently flavored---separation logic-based
verification tools: the Coq-based tactic system of the Verified Software Toolchain CITE and the more highly-automated HIP/SLEEK
program verifier~\cite{chin:hipsleek}.  Despite the substantial differences between these systems, the vast majority of our infrastructure is
shared between them, and since many of the other computer-assisted verification tools under development
today CITE CITE CITE CITE have much in common with at least one of these tools, we believe that our techniques will be
applicable to many other systems as well.

Along the way we develop an improved proof rule for ramification that supports existential variables and enjoys a smoother interaction with


with modified

 references to modified local program variables more generally.

 smoothly



a smoother and more uniform support for modified program variables.

along with a more

make a number upgrades to the theory of ramification and present

, with a better treatment of modified variables, existentials,

Along the way we discover---and show how to fix---a rather subtle error in Hobor and Villard's presentation: neither the
Knaster-Tarski \cite{tarski:fixpoint} nor the Appel-McAllester \cite{appel:fixpoint} method for solving recursive fixpoints is suitable for defining
recursive graph predicates in separation logic.

  We also develop a general framework for defining and reasoning about mathematical
graphs and

different kinds of mathematical
graphs can be implemented in separation logic in a uniform way;

generalize their setting
so that it can handle a wider variety of data structures;

We use both systems to verify a number of different programs utilizing graph-manipulating structures,
letting us understand the advantages and disadvantages of both.

\paragraph{Contributions and structure of the remainder of this paper.}
\begin{itemize}
\item Example \S\ref{sec:example}.  Contributions: new ramify rules, new notation, everything machine-checked, multiple tools sharing mathematical infrastructure.
\item Mathematical graphs.  Contributions: computable, compositional, \& general graph library in Coq.  Treatment of null.
\item Spatial graphs.  Contributions: correct general graph predicate.  Problem with fixed point.  Problem with ``later'' not being precise.  Fold/unfold, precise, etc.
\item Integrating ramification into verification tools.  Contributions: VST (localize/unlocalize). H/S (external axioms).  Additional examples.  New proof of ``copy'' that does not use regions.
\item Related work, future work, and conclusion
\end{itemize}

\section{Generalizing localizations}
\label{sec:orientation}

\input{orientation.tex}

\section{A framework for graph theory}
\input{math_graph.tex}

\input{spatial.tex}

\section{Verifying graph-manipulating programs}

4. General Strategy for Verifying Programs
4.1. Using relation. (Better for proof's code reuse). For example, spanning tree is mark together with some structural requirement.
4.2. Using existential quantifier in post condition.

%[5:19:46 AM] Aquinas Hobor: the localize/unlocalize tactics or the semantic model for semax_ram
%[5:19:46 AM] caoqinxiang: And we will discuss the trick in "\item Integrating ramification into verification tools" section right?
%[5:20:00 AM] Aquinas Hobor: Yes, and also the model for semax_ram
%[5:20:06 AM] Aquinas Hobor: And also the other examples
%[5:20:12 AM] caoqinxiang: Aha, yes.
%[5:20:23 AM] Aquinas Hobor: And also point out which parts are easier to automate, etc.
%[5:20:49 AM] Aquinas Hobor: For example, how does the "close w.r.t. modified variables" work?  Is that calculated automagically?
%[5:21:06 AM] caoqinxiang: yes.
%[5:21:22 AM | Edited 5:21:37 AM] caoqinxiang: Box_c(P) is closed w.r.t. to modvar(c)
%[5:21:34 AM] Aquinas Hobor: Right, so we point that out.  What about how the existentials etc. work.  Is that automagic also or does the user have to specify them?
%[5:22:20 AM] caoqinxiang: User specify which variables are dependent, and the tactic makes them quantified.
%[5:22:29 AM] Aquinas Hobor: So "semiautomatic"?
%[5:22:44 AM] caoqinxiang: Right, user should give hints.
%[5:22:52 AM] caoqinxiang: And tactic do the rest.
%[5:23:06 AM] Aquinas Hobor: Right.  Anyhow, that goes there, along with the extra VST examples.

\input{vst.tex}

\section{Enabling externally-verified lemmas in HIP/SLEEK}

* the connection to HIP/SLEEK

In the H/S section we talk about the engineering inside H/S, the module type/module interface, forward ramify, etc.

\section{Applying ramification}\label{sec:application}

5. Mark algorithm
5.1. For Ramification-Paper-style proof
5.1.1. Math land theorems for marking algorithm (general situation and bi-graph situation) are all proved. Mainly in "\texttt{marked\_graph.v}" and "\texttt{spatial\_graph\_mark\_bi.v}".
5.1.2. Ramification rule for marking algorithm (bi-graph situation) are all proved in "\texttt{spatial\_graph\_mark\_bi.v}".
5.1.3. Combining 2.4 and 3.1.1 and 3.1.2, we have a end-to-end proof for marking-graph in VST.
5.1.4. We have an end-to-end proof for marking-dag, but not defining dag predicate as a whole.
5.1.5. The module type which will be generated by HIP/SLEEK should be instantiated by 2.2 and 2.5.

6. Spanning tree algorithm
6.1. We divide the spanning tree relation into structural part and marking part. They are both defined properly.
6.2. Important pure facts and ramification rules are not proved yet.
6.3. Shengyi has already known how to use VST to handle the C program of bigraph spanning tree.

\input{related.tex}

\section{Conclusion}

\bibliographystyle{abbrvnat}
%\bibliographystyle{tropbien_nopages}
\bibliography{autoquack}

\input{appendix.tex}

\end{document}
