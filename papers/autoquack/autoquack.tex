%
% LaTeX template for prepartion of submissions to PLDI'15
%
% Requires temporary version of sigplanconf style file provided on
% PLDI'15 web site.
%
\documentclass[pldi]{sigplanconf-pldi15}

%
% the following standard packages may be helpful, but are not required
%

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{ amssymb }
\usepackage{wasysym}
\usepackage{stmaryrd}
\usepackage{SIunits}            % typset units correctly
\usepackage{courier}            % standard fixed width font
\usepackage[scaled]{helvet} % see www.ctan.org/get/macros/latex/required/psnfss/psnfss2e.pdf
\usepackage{url}                  % format URLs
\usepackage{listings}          % format code
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink
\usepackage{tikz}
\usepackage{fancybox}
\usepackage{multicol}
\usetikzlibrary{arrows.meta}
\usepackage{semantic}
\newcommand{\triple}[3]{\{#1\}\,#2\,\{#3\}}
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}   % print a hyperlinked DOI

\lstset{language=C,basicstyle=\small,mathescape=true,columns=fullflexible}

\begin{document}

%
% any author declaration will be ignored  when using 'plid' option (for double blind review)
%

\title{The Ramifications of Mechanizing Verification}
\authorinfo{Shengyi Wang$^{*}$ \qquad Qinxiang Cao$^{+}$ \qquad Asankhaya Sharma$^{*}$ \qquad Aquinas Hobor$^{\dagger,*}$}
{}
{School of Computing$^{*}$ and Yale-NUS College$^{\dagger}$, National University of Singapore; Princeton University$^{+}$}

\maketitle
\begin{abstract}
Blah blah blah
\end{abstract}

\newcommand\hide[1]{}

\section{Introduction}
Over the last fifteen years great strides have been made in automating verifications of programs that manipulate
tree-like data structures using separation logic CITE CITE CITE.  Unfortunately, verifying programs that manipulate
graph-like data structures (e.g. structures with \emph{intrinsic sharing}) has been far more challenging.
Indeed, verifying such programs was formidable enough that a number of the early landmark results in separation logic
devoted substantial efforts to verify single examples such as Schorr-Waite \cite{hongseok:phd} and XXX CITE with pen and
paper---avoiding entirely the additional challenges inherent in machine-assisted reasoning.

In recent years, Hobor and Villard introduced the concept of \emph{ramification} as a kind of proof pattern or framework
to verify graph-manipulating programs with pen and paper \cite{hobor:ramification}, but left open the question of how such proofs could
be incorporated in a machine-assisted setting.  In this paper, we show how this can be done, and demonstrate the
value of our approach by adding ramification to two rather sizeable---albeit quite differently flavored---separation logic-based
verification tools: the Coq-based tactic system of the Verified Software Toolchain CITE and the more highly-automated HIP/SLEEK
program verifier \cite{chin:hipsleek}.  Despite the substantial differences between these systems, the vast majority of our infrastructure is
shared between them, and since many of the other computer-assisted verification tools under development
today CITE CITE CITE CITE have much in common with at least one of these tools, we believe that our techniques will be
applicable to many other systems as well.



Along the way we discover---and show how to fix---a rather subtle error in Hobor and Villard's presentation: neither the
Knaster-Tarski \cite{tarski:fixpoint} nor the Appel-McAllester \cite{appel:fixpoint} method for solving recursive fixpoints is suitable for defining
recursive graph predicates in separation logic.

  We also develop a general framework for defining and reasoning about mathematical
graphs and

different kinds of mathematical
graphs can be implemented in separation logic in a uniform way;

generalize their setting
so that it can handle a wider variety of data structures;

We use both systems to verify a number of different programs utilizing graph-manipulating structures,
letting us understand the advantages and disadvantages of both.

\section{A framework for graph theory}
\input{math_graph.tex}

\section{Defining and reasoning about spatial graphs}

2.3. \texttt{sSpatialGraph\_Graph\_Bi} defined in "\texttt{spatial\_graph\_bi.v}" is the premise type class for defining how a BiMaFin graph is stored in memory.

2.5. Heap-Model-Direct instances are broken now. They are not hard to get fixed. Previous proofs are in "\texttt{spatial\_graph\_HMD.v}".

\subsection{Traditional fixpoints fail}

Hobor and Villard defined the separation logic graph predicate $\mathsf{graph}(x,\gamma)$ in direct analogy to the standard
separation logic definition of a tree as follows:
\[
\begin{array}{l}
\mathsf{graph}(x,\gamma) ~~ \stackrel{\Delta}{=} ~~ ({x = 0} \wedge \mathsf{emp}) \vee \null \\
~~~~ (\exists d,l,r.~ x \mapsto d,l,r, ** \mathsf{graph}(l,\gamma) ** \mathsf{graph}(r,\gamma))
\end{array}
\]

%* Showing that neither traditional fixpoint method works

Recursive/inductive predicates are ubiquitous in separation logic---so much so that when a person writes the definition of a
predicate as $P \stackrel{\textrm{``}\Delta\textrm{''}}{=} \ldots P \ldots$ no one raises an eyebrow, despite the dangers of circularity in
mathematics.  Indeed, 95\% of the time there is no danger thanks to the magic of the Knaster/Tarski fixpoint $\mu_{\mathsf{T}}$ \cite{tarski:fixpoint}.
Formally what is going on is instead of defining $P$ directly, one defines a functional
$F_P \stackrel{\Delta}{=} \lambda P.~ \ldots P \ldots$ and then defines $P$ itself as $P \stackrel{\Delta}{=} \mu_{\mathsf{T}} \, F_P$.
Assuming (as one typically does without comment) that $F_P$ is \emph{covariant}, i.e. $(P \vdash Q) \Rightarrow (F \, P \vdash F \, Q)$,
one then enjoys the fixpoint equation
$P \Leftrightarrow \ldots P \ldots$, formally justifying typically written pseudodefinition ($\stackrel{\textrm{``}\Delta\textrm{''}}{=}$).





Appel and McAllester developed an additional fixpoint \cite{appel:fixpoint} whose \cite{appel:vmm}

\subsection{The iterated separating conjunction}
1.2. \texttt{Iter\_sepcon} and \texttt{pred\_sepcon} are defined. And related ramification rules are proved.
1.3. The most general graph-spatial-predicate \texttt{vertices\_at} are defined (for all possible styles of graphs). Related ramification rules are proved. Graph and graphs are defined as special cases of vertices at.

2. A minor implementation trick. There are many tactics defined in \texttt{msl\_ext/ramify\_tactics.v}, which can manipulate low level heaps efficiently.

* Separating the material into the general vs. tool-specific part.  Measurements of etc.

\section{Verifying graph-manipulating programs}

4. General Strategy for Verifying Programs
4.1. Using relation. (Better for proof's code reuse). For example, spanning tree is mark together with some structural requirement.
4.2. Using existential quantifier in post condition.

\input{vst.tex}

\section{Enabling externally-verified lemmas in HIP/SLEEK}

* the connection to HIP/SLEEK

\section{Applying ramification}

5. Mark algorithm
5.1. For Ramification-Paper-style proof
5.1.1. Math land theorems for marking algorithm (general situation and bi-graph situation) are all proved. Mainly in "\texttt{marked\_graph.v}" and "\texttt{spatial\_graph\_mark\_bi.v}".
5.1.2. Ramification rule for marking algorithm (bi-graph situation) are all proved in "\texttt{spatial\_graph\_mark\_bi.v}".
5.1.3. Combining 2.4 and 3.1.1 and 3.1.2, we have a end-to-end proof for marking-graph in VST.
5.1.4. We have an end-to-end proof for marking-dag, but not defining dag predicate as a whole.
5.1.5. The module type which will be generated by HIP/SLEEK should be instantiated by 2.2 and 2.5.

6. Spanning tree algorithm
6.1. We divide the spanning tree relation into structural part and marking part. They are both defined properly.
6.2. Important pure facts and ramification rules are not proved yet.
6.3. Shengyi has already known how to use VST to handle the C program of bigraph spanning tree.

\section{Related and future work}

5.2. An alternative way of verifying marking program is reasoning about the whole history of marking operations. The disadvantage of it is that it currently needs more work in a Hoare logic framework. The advantage of it is that its reasoning structure are more similar with the way we understand it in our first algorithm class.
5.3. I take some effort on garbage collector like graph structural. Though it is only connecting this special structural with 5.1.1 and 1.3, it takes much time and it is not finished yet.

\section{Conclusion}

\bibliographystyle{abbrvnat}
\bibliography{autoquack}

\end{document}
