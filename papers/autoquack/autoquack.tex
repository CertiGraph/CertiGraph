%
% LaTeX template for prepartion of submissions to PLDI'15
%
% Requires temporary version of sigplanconf style file provided on
% PLDI'15 web site.
%
\documentclass[pldi]{sigplanconf-pldi15}

%
% the following standard packages may be helpful, but are not required
%
\usepackage{SIunits}            % typset units correctly
\usepackage{courier}            % standard fixed width font
\usepackage[scaled]{helvet} % see www.ctan.org/get/macros/latex/required/psnfss/psnfss2e.pdf
\usepackage{url}                  % format URLs
\usepackage{listings}          % format code
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}   % print a hyperlinked DOI



\begin{document}

%
% any author declaration will be ignored  when using 'plid' option (for double blind review)
%

\title{The Ramifications of Mechanizing Verification}
\authorinfo{Shengyi Wang$^{*}$ \qquad Qinxiang Cao$^{+}$ \qquad Asankhaya Sharma$^{*}$ \qquad Aquinas Hobor$^{\dagger,*}$}
{}
{School of Computing$^{*}$ and Yale-NUS College$^{\dagger}$, National University of Singapore; Princeton University$^{+}$}

\maketitle
\begin{abstract}
Blah blah blah
\end{abstract}

\newcommand\hide[1]{}

\section{Introduction}
Over the last fifteen years great strides have been made in automating verifications of programs that manipulate
tree-like data structures using separation logic CITE CITE CITE.  Unfortunately, verifying programs that manipulate 
graph-like data structures (e.g. structures with \emph{intrinsic sharing}) has been far more challenging.
Indeed, verifying such programs was formidable enough that a number of the early landmark results in separation logic
devoted substantial efforts to verify single examples such as Schorr-Waite \cite{hongseok:phd} and XXX CITE with pen and 
paper---avoiding entirely the additional challenges inherent in machine-assisted reasoning.

In recent years, Hobor and Villard introduced the concept of \emph{ramification} as a kind of proof pattern or framework
to verify graph-manipulating programs with pen and paper \cite{hobor:ramification}, but left open the question of how such proofs could
be incorporated in a machine-assisted setting.  In this paper, we show how this can be done, and demonstrate the
value of our approach by adding ramification to two rather sizeable---albeit quite differently flavored---separation logic-based 
verification tools: the Coq-based tactic system of the Verified Software Toolchain CITE and the more highly-automated HIP/SLEEK
program verifier \cite{chin:hipsleek}.  Despite the substantial differences between these systems, the vast majority of our infrastructure is 
shared between them, and since many of the other computer-assisted verification tools under development 
today CITE CITE CITE CITE have much in common with at least one of these tools, we believe that our techniques will be 
applicable to many other systems as well.



Along the way we discover---and show how to fix---a rather subtle error in Hobor and Villard's presentation: neither the 
Knaster-Tarski \cite{tarski:fixpoint} nor the Appel-McAllester \cite{appel:fixpoint} method for solving recursive fixpoints is suitable for defining
recursive graph predicates in separation logic.

  We also develop a general framework for defining and reasoning about mathematical 
graphs and 

different kinds of mathematical
graphs can be implemented in separation logic in a uniform way; 

generalize their setting
so that it can handle a wider variety of data structures; 

We use both systems to verify a number of different programs utilizing graph-manipulating structures,
letting us understand the advantages and disadvantages of both.

\section{A framework for mathematical graphs}

* the DFS algorithm on math graphs

1.1. A lot of important theorems about graph are proved.

2. Bi-graph.
2.1. BiMaFin is defined as one kind of general graph.
2.2. \texttt{pSpatialGraph\_Graph\_Bi} defined in "\texttt{spatial\_graph\_bi.v}" is the premise type class for defining BiMaFin.

1. Classification of various graphs: MathGraph, BiGraph and FinGraph. Though now we put them all in a BiMaFin, there are still many general theorems based on only one of them. The abstraction and classification is useful.

1.4. Dag predicate has not been defined as a whole. It is not hard to get fixed.

\section{Defining and reasoning about spatial graphs}

2.3. \texttt{sSpatialGraph\_Graph\_Bi} defined in "\texttt{spatial\_graph\_bi.v}" is the premise type class for defining how a BiMaFin graph is stored in memory.

2.5. Heap-Model-Direct instances are broken now. They are not hard to get fixed. Previous proofs are in "\texttt{spatial\_graph\_HMD.v}".

\subsection{Traditional fixpoints fail}

Hobor and Villard defined the separation logic graph predicate $\mathsf{graph}(x,\gamma)$ in direct analogy to the standard 
separation logic definition of a tree as follows:
\[
\begin{array}{l}
\mathsf{graph}(x,\gamma) ~~ \stackrel{\Delta}{=} ~~ ({x = 0} \wedge \mathsf{emp}) \vee \null \\
~~~~ (\exists d,l,r.~ x \mapsto d,l,r, ** \mathsf{graph}(l,\gamma) ** \mathsf{graph}(r,\gamma))
\end{array}
\]

%* Showing that neither traditional fixpoint method works

Recursive/inductive predicates are ubiquitous in separation logic---so much so that when a person writes the definition of a 
predicate as $P \stackrel{\textrm{``}\Delta\textrm{''}}{=} \ldots P \ldots$ no one raises an eyebrow, despite the dangers of circularity in
mathematics.  Indeed, 95\% of the time there is no danger thanks to the magic of the Knaster/Tarski fixpoint $\mu_{\mathsf{T}}$ \cite{tarski:fixpoint}.
Formally what is going on is instead of defining $P$ directly, one defines a functional 
$F_P \stackrel{\Delta}{=} \lambda P.~ \ldots P \ldots$ and then defines $P$ itself as $P \stackrel{\Delta}{=} \mu_{\mathsf{T}} \, F_P$.  
Assuming (as one typically does without comment) that $F_P$ is \emph{covariant}, i.e. $(P \vdash Q) \Rightarrow (F \, P \vdash F \, Q)$, 
one then enjoys the fixpoint equation
$P \Leftrightarrow \ldots P \ldots$, formally justifying typically written pseudodefinition ($\stackrel{\textrm{``}\Delta\textrm{''}}{=}$).





Appel and McAllester developed an additional fixpoint \cite{appel:fixpoint} whose \cite{appel:vmm}

\subsection{The iterated separating conjunction}
1.2. \texttt{Iter\_sepcon} and \texttt{pred\_sepcon} are defined. And related ramification rules are proved.
1.3. The most general graph-spatial-predicate \texttt{vertices\_at} are defined (for all possible styles of graphs). Related ramification rules are proved. Graph and graphs are defined as special cases of vertices at.

2. A minor implementation trick. There are many tactics defined in \texttt{msl\_ext/ramify\_tactics.v}, which can manipulate low level heaps efficiently.

* Separating the material into the general vs. tool-specific part.  Measurements of etc.

\section{Verifying graph-manipulating programs}

4. General Strategy for Verifying Programs
4.1. Using relation. (Better for proof's code reuse). For example, spanning tree is mark together with some structural requirement.
4.2. Using existential quantifier in post condition.

\section{Ramification based on VST}

WHY WE NEED RAMIFICATION BEFORE THIS SECTION?

VST is a correctness-certified tool to prove functional correctness of C programs CITE. All Hoare rules are proved sound and users can use them to build modularized proof. At the same time, users can have all the convenience offered by separation logic. For example, frame rule is already proved sound as well. VST is fully developed in Coq and it uses the C semantics offered by ComCert. CITE

AQUINAS, IS IT CORRECT TO USE PRESENT TENSE TO TALK ABOUT VST? SHALL I USE PAST TENSE?

$$ \frac{\{ P \} c \{Q \} \quad FreeVar(F) \cap ModVar(c) = \emptyset } {\{P * F \} c \{ Q * F \}} $$

$$ \frac{\{ L \} c \{L' \} \quad FreeVar(L' -* G') \cap ModVar(c) = \emptyset \quad G \vdash L * (L' -* G')} {\{G \} c \{ G' \}} $$

EDITING FORMAT

In this work we present, we establish the soundness of ramification rule based on frame rule. Noticing that local variables are stored in stack in C, expressing the property of a local variable's value is a pure fact rather than a spatial fact. So, we prove a pure-facts-related rule besides the primary one such that ramification is much easier to apply in VST.

$$ \frac{\{ L \} c \{PureLocal \wedge L' \} \quad FreeVar(PureFrame \wedge (L' -* G')) \cap ModVar(c) = \emptyset \quad G \vdash L * (PureFrame \wedge (L' -* G'))} {\{G \} c \{ PureFrame \wedge PureLocal \wedge G' \}} $$

EDITING FORMAT

MORE TO WRITE: divide pure facts into frame and local based on VST's canonical form. Based on localize/unlocalize, compared with frame rule, ramification rule have better use on VST's automatic symbolic execution system.





2.4. VST instance of \texttt{pSpatialGraph\_Graph\_Bi} and \texttt{sSpatialGraph\_Graph\_Bi} are constructed in "\texttt{spatial\_graph\_aligned\_bi\_VST.v}" and "\texttt{spatial\_graph\_unaligned\_bi\_VST.v}".

3. Embed ramification into VST.
3.1. Ramification rule are proved sound in VST.
3.2. A special ramification rule for VST's Sep-Local-Prop style pre/post condition is prove. The point is traditional ramification rule require the whole frame-like-wand-expression to be closed w.r.t. the modified variables. This special rule split closed and unclosed away.
3.3. Localize and unlocalize are defined.
3.3.1. Localize/unlocalize offer a user-friendly way of using ramification rule.
3.3.2. Unlocalize tactic need "Grab Existential Variables" afterwards. It is not nice.
3.3.3. Writing Ocaml plugin is one solution. But we need to develop for both mac and windows.
3.3.4. Or we can see whether Coq's next version offers more tactics for existential variables.

\section{Enabling externally-verified lemmas in HIP/SLEEK}

* the connection to HIP/SLEEK

\section{Applying ramification}

5. Mark algorithm
5.1. For Ramification-Paper-style proof
5.1.1. Math land theorems for marking algorithm (general situation and bi-graph situation) are all proved. Mainly in "\texttt{marked\_graph.v}" and "\texttt{spatial\_graph\_mark\_bi.v}".
5.1.2. Ramification rule for marking algorithm (bi-graph situation) are all proved in "\texttt{spatial\_graph\_mark\_bi.v}".
5.1.3. Combining 2.4 and 3.1.1 and 3.1.2, we have a end-to-end proof for marking-graph in VST.
5.1.4. We have an end-to-end proof for marking-dag, but not defining dag predicate as a whole.
5.1.5. The module type which will be generated by HIP/SLEEK should be instantiated by 2.2 and 2.5.

6. Spanning tree algorithm
6.1. We divide the spanning tree relation into structural part and marking part. They are both defined properly.
6.2. Important pure facts and ramification rules are not proved yet.
6.3. Shengyi has already known how to use VST to handle the C program of bigraph spanning tree.

\section{Related and future work}

5.2. An alternative way of verifying marking program is reasoning about the whole history of marking operations. The disadvantage of it is that it currently needs more work in a Hoare logic framework. The advantage of it is that its reasoning structure are more similar with the way we understand it in our first algorithm class.
5.3. I take some effort on garbage collector like graph structural. Though it is only connecting this special structural with 5.1.1 and 1.3, it takes much time and it is not finished yet.

\section{Conclusion}

\bibliographystyle{abbrvnat}
\bibliography{autoquack}

\end{document}
