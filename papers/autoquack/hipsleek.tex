HIP/SLEEK is a toolset for verifying programs using separation logic~\cite{chin:hipsleek}.  As compared to VST, H/S has a heavier focus on automation: for example, users need only specify loop invariants and the pre/postconditions of methods, rather than describing each program point.  H/S has two interlocking components.  HIP applies Hoare rules using forward reasoning to verify programs, \emph{i.e.} each entailment is of the form $P |- Q * R$, where the heap from the antecedent~$P$ is matched with the consequent $Q$ and a frame/residue $R$. To check these separation logic entailments and calculate~$R$, HIP calls SLEEK.  SLEEK handles spatial operators such as~$*$ and $|->$ before handing any remaining pure entailments to a variety of external solvers such as Z3.  One of H/S's distinguishing features is support for user-defined recursive predicates.  HIP/SLEEK has been used to verify programs manipulating data structures like lists, arrays, and trees.

\subsection{Verifying \li{mark} in HIP/SLEEK}
\label{sec:hipsleekmark}
\lstset{otherkeywords={data,relation,rlemma,abstract,axiom}}

\begin{figure}[t]
  \begin{lstlisting}
data node { int val; node left; node right; }

graph<G> == self = null or 
 self::node<v,l,r>U*(l::graph<G>U*r::graph<G>)
 & lookup(G,self,v,l,r);

$\label{code:hipstartrelation}$relation lookup(abstract G, node x, 
  node v, node l, node r).
relation mark(abstract G, node x, abstract G1).
relation
  subset_reach(abstract G, node x, abstract G1).
relation
$\label{code:hipendrelation}$ eq_notreach(abstract G, node x, abstract G1).

$\label{code:hipaxiom}$axiom lookup(G,x,1,l,r) ==> mark(G,x,G).

$\label{code:hipbeginlemma}$rlemma "subgraphupdate_l" l::graph<G1> *
 (l::graph<G> --@ (x::node<v,l,r> U*
 (l::graph<G> U* r::graph<G>))) &
 subset_reach(G,l,G1) & eq_notreach(G,l,G1)
 & lookup(G,x,v,l,r) & lookup(G1,x,v1,l,r)
  -> x::node<v1,l,r> U*
$\label{code:hipendlemma}$   (l::graph<G1> U* r::graph<G1>);
...

void mark(node x) { node l, r; // $\label{code:hipmarkstart}\{\p{graph}(\tx{x},\gamma)\}$
  if (x == null) return;
  else { if (x.val == 1) return; $\label{ifcondmark}$
         l = x.left; r = x.right; x.val = 1;
         mark(l);$\label{beforemarkleft}$
         mark(r); } } //$\label{code:hipmarkend}\{\exists \gamma'. \p{graph}(\tx x,\gamma') {/|} \m{mark}(\gamma, \tx{x}, \gamma')\}$
\end{lstlisting}
%% \vspace{-8pt}
\caption{Bigraph marking in HIP/SLEEK}
\label{fig:hipmarkgraph}
\end{figure}

Figure~\ref{fig:hipmarkgraph} gives the HIP/SLEEK file used to verify \li{mark}.  In the body of the function itself (lines~\ref{code:hipmarkstart}--\ref{code:hipmarkend}) we only specify the pre/postconditions of the function (in a mathematical style for succinct readability); note this is the same specification we verified in VST in Figure~\ref{fig:markgraph}.  We do define a number of things e define a number of abstract relations (\emph{e.g.} lines~\ref{code:hipstartrelation}--\ref{code:hipendrelation}), axioms relating these pure relations to each other (\emph{e.g.} line~\ref{code:hipaxiom}), and ramification rules connection spatial predicates with the abstract relations (\emph{e.g.} lines~\ref{code:hipbeginlemma}--\ref{code:hipendlemma}).



and 


One difference here is that HIP/SLEEK uses a Java-like memory model with objects and fields, thus there are no alignment issues as one cannot have a pointer to the middle of a field. As explained in section \ref{sec:spacegraph} the ramification library we provide is generic, reasoning in HIP/SLEEK uses the supplementary graphs from our library.

There are three key steps that automate ramifications in HIP/SLEEK, the first step is the use of fold/unfold relationship for graphs given in (\ref{eqn:unfold_graph}). HIP/SLEEK uses unfold lemma for graph to automatically expose the heap required to check entailments during forward reasoning. E.g. in order to check the dereference at line \ref{ifcondmark} in figure \ref{fig:hipmarkgraph} the $\p{graph}(\tx{x},\gamma)$ predicate is unfolded and the state just before line \ref{ifcondmark} is $ \exists m,l,r.~ \gamma(x)=(m,l,r) \wedge x \mapsto m,l,r \ocon \p{graph}(l, \gamma) \ocon \p{graph}(r, \gamma)$.

\subsection{Externally-verified lemmas}

To implement ramifications in HIP/SLEEK we extended its lemma system~\cite{NguyenC08}.
Normal lemmas in H/S are user defined, automatically checked, and automatically
applied in program verifications.  In contrast, our new lemmas are still user defined and still automatically applied in program verifications, but \textbf{not} automatically checked, so we call them \emph{externally verified lemmas}; their key advantage is that they can be much more complex than the lemmas H/S can check automatically.  Instead of checking the lemmas automatically, H/S outputs a Coq \li{Module} \li{Type} that states the lemmas H/S needed in the verification.  Users then implement a matching \li{Module} to get a fully-verified result.

Similar to most other verification tools~\cite{Beckert:2007,DistefanoP08,berdine:smallfoot,jacobs:verifast}, HIP/SLEEK uses forward reasoning based on symbolic execution.

We use the $\septraction$ operator to capture the strongest post condition during forward reasoning. Given a precondition $R$ and $\{P\}~c~\{Q\}$ the strongest post condition can be captured as $(P \septraction R) \scon Q$. During forward reasoning in HIP/SLEEK we introduce the $\septraction$ when checking entailments with predicates that use sharing. E.g. at line \ref{beforemarkleft} in figure \ref{fig:hipmarkgraph} in order to check the precondition we introduce the following to the state $ (\p{graph}(l, \gamma) \septraction (x \mapsto m,l,r \ocon \p{graph}(l, \gamma) \ocon \p{graph}(r, \gamma))) \scon \p{graph}(l, \gamma')$, where $\gamma'$ is the mathematical graph after the \texttt{mark(l)} recursive call.

The third and final step is to eliminate the $\septraction$ operator from the state using lemmas. At line \ref{beforemarkleft}, we make use of the following lemma:

\[
\begin{array}{l}
(\p{graph}(l, \gamma) \septraction (x \mapsto m,l,r \ocon \p{graph}(l, \gamma) \ocon \p{graph}(r, \gamma))) \\
\quad \scon \p{graph}(l, \gamma') \wedge \p{subset\_reach}(\gamma,l,\gamma') \wedge \p{eqnot\_reach}(\gamma,l,\gamma') \\
\quad \wedge  \gamma(x)=(m,l,r) \wedge \gamma'(x)=(m1,l,r) ==> \\
\qquad \qquad x \mapsto m1,l,r \ocon \p{graph}(l, \gamma') \ocon \p{graph}(r, \gamma')
\end{array}
\]

Where, $\p{subset\_reach}$ and $\p{eqnot\_reach}$ are uninterpreted relations. The lemma application is guided by structural matching, the LHS of the lemma matches with the current state at line \ref{beforemarkleft}. Thus we apply the lemma by substituting and rewriting the state to RHS of the lemma. Thus, the $\septraction$ operator is eliminated from the state and we can happily use the usual HIP/SLEEK forward reasoning to proceed with the verification.

\subsection{Generating Coq module type}

% Parameter formula : Type.
% Parameter valid : formula -> Prop.

\lstset{deletekeywords={union},otherkeywords={Module,Type,Prop,Parameter,Axiom,End}}
\begin{figure}[t]
  \begin{lstlisting}
Module Type Mgraphmark.
 ...
 Axiom subgraphupdate_l : forall G v G1 x v1 l r,
  valid (imp (and (star (graph l G1)
  (mwand (graph l G) (union (ptto_node x v l r)
  (union (graph l G) (graph r G)))))
  (and (subset_reach G l G1) (and
  (eq_notreach G l G1) (and (lookup G x v l r)
  (lookup G1 x v1 l r)))))
  (union (ptto_node x v1 l r) (union (graph l G1)
  (graph r G1)))).
 ...
End Mgraphmark.
\end{lstlisting}
%% \vspace{-8pt}
\caption{Coq \li{Module Type} generated by HIP/SLEEK}
\label{fig:hipcoqfile}
\end{figure}

The lemmas used in HIP/SLEEK are ultimately certified mechanically in Coq. HIP/SLEEK generates a file with module type as shown in figure \ref{fig:hipcoqfile}, this file lists all lemmas that were used during the verification by HIP/SLEEK as axioms. The \texttt{Mgraphmark} module is implemented in Coq and those axioms are verified mechanically. Thus even though we rely on lemmas in HIP/SLEEK for automation our proof is verified end-to-end as we mechanically check all lemmas used by the tool. 