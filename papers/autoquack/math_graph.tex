To enable the verification of full functional correctness of graph
algorithms we need a way to reason about mathematical graphs.
To allow such verifications to be mechanized without undue pain
we must take care to develop a modular and general-purpose 
framework for such mathematical graphs.

\subsection{Structure of the mathematical graph framework}\label{sec:mathinfra}

\begin{figure}[t]
\centering
\beginpgfgraphicnamed{variousgraph}
\begin{tikzpicture}
[->/.style={thick,arrows={-Stealth}},
-->/.style={thick,arrows={-Stealth}, decorate, decoration={snake, amplitude=.4mm,segment length=2mm,post length=2mm}},
   realG/.style={shape=rectangle, rounded corners=4pt, draw, fill=gray!40},
   propG/.style={shape=rectangle, rounded corners=4pt, draw}]
\node[realG] (PG) at (0, 0) {\small PreGraph};
\node[realG] (LG) [right=0.8 of PG] {\small LabeledGraph};
\node[realG] (GG) [right=2 of LG] {\small GeneralGraph};
\draw [double, ->] (PG) -- (LG) node [pos=0.5, above] {\small Label} ;
\draw [double, ->] (LG) -- (GG) node (SC) [pos=0.5, above, align=center]
{\small Soundness \\ \small Condition};
\node[propG] (Prop) [below=0.6 of SC] {\small Property};
\node[propG] (PropL) [below=0.4 of Prop] {\small Property Lemmas};
\node[propG] (PGL) [below=2 of PG, align=center] {\small PreGraph \\\small Lemmas};
\node[propG] (LGL) [below=2 of LG, align=center] {\small LabeledGraph \\\small Lemmas};
\node[propG] (GGL) [below=2 of GG, align=center] {\small GeneralGraph \\\small Lemmas};
\draw [double, ->] (PGL) to (LGL);
%% \draw [double, ->] (LGL) to (GGL);
\draw [->] (PG) to (PGL);
\draw [->] (Prop) to (PropL);
\draw [-->] (Prop) to (SC);
\coordinate [left=0.2 of LG.south] (LGs1);
\coordinate [left=0.2 of LGL.north] (LGLn1);
\draw [->] (LGs1) to (LGLn1);
\coordinate [right=0.2 of LG.south] (LGs2);
\coordinate [right=0.2 of LGL.north] (LGLn2);
\draw [->] (LGs2) |- (Prop);
\draw [double, ->] (LGLn2) |- (PropL);
\coordinate [right=0.2 of GG.south] (GGs);
\coordinate [left=0.2 of GGL.north] (GGLn1);
\coordinate [right=0.2 of GGL.north] (GGLn2);
\draw [double, ->] (PropL) -| (GGLn1);
\draw [->] (GGs) to (GGLn2);
\node [draw, thick, rectangle, dashed, fit=(Prop) (PropL)] {};
\node (legend1) [below right=0.2 and -0.3 of PGL] {\small Dependence};
\coordinate[left=0.8 of legend1]  (l1);
\draw [->] (l1) to (legend1);
\node (legend2) [right=1 of legend1] {\small Inheritance};
\coordinate[left=0.8 of legend2]  (l2);
\draw [double, ->] (l2) to (legend2);
\node (legend3) [right=1 of legend2] {\small Instantializes};
\coordinate[left=0.8 of legend3]  (l3);
\draw [-->] (l3) to (legend3);
\end{tikzpicture}
\endpgfgraphicnamed
\vspace{1ex}
\caption{Structure of the Mathematical Graph Library}\label{fig:graphs}
\end{figure}

\begin{figure}[t]
\centering
\beginpgfgraphicnamed{pregraphexp}
\begin{tikzpicture}
[vad/.style={circle, fill=black, inner sep=0pt, minimum size=4pt},
 inv/.style={circle, draw=black, thick, inner sep=0pt, minimum size=4pt},
 ->/.style={thick, arrows={-Stealth}}]
\node[vad] (n1) at (0, 0) {};
\node[vad] (n2) at (1, 1) {};
\node[inv] (n3) at (1, -1) {};
\node[vad] (n4) at (-2,2) {};
\node[vad] (n5) at (-2,-2) {};
\node[vad] (n6) at (-3,0) {};
\node[vad] (n7) at (3,1.5) {};
\node[inv] (n8) at (3,-1.5) {};
\node[vad] (n9) at (3.5, 1) {};
\node[inv] (n10) at (3.5, 0.5) {};
\node at (3.5, 1) [right=1.5pt] {\small Valid node};
\node at (3.5, 0.5) [right=1.5pt] {\small Invalid node};
\node at (3.5, 0) [right=1.5pt] {\small Valid edge};
\node at (3.5, -0.5) [right=1.5pt] {\small Invalid edge};
\draw[->] (n1) to (n2);
\draw[->,dashed] (n1) to (n3);
\draw[->,dashed] (n3) to (n5);
\draw[->] (n2) to (n3);
\draw[->] (n2) to (n7);
\draw[->] (n2) to (n8);
\draw[->,dashed] (n3) to (n8);
\draw[->] (n4) to (n1);
\draw[->] (n1) to (n5);
\draw[->] (n2) to (n4);
\draw[->] (n1) to [bend left=20] (n6);
\draw[->] (n6) to (n5);
\draw[->] (n8) to [bend left=20] (n7);
\draw[->] (n4) to [bend right=35] (n1);
\draw[->] (3.0, 0) -- (3.6, 0);
\draw[->,dashed] (3.0, -0.5) -- (3.6, -0.5);
\end{tikzpicture}
\endpgfgraphicnamed
\vspace{1ex}
\caption{A PreGraph with invalid nodes and edges.}\label{fig:pregraph}
\end{figure}

Figure~\ref{fig:graphs} gives the overall architecture of how our graphs are constructed.
The most basic kind of graph is PreGraph, out of which we LabeledGraphs, and which in turn are used
to build GeneralGraphs.  Each kind of graph has some associated lemmas, and each kind inherits the lemmas of the previous kind.  %We will consider each in turn.

\paragraph{Pregraphs.} A PreGraph is a hextuple $(V, E, \phi_V, \phi_E, s, t)$,
where $V$ and $E$ are the underlying carrier set of vertices and edges.  Not every $v \in V$ or $e \in E$ is actually ``in'' the graph, so we provide the predicates $\phi_V$ and $\phi_E$ to classify vertices and edges as \emph{valid} (in) or not (out).  Finally, $s$ and $e : E -> V$ are functions that map an edges to their source and destination respectively; this model means that PreGraphs are directed rather than undirected.  By design, there are no requirements for \emph{e.g.} how the validity of edges and vertices related.  As shown in Figure \ref{fig:pregraph}, a PreGraph can contain invalid nodes and edges in an arbitrary configuration.

The advantage of designing a graph type that can reason about missing vertices and edges is because some of our later definitions need such flexibility.  Consider the difference of two graphs, $\gamma_1 - \gamma_2$.  Even if both of these graphs are ``well-formed'' to begin with, in the sense that valid nodes have only valid edges and vice versa, their difference may not since there may be dangling edges pointing to the now-removed vertices of $\gamma_2$.

Many basic graph concepts such as \emph{path}, \emph{reachability}, and \emph{subgraph} are defined on PreGraphs.
Informally a path is a list of nodes connected by edges.  Formally it is more convenient to
define a path as an ordered pair $(n,l)$ where $n$ is a node and $l$ is a list of edges.
A valid path requires $n$ to be the source of the first edge of $l$ (if one exists) and moreover
requires $l$ to be ``well chained''.  That is, the destination of one edge in $l$ must be the 
source of the next edge.  The list $l$ can be null to represent an empty path starting and ending
at the node $n$.  We prefer this encoding as opposed to some others (\emph{e.g.} a list of edges)
because the definitions of important concepts like reachability are cleaner.

The most important definition on PreGraph is the concept of reachability.
We use the notation $\gamma \models L_{n_2}^{n_1}(P)$ to mean that we can reach $n_2$ from $n_1$ via the path $L$ in PreGraph $\gamma$, and moreover that every node in $L$ satisfies predicate $P$.  This notation, along
with some derived ones such as
\begin{equation*}
\begin{split}
\gamma\models n_1 \xrightarrow{P} n_2 &\defeq \exists L, \gamma \models L_{n_2}^{n_1}(P),\\
\gamma\models n_1 \leadsto n_2 &\defeq \exists L, \gamma \models L_{n_2}^{n_1}(True)
\end{split}
\end{equation*}
form the bedrock of nearly every nontrivial predicate about and relation between
graphs.

In \S\ref{sec:spacegraph} we will tie mathematical graphs $\gamma$ to a spatial graph predicate
$\p{graph}(x, \gamma)$.   As we will see, $\p{graph}$ ``owns'' only the
spatial portion of $\gamma$ that is reachable
from $x$ even though $\gamma$ may contain other nodes.  Accordingly, when we reason about
$\p{graph}(x, \gamma)$, it is natural to want to describe the
reachable portion of $\gamma$.  In fact we generalize this
idea into two concepts: the subgraph of $\gamma$ satisfying
an arbitrary predicate $P$, written $\gamma \!\downarrow\! P$, and the \emph{relaxed subgraph}, written $\gamma \!\uparrow\! P$, which contains the all of the subgraph plus some additional edges.  In particular, $\gamma \!\downarrow\! P$ contains exactly the vertices satisfying $P$ and only the edges whose source and destination both satisfy $P$.  The relaxed subgraph $\gamma \!\uparrow\! P$ adds the additional edges whose \textbf{source} satisfies $P$, even though their destination may not.
We can use these definitions to, for example, extract the subgraph or relaxed subgraph reachable from a vertex $v$ by writing \emph{e.g.} $\gamma \!\downarrow\! (\lambda v'. \gamma\models v \leadsto v')$.

\paragraph{LabeledGraph.} 
PreGraph and its derived properties (reachability, subgraph, etc) are
inadequate for real program verification, even though many basic lemmas can already be proved about them.
However, when reasoning about the concrete graphs manipulated by various algorithms, 
we usually need to add a notion of \emph{labels} on vertices and/or edges, such as
the ``mark bit'' used in Figure~\ref{fig:markgraph}.

\paragraph{GeneralGraph.}
Much more interesting is the concept of GeneralGraph, which augments a LabeledGraph by adding a user-specified soundness condition.  In Figure~\ref{fig:graphs} this soundness condition is highlighted by a dashed border.  These ``plugins'' can specify many different kinds of properties.  Each property, in turn, can be used to prove many property-specific lemmas, all of which are inherited by the instantiating GeneralGraph.


illustrates the inheritance relation among the
three defintions and their corresponding lemmas. A GeneralGraph can be
seen as a LabeledGraph, and a LabeledGraph can be seen as a
PreGraph. Thus all lemmas about PreGraph can be applied to a
LabeledGraph or GeneralGraph for free, and all lemmas about
LabeledGraph are applicable to a GeneralGraph too. The soundness
condition can be configured with extra requirements of graphs. We
categories several common requirements into different property
bundles. Those property bundles along with their derived lemmas can be
seen as certain kinds of ``plug-ins'' of the framework, which are
indicated as a dashed rectangle in Figure~\ref{fig:graphs}.

, each of which carries with it some associated 

there are many features
which a bare PreGraph can not inculde. For example, many algorithms
about graphs assume there are labels in vertices or edges. And some
graph related theorems do not allow dangling edges (i.e.\ valid edges
with invalid vertices). The former problem can be solved by adding
label functions to the definition of PreGraph, which defines
a \emph{LabeledGraph}. For the latter one, we
defined \emph{GeneralGraph} which contains a configurable soundness
condition based on LabeledGraph.




\subsection{Definitions of graph and other concepts}


For example, some graph theory lemmas only hold when the graph is
finite (i.e.\ finite vertices and finite edge). We call this
property \emph{FiniteGraph}. We also defined a less restrictive
property called \emph{LocalFiniteGraph}, which requires that each
vertex only has finite neighbors. In the recursive defnition of a
graph data structure, a node contains many pointers to point to its
neighbors. The pointers could be null to indicate that they do not
point to any. Thus we need a special node which represents null
pointer. We call this kind of graph as \emph{MathGraph}. In some
cases, we have to specify a graph in which the outdegree of each nodes
is 2. That is a \emph{BiGraph}. FiniteGraph, LocalFiniteGraph,
MathGraph and BiGraph, each with its own related lemmas, are four
property plugins of our framework. There are several other plugins.


Furthermore, property plugins can be composed to a larger plugin. This
composition is not just putting them together because when we consider
two property bundles at the same time, new lemmas would emerge, just
like Figure~\ref{fig:properties}. For example, we compose BiGraph,
MathGraph and FiniteGraph together---called \emph{BiMaFin}---as the
soundness condition for GeneralGraph in verifying the program
in \S\ref{sec:orientation}.

\begin{figure}[t]
\centering
\beginpgfgraphicnamed{graphproperty}
\begin{tikzpicture}
[->/.style={thick,arrows={-Stealth}},
   group/.style={shape=rectangle, draw, thick, dashed},
   propG/.style={shape=rectangle, rounded corners=4pt, draw}]
\node[propG] (PL12) at (0, 0) {\small Lemmas of Property 1 and 2};
\coordinate [left=1 of PL12.north] (PL12n1);
\coordinate [right=1 of PL12.north] (PL12n2);
\node[propG] (PL1) [above=0.5 of PL12n1, align=center] {\small Property 1 \\\small Lemmas};
\node[propG] (PL2) [above=0.5 of PL12n2, align=center] {\small Property 2 \\\small Lemms};
\node[propG] (P1) [above=0.5 of PL1] {\small Property 1};
\node[propG] (P2) [above=0.5 of PL2] {\small Property 2};
\draw [->] (P1) to (PL1);
\draw [->] (P2) to (PL2);
\draw [double, ->] (PL1) to (PL12n1);
\draw [double, ->] (PL2) to (PL12n2);
\draw [->] (P1.west) to [bend right=45] (PL12.west);
\draw [->] (P2.east) to [bend left=45] (PL12.east);
\node (R1) [group, fit=(P1) (PL1)] {};
\node (R2) [group, fit=(P2) (PL2)] {};
\node (R3) [group, fit=(current bounding box)] {};
\node [propG] (P1P2) [above right=-1.1 and 1.2 of R3, align=left] {\small Property 1$/|$ \\\small Property 2};
\node [propG] (PL1PL2) [below=0.5 of P1P2, align=center] {\small Prop. 1 Lemmas \\\small Prop. 2 Lemmas \\\small Prop. 1$/|$2 Lemmas};
\draw [->] (P1P2) to (PL1PL2);
\node (R4) [group, fit=(P1P2) (PL1PL2)] {};
\node (EQ) [right=0 of R3] {\bf \Large $\mapsto$};
\end{tikzpicture}
\endpgfgraphicnamed
\vspace{1ex}
\caption{Graph Properties}\label{fig:properties}
\end{figure}

One example of the compositional property lemmas is listed as follows:
\newtheorem{mylem}{Lemma}
\begin{mylem}\label{lem:computereach}
\[
\begin{split}
\forall \gamma, x.~&\text{MathGraph }x => \text{LocalFiniteGraph x} =>\\
        & \p{reachable}(\gamma, x)\text{ is finite} => \\
        & \text{compute an }S \text{ s.t.\ } \forall v.~v \in S <=>
        \gamma \models x \leadsto v.
\end{split}
\]
\end{mylem}
It sounds so trivial but the proof is subtle. The most obvious way to
prove it---filtering reachable nodes from all valid nodes---is
impossible: there is no decision procedure for reachability to select
reachable nodes because the current definition of graphs is applicable
for graphs containing infinite number of nodes (A LocalFiniteGraph can
still be infinite). In such a graph, one may need to inspect infinite
number of paths to judge whether a node is reachable, which is a
mission impossible.

Another intuitive way to construct the reachable list is using a
breadth-first searching algorithm to collect distinct nodes along the
edges from $x$, which is employed in the proof. But still, a na\"ive
implementation may not terminate. As mentioned in the premises of this
lemma, the number of reachable nodes has an upper bound. So the
actually working breadth-first searching function is constructed as
follows. It holds a set of nodes collected so far and a queue for
visited but unexpanded nodes. It keeps on expanding nodes from the
queue to add distinct nodes to result set and the processing queue,
until the processing queue is empty or the number of nodes collected
reaches the upper bound. It is worth mentioning that constructing this
function in Coq is nontrivial. The direct implementation is rejected
because it violates the syntactic criteria for recursion in Coq. It
has to be defined in a sophisticated way: defining a well-founded
relation and proving that the definition of the function fulfills the
relation.

\subsection{Application of the framework}

We apply our framework to define other structures and relations
between these structures (including graph), and then use them to prove
certain pure facts proposed by real verifications.

For example, we define dag (directed acyclic graph) as a PreGraph with
an additional property: forall any $x$ and $y$, if $x$ is reachable
from $y$, then $y$ is not reachable from $x$. We also define tree in a
similar way. The additional property for tree is that there is one and
only one path from root to any reachable node from root. As for
relations, we define the relation $\m{mark}(\gamma, \tx x, \gamma')$
for the ``graph mark'' algorithm in Figure~\ref{fig:markgraph}. It
means $gamma'$ is the result of marking $\gamma$ from $\tx
x$. Similarly, we define $\m{span}$ for the ``spanning tree'' program
and $\m{copy}$ for the ``graph copy'' program. All these relations
captured the connections of the states of mathematical graphs before
and after program execution. As we mentioned before, $\m{mark}$ and
related lemmas are reused in proving pure facts of ``spanning tree''
and ``graph copy'' because the latter two programs do contain marking
operations. So we reuse the following pure fact:
\begin{equation*}
\begin{split}
\forall \gamma, x, n.~&\gamma(x)=(0, v_1, v_2,\dots,v_n) => \m{mark1}(\gamma, x, \gamma_1) =>\\
        & \m{mark}(\gamma_1,v_1,\gamma_2) => \m{mark}(\gamma_2,v_2,\gamma_3) => \dots =>\\
        & \m{mark}(\gamma_n,v_n,\gamma_{n+1}) => \m{mark}(\gamma,x,\gamma_{n+1}).
\end{split}
\end{equation*}
Note that it is a general theorem for any LocalFiniteGraph, not just
BiGraph. In our framework, almost all theorems (except $\m{span}$
related ones) are proved as generally as possible.

It is worth mentioning that when dealing with formal proofs, there are
some unexpected facts which showed the rigidity of mechanized
verification. For example, our na\"ive definition of the relation
$\m{span}$ is not strong enough to complete a above-like inference. We
express that graph $g_2$ is a spanning tree of graph $g_1$ starting
from root node $r$ as $\m{span}(g_1, r, g_2)$. We conclude three
relations as the predicate. First, the unreachable parts from root $r$
in $g_1$ and $g_2$ are the same. Secondly, the shape of $g_2$ must be
a tree. Lastly, all nodes reachable from $r$ in $g_1$ are still
reachable from $r$ in $g_2$. The second relation ensures that the
result is a tree while the third one ensures it is a spanning tree of
$g_1$. At first glance, it is a very complete definition. But the
subsequent formal proof reveals that the definition still lacks one
condition: for any two nodes $a$ and $b$, if $a$ is reachable from $r$
in $g_1$ and $b$ is not reachable from $r$ in $g_1$, then in $g_2$,
$b$ is not reachable from $a$. It is a long-winded but necessary
relation.
