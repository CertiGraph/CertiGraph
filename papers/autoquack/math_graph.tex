As pointed out in \cite{hobor:ramification}, na\"iave attempts to
verify graph-manipulating programms using the shape-only predicates
are unsound. An obvious solution---especially for verifying functional
correctness---is to involve a mathematical graph $\gamma$ in spatial
predicates as a parameter. Since the additional parameter is involved
in the specification, we needs a way to reason about it, so as to
deduce the specification. Thus we formalize a general-purpose proof
framework for mathematical graphs and provide a bunch of useful
theorems in graph theory to ease the burden in verifying programs. In
this section, we will introduce the framework and show how we built
them.

\subsection{Definitions of graph and other concepts}
The core of the graph theory framework are the definitions of graph,
graph-related structures and relations. In mathematics, a (directed)
graph is an ordered pair $(V, E)$ where $V$ is the set of vertices or
nodes and $E$ is the set of edges comprising a source node and a
destination node. Analogously, in our framework, a mathematical graph
is a hextuple $(V, E, \phi_V, \phi_E, s, t)$ where $V$/$E$ is the type
of vertices/edges, $\phi_V$/$\phi_E$ is the predicate over $V$/$E$
which asserts the validity of a vertex/edge, $s$ and $e$ are functions
of type $E -> V$ which maps an edge to its source and destination
respectively. Invalid nodes and edges are not considered as elements
of a graph. However, there are no additional requirements for the
validity of the whole graph. As shown in Figure \ref{fig:pregraph},
our graph can contain invalid nodes and edges. That is why we call
this combinatorial structure \textbf{PreGraph} because it can express
not just normal graphs. We design it deliberately because we need a
way to present such things. For example, the difference of two graphs:
$\gamma_1-\gamma_2$, is not necessarily a normal graph because it may
contain dangling edges. The ``subtracted'' nodes are not really
removed but are ruled out from valid nodes because they are still
referred in edge-part of $\gamma_1-\gamma_2$. Many concepts such as
path, reachability, subgraph are defined based on PreGraph.

\begin{figure}
\centering
\beginpgfgraphicnamed{pregraphexp}
\begin{tikzpicture}
[vad/.style={circle, fill=black, inner sep=0pt, minimum size=4pt},
 inv/.style={circle, draw=black, thick, inner sep=0pt, minimum size=4pt},
 ->/.style={thick, arrows={-Stealth}}]
\node[vad] (n1) at (0, 0) {};
\node[vad] (n2) at (1, 1) {};
\node[inv] (n3) at (1, -1) {};
\node[vad] (n4) at (-2,2) {};
\node[vad] (n5) at (-2,-2) {};
\node[vad] (n6) at (-3,0) {};
\node[vad] (n7) at (3,1.5) {};
\node[inv] (n8) at (3,-1.5) {};
\node[vad] (n9) at (3.5, 1) {};
\node[inv] (n10) at (3.5, 0.5) {};
\node at (3.5, 1) [right=1.5pt] {\small Valid node};
\node at (3.5, 0.5) [right=1.5pt] {\small Invalid node};
\node at (3.5, 0) [right=1.5pt] {\small Valid edge};
\node at (3.5, -0.5) [right=1.5pt] {\small Invalid edge};
\draw[->] (n1) to (n2);
\draw[->,dashed] (n1) to (n3);
\draw[->] (n2) to (n3);
\draw[->] (n2) to (n7);
\draw[->] (n2) to (n8);
\draw[->,dashed] (n3) to (n8);
\draw[->] (n4) to (n1);
\draw[->] (n1) to (n5);
\draw[->] (n2) to (n4);
\draw[->] (n1) to (n6);
\draw[->] (n6) to (n5);
\draw[->] (3, 0) -- (3.5, 0);
\draw[->,dashed] (3, -0.5) -- (3.5, -0.5);
\end{tikzpicture}
\endpgfgraphicnamed
\vspace{1ex}
\caption{A PreGraph with invalid nodes and edges.}\label{fig:pregraph}
\end{figure}

\paragraph{Path}
Once we have the definition of PreGraph, it is time to define another
infrastructure: path. Informally, a path is a list of nodes
concatenated with edges. Since an edge contains the information about
its source and destination, there is no necessary to define path as an
interleaving list of nodes and edges. Then we have two obvious choices
for representation of a path: a list of nodes or a list of edges.

Both choices have certain defects. If a path is defined as a list of
nodes, we can not distinguish different paths between two nodes in
case there are multiple edges between two nodes. If a path is defined
as a list of edges, then we can deal with multiple edges but we can
not represent an empty path for a certain node---we can not determine
which node an empty list of edges belongs to.

To avoid the defects above, we define the path as a ordered pair $(n,
l)$ where $n$ is a node and $l$ is a list of edges. A valid path
requires that $n$ is the source node of the first edge of $l$ and $l$
is well chained---the destination of an edge in $l$ is the same as the
source of the next edge. The list $l$ can be null to represent an
empty path for a particular node $n$.

Why we insist that a path---even an empty path---must have a leading
node? One reason is that with such a definition, we can give a
consistent definition for a very important concept: reachability.

\paragraph{Reachability}
Among various properties derived from PreGraph, the most important one
is the reachability. The definition of reachability is based on
path. The notation $\gamma \models L_{n_2}^{n_1}(P)$ means in PreGraph
$\gamma$, node $n_2$ is reachable from node $n_1$ along the path $L$
while every node in $L$ satisfies predicate $P$. This notation, along
with other derived ones, such as
\begin{equation*}
\begin{split}
\gamma\models n_1 \xrightarrow{P} n_2 &\defeq \exists L, \gamma \models L_{n_2}^{n_1}(P),\\
\gamma\models n_1 \leadsto n_2 &\defeq \exists L, \gamma \models L_{n_2}^{n_1}(True)
\end{split}
\end{equation*}
form the bedrock of nearly every nontrivial predicate about
graphs. Either the relation of two states---before and after running
an algorithm---of a graph or the description of a graph with a
particular shape, reachability is inevitable. To some extent, it is
quite natural because most graph-related algorithms (DFS, BFS,
Shortest Path, Spanning Tree, etc) depend on a small operation:
exploring neighbours from one node. Thus when describing the effect of
an algorithm, reachability is indispensable. Some of those
descriptions are discussed in later sections.

\paragraph{Subgraph}
When we tie a mathematical graph $\gamma$ to a spatial graph predicate
$g(x, \gamma)$ (which will be explained later), $g$ ``owns'' only the
spatial representation of the portion of $\gamma$ that is reachable
from $x$; $\gamma$ may contain other nodes. When we reason about
$g(x, \gamma)$, it is a very natural requirement to describe the
reachable portion of $\gamma$ in pure part. We generalize this
description as two concepts: partial graph $\gamma \!\uparrow\! P$ and
subgraph $\gamma \!\downarrow\! P$ for arbitrary predicate $P$. To define
$\gamma \!\uparrow\! P$ and $\gamma \!\downarrow\! P$, for any $\gamma=(V,
E, \phi_V, \phi_E, s, t)$, we do not change $V$ and $E$ but change
$\phi_V$ and $\phi_E$ by adding proposition about satisfying $P$ for
nodes. It means valid nodes in $\gamma \!\uparrow\! P$ and
$\gamma \!\downarrow\! P$ must satisfy $P$. The only difference between
$\gamma \!\uparrow\! P$ and $\gamma \!\downarrow\! P$ is that in
$\gamma \!\uparrow\! P$ the edges with its source node satisfying $P$ is
valid, but in $\gamma \!\downarrow\! P$, valid edges means both its source
and destination nodes satisfy $P$. With the concepts of partial graph
and subgraph, we can express the reachable portion by instantiating
$P$ as reachable predicate.

\subsection{Classification of various graphs}

PreGraph and its derived properties (reachability, subgraph, etc) are
inadequate for real program verifications. Admittedly many helpful
lemmas can be inferred directly from PreGraph. But when we dealing
with concrete graphs for various algorithms, there are many features
which a bare PreGraph can not inculde. For example, when we compute
some properties of a graph, we always hope the graph is finite. In the
recursive defnition of a graph data structure, a node contains many
pointers to point to its neighbors. The pointers could be null to
indicate that they do not point to any. Thus we need a special node
which represents null pointer. In some cases, we have to specify a
graph in which the outdegree of each nodes is 2. All these additional
properties are abstracted as different property bundles. We
defined \textbf{FiniteGraph}, \textbf{MathGraph} and \textbf{BiGraph}
to fulfill the three requirements above, respectively.

\begin{figure}[htbp]
\centering
\beginpgfgraphicnamed{variousgraph}
\begin{tikzpicture}[->/.style={thick,arrows={-Stealth}},
                    realG/.style={shape=rectangle, rounded corners=4pt, draw, fill=gray!40},
                    propG/.style={shape=rectangle, rounded corners=4pt, draw}]
\node[realG] (PG) at (0, 0) {PreGraph};
\node[realG] (LG) [below=1 of PG] {LabeledGraph};
\node[realG] (GG) [right=3 of LG] {GeneralGraph};
\draw [->] (PG) -- (LG) node [pos=0.5, right] {\small Add Label} ;
\draw [->] (LG) -- (GG) node [pos=0.5, above] {\small Add} node (SC) [pos=0.5, below] {\small Soundness Condition};
\node[propG] (BMF) [below=1 of SC] {BiMaFin};
\draw [double,->] (BMF) -- (SC) node [pos=0.5, left] {\small Instantialize};
\node[propG] (BG) [left=1 of BMF] {BiGraph};
\node[propG] (MG) [below=0.5 of GG] {MathGraph};
\node[propG] (FG) [below=0.5 of MG] {FiniteGraph};
\draw [->] (BG) to (BMF);
\draw [->] (MG) to (BMF);
\draw [->] (FG) to (BMF);
\end{tikzpicture}
\endpgfgraphicnamed
\vspace{1ex}
\caption{Various Kinds of Graphs}\label{fig:graphs}
\end{figure}

As shown in Figure \ref{fig:graphs}, there are several different
``Graph'' definitions in our framework. Some of them (with gray
background) are real mathematical objects, just like PreGraph. The
rest are just property bundles which are PreGraph with special
properties. They provide different views of graphs from certain
perspectives.

In our framework, there are three kinds of \emph{real}
graphs: \textbf{PreGraph}, \textbf{LabeledGraph}
and \textbf{GeneralGraph}. The definition of PreGraph is already
known. Based on a PreGraph, when adding labels of vertices or of
edges, we get a LabeledGraph. Sometimes when we hope the graph we
refer to satisfies more conditions (finite, binary, etc), we can use
GeneralGraph with a customized soundness condition. We distinguish
these ``Graphs'' because we hope the lemmas provided by our framework
are in their most general and flexible form. For some of the lemmas, a PreGraph is
enough while others may not hold without extra conditions.

The rest in Figure \ref{fig:graphs} are all property bundles where
FiniteGraph, MathGraph and BiGraph are already explained. BiMaFin is a
compositional property of the three: it means a graph satisfying
BiGraph, MathGraph and FiniteGraph simultaneously. As an application,
we adopt BiMaFin as the soundness condition for GeneralGraph in the
final real verifications.

\subsection{Computable Reachability}
We proved quite many property-bundle specific theorems. One typical
example of such theorems is the following one:
\newtheorem{mythm}{Theorem}
\begin{mythm}
For any graph $\gamma$ which is both MathGraph and LocalFiniteGraph
(i.e. every node has a finite number of neighbors) and any node $x$ in
$\gamma$, if the number of nodes reachable from node $x$ is finite,
then we can find a set which exactly contains the reachable nodes from
$x$ in $\gamma$.
\end{mythm}
It sounds so trivial but the proof is totally non-trivial. The most
obvious way to prove it---filtering reachable nodes from all valid
nodes---is impossible: there is no decision procedure for reachability
to select reachable nodes because the current definition of graphs is
applicable for graphs containing infinite number of nodes (A
LocalFiniteGraph can still be infinite). In such a graph, one may need
to inspect infinite number of paths to judge whether a node is
reachable, which is a mission impossible.

Another intuitive way to construct the reachable list is using a
breadth-first searching algorithm to collect distinct nodes along the
edges from $x$, which is employed in the proof. But still, a na\"ive
implementation may not terminate. As mentioned in the premises of this
lemma, the number of reachable nodes has an upper bound. So the
actually working breadth-first searching function is constructed as
follows. It holds a set of nodes collected so far and a queue for
visited but unexpanded nodes. It keeps on expanding nodes from the
queue to add distinct nodes to result set and the processing queue,
until the processing queue is empty or the number of nodes collected
reaches the upper bound. It is worth mentioning that constructing this
function in Coq is hard. The direct implementation is rejected because
it violates the syntactic criteria for recursion in Coq. It has to be
defined in a sophisticated way: defining a well-founded relation and
proving that the definition of the function fulfills the relation.

After the establishing of the searching function, it is still hard to
prove that the result generated by the function is the reachable
list. There are two goals that needs to be proved: one is that all
nodes collected by this searching function is reachable from $x$ and
the other is all reachable nodes from $x$ is in the
collected list of the searching function. The former one is relatively
easier than the latter because for the latter case, there are two
completeness proofs corresponding to the two different termination
conditions. It is not known yet whether a proof by contradiction
exists or is simpler.

\subsection{Application of the framework}

Graph-manipulating programms may also deal with other structures, such
as dags (directed acyclic graphs), trees or spanning trees. With the
basic defintions in our framework, new structures can be defined
easily. Acyclic graph is just a graph with an additional property:
forall any $x$ and $y$, if $x$ is reachable from $y$, then $y$ is not
reachable from $x$. Tree is similar. The additional property for tree
is that there is one and only one path from root to any reachable node
from root. Spanning tree is a tree with the same reachable vertex set
of the original graph.

But when dealing with formal proofs, there are some unexpected
facts. For example, our na\"ive definition of the
predicate \verb|spanning_tree| is not strong enough to complete the
inference. We express that graph $g_2$ is a spanning tree of graph
$g_1$ starting from root node $r$ as \verb|spanning_tree|
$g_1\,r\,g_2$. We conclude three relations as the predicate. First,
the unreachable parts from root $r$ in $g_1$ and $g_2$ are the
same. Secondly, the shape of $g_2$ must be a tree. Lastly, all nodes
reachable from $r$ in $g_1$ are still reachable from $r$ in $g_2$. The
second relation ensures that the result is a tree while the third one
ensures it is a spanning tree of $g_1$. At first glance, it is a very
complete definition. But the subsequent formal proof reveals that the
definition still lacks one condition: for any two nodes $a$ and $b$,
if $a$ is reachable from $r$ in $g_1$ and $b$ is not reachable from
$r$ in $g_1$, then in $g_2$, $b$ is not reachable from $a$. It is a
long-winded but necessary relation.
