% inline code
\makeatletter
\newlength{\@mli}
\newcommand{\mli}[1]{%
  \settowidth{\@mli}{\lstinline/#1/}
  \hspace{-.5ex}\begin{minipage}[t]{\@mli}\lstinline/#1/\end{minipage}}
\makeatother
\newcommand{\li}[1]{\ifmmode\mbox{\mli{#1}}\else\mbox{\lstinline/#1/}\fi}

\newcommand{\tx}[1]{\text{#1}}
\newcommand{\p}[1]{\ensuremath{\mathsf{#1}}} % predicate font
\newcommand{\m}[1]{\ensuremath{\mathit{#1}}} % math font
%\let\ramify\lightning
\newcommand{\ramify}{\mbox{\lightning}}
\newcommand{\infrulestyle}[1]{\textsc{#1}}
\newcommand{\infrule}[4]{\inferrule*[lab=\infrulestyle{#1},right=$\mathrlap{#4}$]{#2}{#3}}
\newcommand{\RuleS}[4]{\infrulestyle{#1}\frac{#2}{#3} \textit{#4}}
\newcommand{\Rule}[3]{\[\RuleS{#1}{\begin{array}{c} #2 \end{array}}{#3}{}\]}
\newcommand{\MV}{\ensuremath{\mathsf{ModVar}}}
\newcommand{\FV}{\ensuremath{\mathsf{FreeVar}}}
\newcommand{\pguards}[1]{\llbracket #1 \rrbracket}



\input{mark_listing.tex}

In Figure~\ref{fig:markgraph} we put the code and proof sketch of the classic \li{mark} algorithm that visits and colors every reachable node in a heap-represented graph.  The \li{mark} algorithm is good to start with because it is complex enough to require some care to verify while being simple enough that the invariants are straightforward.  In \S\ref{sec:application} we will discuss more complex examples that do the kinds of things \li{mark} does not (\emph{e.g.} structurally changing the graph by adding/changing/removing edges and/or vertices).  Hobor and Villard developed a modular way to verify graph-manipulating programs called ``ramification'' and the outline of our verification sketch for \li{mark} draws heavily their first example~\cite{hobor:ramification}.  However, we have made many improvements to both their theory and practice as we detail below.

\textbf{First}, the code in Figure~\ref{fig:markgraph} is written in the Clight language~\cite{blazy:clight}.  Clight is an input language to the CompCert certified compiler~\cite{leroy:compcert}, which compiles our code exactly as written.  \textbf{Second}, the paper-format verification sketch for \li{mark} in Figure~\ref{fig:markgraph} is backed by a fully machine-checked proof using an upgraded version of the Floyd system of the Verified Software Toolchain (VST)~\cite{appel:programlogics}; our upgrades are explained in \S\ref{vst}.  Accordingly, there is an unbroken certified chain from our specification of \li{mark} all the way to the assembly code.  The program invariants in Figure~\ref{fig:markgraph} are almost exactly what is used in the Floyd proof, with only minor cleanup to aid the presentation.

The specification we certify (lines \ref{code:markstart} and \ref{code:markend}) is
\[
\{\p{graph}(\li{x},\gamma)\}~\li{mark(x)}~\{\exists \gamma'.~ \p{graph}(\li{x},\gamma') /| \m{mark}(\gamma, \li{x}, \gamma')\}
\]
The specification is for full functional correctness and stated incorporating some \emph{mathematical} graphs $\gamma$.  Our \textbf{third} improvement on Hobor and Villard is that the definition of $\gamma$ we employ is quite general; we defer it until \S\ref{sec:mathgraph}.  For now consider $\gamma$ to be a function that maps a vertex $v \in V$ to triples $(m,l,r)$, where $m$ is a ``color'' bit (0 or 1) and $\{l,r\} \subseteq V \uplus \{0\}$ are the neighbors of $v$.  %Neighbors can take a non-$V$ ``null'' value.

The \p{graph} predicate is \emph{spatial}, \emph{i.e.} defined with separation logic operators such as maps-to $|->$, and explains how the mathematical graph $\gamma$ is actually implemented in the heap.  Our \textbf{fourth} improvement on Hobor and Villard is that our spatial \p{graph} predicate is also quite general, so we defer it until \S\ref{sec:spacegraph}.  For now it is enough to know that \p{graph} satisfies the following fold/unfold relationship:
{\color{magenta} SNIP}
This fold/unfold relationship has several interesting points.  
First, as we explain in \S\ref{sec:fixpointfail}, it is a terrible mistake to write \eqref{eqn:bigraphintrofoldunfold} as a definition using $\stackrel{\Delta}{=}$ rather than as a biimplication using $<=>$.  Second, as in Hobor and Villard, \eqref{eqn:bigraphintrofoldunfold} uses the less-standard ``overlapping conjunction'' $\ocon$ of separation logic.  The semantics of $\sigma |= P \ocon Q$ is that the state $\sigma$ divides into \emph{three} disjoint parts $\sigma_1$, $\sigma_2$, and $\sigma_3$ such that $\sigma_1 \oplus \sigma_2 |= P$ and $\sigma_2 \oplus \sigma_3 |= Q$.  That is, $P$ and $Q$ share the existentially-quantified substate $\sigma_2$, which we use in the unfolded side of \eqref{eqn:bigraphintrofoldunfold} to indicate that all portions of the graph can overlap (\emph{e.g.}, nodes in the left subgraph can also be in the right subgraph or even be the root $x$).  The presence of the unspecified sharing indicated by the $\ocon$ connective is exactly why graph-manipulating algorithms are so hard to verify (\emph{e.g.}, it is hard to apply the \infrulestyle{Frame} rule).  Third \eqref{eqn:bigraphintrofoldunfold} includes an example of a consequence of how an industrial-strength setting complicates verification.  Lines~\ref{code:nodedefstart}--\ref{code:nodedefend} define the data type \li{Node} used by \li{mark}.  The \li{_Allignas($n$)} directives force the compiler to align fields on $n$-byte boundaries.  As explained in \S\ref{sec:foldunfold}, this alignment is necessary in C-like memory models to prove the fold-unfold relationship \eqref{eqn:bigraphintrofoldunfold}, which is why \eqref{eqn:bigraphintrofoldunfold} includes an alignment restriction $x~\mathsf{mod}~16 = 0$ and an existentially-quantified ``blank'' second field for the root $x \mapsto m,-,l,r$.  (In our Floyd proofs the alignment restriction and blank second field are nicely hidden ``behind the scenes'', but they are there if you unfold the definitions far enough.)

Our \textbf{fifth} improvement on Hobor and Villard is that the postcondition of \li{mark} is specified \emph{relationally}, \emph{i.e.}
\[
\{\exists \gamma'.~ \p{graph}(\li{x},\gamma') /| \m{mark}(\gamma, \li{x}, \gamma')\}
\]
instead of \emph{functionally}, \emph{i.e.}
\[
\{\p{graph}\big(\li{x},\m{mark}(\gamma, \li{x})\big)\}
\]
In both cases a mathematical definition $\m{mark}$ is used; in the first case it is a relation that specifies that $\gamma'$ is the result of correctly marking $\gamma$ from \li{x}, whereas in the second it is a function that computes the result of marking $\gamma$ from \li{x}. For both practical and theoretical reasons a relational approach is better.  Practically, it is remarkably painful to define computational functions over graphs in a proof assistant like Coq.  Substantial portions of this pain are even unnecessary: for example, Coq requires that all functions terminate, a nontrivial proof obligation over cyclic structures like graphs, but our verification of \li{mark} is only for partial correctness.  In contrast, defining relations is much easier because \emph{e.g.} one can use quantifiers and do not have to prove termination.  Theoretically, relations are preferable because they are more general (\emph{e.g.} they allow some ``inputs'' to not have ``outputs'', \emph{i.e.} be partial; or conversely allow multiple outputs from a single input, \emph{i.e.} in nondeterministic settings) and more compositional (\emph{i.e.}, we can reuse relations and associated lemmas in other verifications).
We take advantage of compositionality by using $\m{mark}(\gamma,x,\gamma') /| \ldots$ to specify both our ``spanning tree'' and ``graph copy'' algorithms in \S\ref{sec:application}, which also mark nodes while carrying out their primary task.

The actual definition of the $\m{mark}$ relation is straightforward.  Our mathematical graphs admit natural definitions of reachability, and so $\m{mark}(\gamma,x,\gamma')$ means that
{\color{magenta} SNIP}
That is, $\gamma$ and $\gamma'$ have the same vertices and edges but the mark bits in $\gamma'$ have been set to 1 (marked) in all nodes $x'$ reachable from $x$ in $\gamma$ along an unmarked path.  Note the use of the $\forall$ quantifier, permitted because \m{mark} is a relation.

Turning to the body of the verification (lines~\ref{code:inmark}--\ref{code:outmark}), our \textbf{sixth} improvement over Hobor and Villard is perhaps the most readily apparent visually: blocks of proof script bracketed by the symbols $\searrow$ and $\swarrow$, such as lines~\ref{code:beforerootmark}--\ref{code:afterrootmark}.  We call a bracketed set of lines like this a ``localization block'', and it is a new paper-based notation/visualization for Hobor and Villard's concept of \emph{ramification}.  The intuitive idea is that we zoom in from a larger ``global'' context into a smaller ``local'' one.  After verifying some commands locally to arrive at the local postcondition we zoom back out to the global postcondition. In the case of these lines, you can imagine unfolding the \p{graph} predicate in line~\ref{code:globalbeforerootmark} using equation \eqref{eqn:bigraphintrofoldunfold} and then zooming in to the root node \li{x} for lines~\ref{code:beforerootmark}--\ref{code:afterrootmark}, before zooming back out in line~\ref{code:globalafterrootmark}.  Although we do not use this power here, localization blocks can be safely nested.  We will define localization blocks formally in \S\ref{sec:localizations}.
This notation was inspired by the way we mechanized our theories in \S\ref{vst}, but we believe it to be useful outside of mechanized contexts.

Our \textbf{seventh} improvement is best illustrated by lines~\ref{code:markbeforetripleramify}--\ref{code:markaftertripleramify}.  As explained more fully in \S\ref{sec:freevars}, Hobor and Villard's \infrulestyle{Ramify} rule interacts very poorly with modified program variables such as \li{l} and \li{r}.  They hacked their way around this issue by proposing a variant of \infrulestyle{Ramify} called \infrulestyle{RamifyAssign}, which could reason about the special case of a single assignment \li{x=$f(\ldots)$}, assuming the verifier can make the local program translation to \li{x'=$f(\ldots)$;x=x'}, where \li{x'} is fresh.  They proposed no way to verify unmodified program code or to ramify/localize across multiple assignments; we do both in lines~\ref{code:markbeforetripleramify}--\ref{code:markaftertripleramify} using a new \infrulestyle{Ramify-P} rule.




{\color{magenta} 
existentials \S\ref{sec:existentials} 4.2. Using existential quantifier in post condition.
}

Our \textbf{nineth} and final improvement over Hobor and Villard is that, not content with verifying \li{mark} with one mechanized verification tool (VST), we also verify it using the HIP/SLEEK system~\cite{chin:hipsleek}.  HIP/SLEEK is at a very different point in the design space for verification tools than VST, with on the one hand a much higher emphasis on automation but on the other no machine-checked soundness proof.  HIP/SLEEK verifies a \li{mark} program written in a variant of Java instead of Clight, and generates a proof that is structured modestly differently due to the way HIP/SLEEK is engineered to increase automation.  Nevertheless, both verifications share the vast majority of their Coq code base, providing some evidence that our techniques are applicable to a variety of verification tool styles.  We explain our modifications to HIP/SLEEK and discuss our experience verifying the \li{mark} algorithm using it in \S\ref{sec:hipsleek}.

\subsection{Frames and ramifications are localizations}
\label{sec:localizations}
The key rule of separation logic is \infrulestyle{Frame}~\cite{rey02}:
\[
\infrule{Frame}
{\{ P \} ~ c ~ \{Q \}}
{\{P * F \} ~ c ~ \{ Q * F \}}
{\begin{array}{c}F \textrm{ ignores } \MV(c) \end{array}} \qquad \qquad
\]
The reason \infrulestyle{Frame} is so important is because it enables local verifications.  That is, a verifier can focus on the portions of the heap that are relevant to command $c$ and ``frame away'' the rest.  The side condition $F \textrm{ ignores } \MV(c)$ relates to modified program variables and will be discussed in \S\ref{sec:freevars}.
 
Hobor and Villard observed that \infrulestyle{Frame} is bit rigid because it forces verifiers to split program assertions into syntactically $*$-separated parts~\cite{hobor:ramification}.  This rigidity is particularly unpleasant when verifying programs that manipulate data structures with intrinsic unspecified sharing such as DAGs and graphs.  Hobor and Villard proposed the \infrulestyle{Ramify} rule to circumvent this rigidity:
\[
\infrule{Ramify}
{\{L_1\} ~ c ~ \{L_2\} \\ G_1 |- L_1 * (L_2--* G_2)}
{\{G_1\} ~ c ~ \{G_2\}}
{\begin{array}{c}(L_2 --* G_2) \\ \textrm{ignores} \\ \MV(c) \end{array}} \qquad \qquad \qquad
%{$\begin{array}{l}\m{fv}(Q --* R') \cap \null \\ \m{modif}(c) = \emptyset\end{array}$} \qquad \qquad \qquad
\]
That is, we can verify a ``global'' specification $\{G_1\}~c~\{G_2\}$ by combining a ``local'' specification $\{L_1\}~c~\{L_2\}$ with a \emph{ramification entailment} $G_1 |- L_1 * (L_2--* G_2)$.  This entailment uses the ``magic wand'' operator $--*$ of separation logic\footnote{$--*$ is the adjunct of $*$, \emph{i.e.} $(P * Q |- R) <=> (P |- Q --* R)$.} to express a notion of ``state update'': replace $L_1$ with $L_2$ inside $G_1$ to reach $G_2$.  Essentially the ramification entailment ensures that the change in state specified locally fits properly into the global context.  In exchange for proving the ramification entailment, a verifier can use \infrulestyle{Ramify} at any time, \emph{i.e.} they need not worry about syntactically matching their assertions with the $*$ in the \infrulestyle{Frame} rule.

We are now ready to give a formal meaning to the ``localization'' pattern employed in Figure~\ref{fig:markgraph}.  When we write:
%\begin{minipage}{.25\textwidth}
\begin{lstlisting}
// $\label{code:prelocal}\{ G_1 \}$
// $\label{code:inlocal}\searrow \{ L_1 \}$
$\ramify(i)$      $c_1$; ... ; $c_n$;
// $\label{code:outlocal}\swarrow \{ L_2 \}$
// $\label{code:postlocal}\{ G_2 \}$
\end{lstlisting}
we mean apply the \infrulestyle{Ramify} rule with $G_1 |- L_1 * (L_2 --* G_2)$.
An advantage of this notation is crystal clarity on the predicates used in the ramification entailment.  For convenience, the optional $\ramify(i)$ specification can reference an equation or lemma number that solves the ramification entailment.  For example, in Figure \ref{fig:markgraph} line \ref{code:markram2} references Lemma \ref{lem:updategraphnode} whereas we omit the ramification entailment around line \ref{code:markram1} since the heap is unchanged.
If we wish to save a line or two we can compress \emph{e.g.} the line pairs \ref{code:prelocal}--\ref{code:inlocal} and \ref{code:outlocal}--\ref{code:postlocal}
to the single lines $\{ G_1 \} \searrow \{ L_1 \}$ and $\{ G_2 \} \swarrow \{ L_2 \}$ without sacrificing clarity.

Hobor and Villard pointed out that \infrulestyle{Ramify} implies \infrulestyle{Frame} (modulo the modified program variables issue we fix in \S\ref{sec:freevars}), meaning that our notation can clarify uses of \infrulestyle{Frame} as well.  This is particularly useful in multi-line contexts with nontrivial $F$, for which the current popular notation to express \infrulestyle{Frame} involves a liberal use of ``\ldots'', \emph{e.g.}:

\vspace{5pt}

\begin{minipage}{.2\textwidth}
Old notation:
\begin{lstlisting}
// $\{ P_1 * F_1 * F_2 * F_3 \}$
   $c_1$;
// $\{ P_2 * \ldots \}$
   $c_2$;
// $\{ P_3 * \ldots \}$
   $c_3$;
// $\{ P_4 * F_1 * F_2 * F_3 \}$
\end{lstlisting}
\end{minipage}
\begin{minipage}{.2\textwidth}
New notation:
\begin{lstlisting}
// $\{ P_1 * F_1 * F_2 * F_3 \} \searrow \{ P_1 \}$
      $c_1$;
//    $\{ P_2 \}$
      $c_2$;
//    $\{ P_3 \}$
      $c_3$;
// $\{ P_4 * F_1 * F_2 * F_3 \} \swarrow \{ P_4 \}$
\end{lstlisting}
\end{minipage}

The \infrulestyle{Ramify} rule is sound but interacts poorly with modified program variables (as in lines~\ref{code:markbeforetripleramify}--\ref{code:markaftertripleramify} of Figure~\ref{fig:markgraph}) {\color{magenta} and
localized existentials (as in lines~\ref{code:beforemarkl}--\ref{code:aftermarkl})}.  Both of these limitations are annoying enough in paper proofs and graduate to major headaches in mechanized ones.  Happily, we show how to overcome both limitations in \S\ref{sec:freevars} and \S\ref{sec:existentials}, respectively, by presenting new variants of \infrulestyle{Ramify}.  Our notation carries over without significant change: just use the new rules to enable the more general ramification entailments they permit.
%When in doubt the most general rule, \infrulestyle{Ramify-PQ} from \S\ref{sec:existentials}, implies all of the others.

%In \S\ref{sec:freevars} and \S\ref{sec:existentials} we present .  

\subsection{The program variable bugaboo}
\label{sec:freevars}

\infrulestyle{Frame}'s side condition ``$F \text{ ignores } \MV(c)$'' can be defined in two ways.
In the more traditional syntactic style, it means that $\FV(F) \cap \MV(c) = \emptyset$.
By ``syntactic style'' we mean that the side condition is written using a function $\FV(F)$ that takes an arbitrary formula and returns the set of free variables within that formula.  To define this $\FV(F)$ function
we need a fixed inductive \textbf{syntax} for formulas.  In contrast, in this paper we follow a ``semantic style'' in which formulas are not given a fixed syntax in advance but can be defined \textbf{semantically} on the fly using an appropriate model~\cite{appel:programlogics}.  In a semantic style, the side condition on the frame rule is defined as:
\[
\begin{array}{ll}
\sigma \stackrel{S}{\cong} \sigma' & \stackrel{\Delta}{=} ~~ \sigma \text{ and } \sigma' \text{ coincide everywhere except } S\\
P \text{ ignores } S & \stackrel{\Delta}{=} ~~ \forall \sigma, \sigma'.~ \sigma \stackrel{S}{\cong} \sigma' => \null \\
& \qquad ~~ (\sigma |= P) <=> (\sigma' |= P)
\end{array}
\]
That is, we consider two program states $\sigma$ and $\sigma'$ equivalent up to program variable set $S$ when they agree everywhere except for on the values of variables in $S$ (typically, a state $\sigma$ is a pair of a heap $h$ and program variables $\rho$).  A predicate $P$ is then stable with respect to $S$ when its truth is independent of all program variables in $S$.  %{\color{magenta} Notice both the syntactic and semantic styles use the $\MV(c)$ function defined via straightforward recursive case analysis on program syntax; programming languages typically do have a fixed syntactic structure.}

%{\color{magenta} Intro blah. lines~\ref{code:beforemarkl}--\ref{code:aftermarkl} of Figure~\ref{fig:markgraph}}

Now consider using ramification to verify this program:
\begin{lstlisting}
// $\{ \tx{x} = 5 /| A \}$
// $\searrow \{\tx{x} = 5 /| B \}$
      ...;
      x = x + 1;
      ...;
// $\swarrow \{\tx{x} = 6 /| C \}$
// $\{ \tx{x} = 6 /| D \}$
\end{lstlisting}
Suppose that the other (elided) lines of the program make localization desirable, even though it is overkill for a single assignment.  The key issue is that the program variable {\li{x}} appears in all four positions in the ramification entailment
\[
(\li{x} = 5 /| A) \vdash (\li{x} = 5 /| B) * \big((\li{x} = 6 /| C) --* (\li{x} = 6 /| D)\big)
\]
One problem is that $(\li{x} = 6 /| C) --* (\li{x} = 6 /| D)$ does \textbf{not} ignore the modified program variable \tx{x}, preventing us from applying the \infrulestyle{Ramify} rule.  Intuitively, the stability side condition on the \infrulestyle{Ramify} rule is a bit too strong since it prevents us from mentioning variables in the postconditions that \textbf{have} been modified by code $c$.

The obvious thing to try is to weaken the side condition in \infrulestyle{Ramify} to $\big(\FV(G_2) \cap \MV(c)\big) \subseteq \FV(L_2)$, the idea being that information about modified program variables mentioned in the local postcondition $L_2$ can be carried to the global postcondition $G_2$.  Unfortunately, this idea is unsound because \li{x} cannot simultaneously be both~5 and~6, \emph{i.e.} the above entailment is vacuous.  A better idea is: % the following :
\[
\infrule{Ramify-P (Program variables)}
{\{ L_1 \} ~ c ~ \{L_2 \} \\
 G_1 \vdash L_1 * \pguards{c}  (L_2 --* G_2)}
{\{ G_1 \} ~ c ~ \{ G_2 \}}{}
\]
The ramification entailment now incorporates a new (universal/boxy) modal operator $\pguards{c}$.  The intuitive meaning of $\pguards{c}$ is that program variables modified by command $c$ can change value inside its scope.    Note that it is vital that $L_2$ appears as the antecedent of a (spatial) implication since the change in program variables is universally quantified.  This means that if we want to say anything specific about modified program variables in the global postcondition $G_2$ then we had better say something about them in the local postcondition $L_2$.

Let us return to our earlier entailment:
\[
\begin{array}{l}
(\li{x} = 5 /| A) \vdash (\li{x} = 5 /| B) * \null \\
~~ \pguards{\li{...; x = x + 1; ...;}} \big((\li{x} = 6 /| C) --* (\li{x} = 6 /| D)\big)
\end{array}
\]
Since \li{x} is modified, its value can change from the first line, in which \li{x} must be 5, to the second, in which \li{x} must be 6.

Here is the definition of $\pguards{c}$, writing $\langle c \rangle$ for $\MV(c)$:
\[
%\begin{array}{lcl}
%\langle c \rangle & \stackrel{\Delta}{=} & \MV(c) \\
\sigma |= \pguards{c} P ~~ \stackrel{\Delta}{=} ~~ \forall \sigma'.~ (\sigma \stackrel{\langle c \rangle}{\cong} \sigma') => (\sigma' |= P)% ~~~~ \text{where $\mathsf{MV}(c)$ is $\MV(c)$}\\
%\end{array}
\]
In other words, $\pguards{c}$ is exactly the universal modal operator~$\Box$ over the relation that considers equivalent all states that differ only on program values modified by $c$.  Since $\stackrel{\langle c \rangle}{\cong}$ is an equivalence relation, $\pguards{c}$ forms an S5 modal logic.

Note that \infrulestyle{Ramify-P} has no free variable side condition, which is unnecessary because $\forall P.~ \pguards{c}P \text{ ignores } \MV(c)$.  However, in practice this side condition reappears because to actually prove a ramification entailment containing $\pguards{c}$ one typically applies the following \infrulestyle{Solve Ramify-P} rule:
\[
\infrule{Solve Ramify-P}
{G_1 |- L_1 * F \\
{\color{magenta} F |- L_2 --* G_2}}
{G_1 \vdash L_1 * \pguards{c}  (L_2 --* G_2)}{F \textrm{ ignores } \MV(c)} \qquad \qquad \qquad \qquad
\]
That is, we can handle the $\pguards{c}$ by breaking apart the single entailment into a pair.  Using two entailments allows modified program variables to change between the preconditions and postconditions.  To connect the pair, we must choose a suitable predicate $F$ that ignores modified variables in $c$. Finding a suitable $F$ and proving the associated entailments can be tricky in the abstract but in practice is guided by using a ``ramification library'' as given in \S\ref{sec:ramifylib}.

With \infrulestyle{Ramify-P} and \infrulestyle{Solve Ramify-P} we can prove the \infrulestyle{Frame} rule with its canonical side condition as follows:
\[
\infrule{}{\raisebox{1.4ex}{$\infrule{}{P * F |- P * F \\ F |- Q --* (Q * F)}
{\raisebox{-4pt}[0pt][0pt]{$P * F |- P * \pguards{c}\big(Q --* (Q * F)\big)$}}
{\hspace{-1.1ex}\raisebox{0.9ex}{$\begin{array}{c}F \text{ ignores} \\ \MV(c)\end{array}$}}$}
\\ \{P\}~c~\{Q\}}
{\{P * F\}~c~\{Q * F\}}
{}
\]
This justifies our point in \S\ref{sec:localizations} that our new localization notation can also be used for frames.
%Conversely, we can also prove \infrulestyle{Ramify-P} from \infrulestyle{Frame} and \infrulestyle{Consequence}:

\subsection{The existential ogre}
\label{sec:existentials}

We call the action in line 2 \emph{localize} and call the action in line 6 \emph{unlocalize}.

~\ref{code:beforemarkl}--\ref{code:aftermarkl}

Existential rule by Floyd~\cite{floydlogic} (1967!)

\[
\infrule{Existential extraction}
{\forall x.~ \big(\{ P \} ~ c ~ \{Q \}\big)}
{\{ \exists x. P \} ~ c ~ \{ \exists x.~ Q \}}{}
\]

\begin{lstlisting}
// $\{ P \}$
  $c$
// $\{ \exists x.~Q \}$
// $\{ Q \}$
\end{lstlisting}


But:
\begin{lstlisting}
// $\{ G_1 \}$
// $\searrow \{ L_1 \}$
      $c$
// $\swarrow \{ \exists x.~L_2 \}$
// $\{ \exists x.~G_2 \}$
// $\{ G_2 \}$
\end{lstlisting}

\Rule{RAM-P-FRAME }
{G \vdash L * \Box^{\llbracket c \rrbracket} (L' --* G') \\
F \text{ is stable w.r.t. } \MV(c) \\}
{G * F \vdash L * \Box^{\llbracket c \rrbracket} (L' --* G' * F) }

\Rule{RAM-P-SPLIT }
{G_1 \vdash L_1 * \Box^{\llbracket c \rrbracket} (L_1' --* G_1') \\
G_2 \vdash L_2 * \Box^{\llbracket c \rrbracket} (L_2' --* G_2') \\}
{G_1 * G_2 \vdash L_1 * L_2 * \Box^{\llbracket c \rrbracket} (L_1' * L_2' --* G_1' * G_2') }

\[\text{UNSOUND-RAM-Q-SPLIT}\]
\Rule{}
{G_1 \vdash L_1 * (\exists x, L_1' (x) --* \exists x, G_1'(x)) \\
G_2 \vdash L_2 * (\exists x, L_2' (x) --* \exists x, G_2'(x)) \\}
{G_1 * G_2 \vdash L_1 * L_2 * (\exists x, L_1'(x) * L_2'(x) --* \exists x, G_1'(x) * G_2'(x)) }


\[
\infrule{Ramify-Q}
{\{ L \} ~ c ~ \{\exists x.~ L' \} \\
 G \vdash L * \big(\forall x.~ (L' --* G')\big)}
{\{ G \} ~ c ~ \{ \exists x.~G' \}}{}
\]

\Rule{Ramification-PQ}
{\{ L \} c \{ \exists x, L' (x) \} \\
 G \vdash L * \Box^{\llbracket c \rrbracket} (\forall x, L' (x) --* G' (x)) \\}
{\{ G \} c \{ \exists x, G' (x)\}}


%Related work

\subsection{Soundness of our rules}
Figure~\ref{fig:rampqproofs}!

\begin{figure*}
Proof of \infrulestyle{Ramify-P} from \infrulestyle{Frame} and \infrulestyle{Consequence}:
\vspace{-3em}
\[
\begin{array}{c}
\infrule{}{
  G_1 |- L_1 * \pguards{c}(L_2 --* G_2) \\
  \infrule{}{\{L_1\}~c~\{L_2\}}
            {\{L_1 * \pguards{c}(L_2 --* G_2)\}~c~\{L_2 * \pguards{c}(L_2 --* G_2)\}}{(1)} \\
  \infrule{}{
            \infrule{}{\stackrel{\langle c \rangle}{\cong} \text{ is reflexive}}{\pguards{c}(L_2 --* G_2) |- L_2 --* G_2}{(2)}}
            {L_2 * \pguards{c}(L_2 --* G_2) |- G_2}{(3)}}
{\{G_1\}~c~\{G_2\}}
{} \\
[5pt]
(1)~ \forall P.~ \pguards{c}P \text{ ignores } \FV(c) \qquad (2)~ \text{Axiom T of modal logic} \qquad (3)~ --* \text{ is the adjunct of } *
\end{array}
\]

Proof of \infrulestyle{Ramify-PQ} from \infrulestyle{Ramify-P}:
\vspace{-4em}
\[
\begin{array}{c}
\infrule{}
{
  \{L_1\}~c~\{\exists x.~ L_2\} \hspace{-0.5em} \\
  \infrule{}
  {
    G_1 |- L_1 * \pguards{c}\big(\forall x.~ (L_2 --* G_2)\big) \hspace{-0.5em} \\
    \infrule{}{
      \infrule{}{
        \infrule{}{
          \vdots
        } {
          \forall x.~ (L_2 --* G_2) |- (\exists x.~ L_2) --* (\exists x.~ G_2)
        } {(1)}
      } {
        \pguards{c}\big(\forall x.~ (L_2 --* G_2)\big) |- \pguards{c}\big((\exists x.~ L_2) --* (\exists x.~ G_2)\big)
      } {(2)}
    } {
      L_1 * \pguards{c}\big(\forall x.~ (L_2 --* G_2)\big) |- L_1 * \pguards{c}\big((\exists x.~ L_2) --* (\exists x.~ G_2)\big)
    } {}
  } {
    G_1 |- L_1 * \pguards{c}\big((\exists x.~ L_2) --* (\exists x.~ G_2)\big)
  } {}
} {
  \{G_1\}~c~\{\exists x.~ G_2\}
} {}
\\
[5pt]
(1)~ \text{tautology using $(P * Q |- R) <=> (P |- Q --* R)$} \qquad (2)~ \text{reduction using modal axioms K and N} %\qquad (3)~ (P |- Q) => (P * F |- Q * F)
\end{array}
\]
\caption{Proofs of \infrulestyle{Ramify-P} and \infrulestyle{Ramify-PQ}}
\label{fig:rampqproofs}
\end{figure*}
