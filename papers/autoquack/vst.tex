\section{Ramification-P and Q}

\newcommand{\Rule}[3]{\[\text{#1}\frac{\begin{array}{c} #2 \end{array}}{#3}\]}
\newcommand{\MV}{\text{ModVar}}
\newcommand{\FV}{\text{FreeVar}}

\Rule{Frame  }
{\{ P \} c \{Q \} \\
  F \text{ is stable w.r.t. } \MV(c)\\}
 {\{P * F \} c \{ Q * F \}}

\Rule{Ramification   }
{\{ L \} c \{L' \} \\
 G \vdash L * (L' -* G') \\
 (L' -* G') \text{ is stable w.r.t. } \MV(c)\\}
{\{ G \} c \{ G' \}}

\Rule{Ramification-P }
{\{ L \} c \{L' \} \\
 G \vdash L * \Box^{\llbracket c \rrbracket} (L' -* G') \\}
{\{ G \} c \{ G' \}}

\Rule{Ramification-Q }
{\{ L \} c \{ \exists x, L' (x) \} \\
 G \vdash L * (\forall x, L' (x) -* G' (x)) \\
 \forall x, (L'(x) -* G'(x)) \text{ is stable w.r.t. } \MV(c)\\}
{\{ G \} c \{ \exists x, G' (x)\}}

\Rule{Ramification-PQ}
{\{ L \} c \{ \exists x, L' (x) \} \\
 G \vdash L * \Box^{\llbracket c \rrbracket} (\forall x, L' (x) -* G' (x)) \\}
{\{ G \} c \{ \exists x, G' (x)\}}

Separation logic has been mechanized by many projects CITE CITE CITE.
In many of them, like VST and Charge!, expressing the value of a local
variable (a variable stored in stack) is a pure fact rather than a
spatial fact. Because the side condition of ramification rule requires $(L' -* G')$ not
to be stable w.r.t. modified local variables in $c$\footnote{In previous papers, the side conditions of Frame rule and ramification rule are usually expressed as ``$\FV(F) \cap \MV(c) = \emptyset$'' and ``$\FV(L' -* G') \cap \MV(c) = \emptyset$''. The side conditions used in this paper are equivalent with typical ones if the semantic interpretation of $\FV$ is used. All the previous mentioned projects takes semantic interpretation instead of syntactical interpretation.}, it is almost impossible to apply ramification rule in any practical situations in these systems. In this paper, we present a pure-facts-related rule (we will call it ramification-P rule, or just P rule in the rest this paper) such that it is sound and practical in the most general setting of separation logics.

The primary ramification rule is essentially an application of frame rule using $(L' -* G')$ as frame.
Thus, the key point of handling pure facts is to find a legal frame even if $(L' -* G')$ is not stable w.r.t. $\MV(c)$. This frame is $\Box^{\llbracket c \rrbracket} (L' -* G')$ in ramification-P rule.
\begin{eqnarray*}
m \models \Box^R P &  \Leftrightarrow  & \forall m', \text{ if } m\xrightarrow{R}m' \text{ then } m' \models P \\
m \xrightarrow{\llbracket c \rrbracket} m' & \Leftrightarrow &   \text{$m$ and $m'$ coincide everywhere} \\
&& \text{except $\MV(c)$} \\
P \text{ is stable} &  \Leftrightarrow  & \forall m \ m',  \text{if $m$ and $m'$ coincide everywhere} \\
\text{w.r.t. $S$} && \text{except $S$, then $m \models P$ iff $m' \models P$}
\end{eqnarray*}

Here, $\Box$ represents the necessity modal operator. The formula $\Box^{\llbracket c \rrbracket} (L' -* G')$ says, it is true on a state $m$ if and only if for any state $m'$, if $m$ and $m'$
coincide everywhere except on the variables modified by $c$, then $(L' -* G')$ is true on $m'$. 

Based on the combination frame rule, consequence rule and three basic facts below, we can immediate prove ramification-P rule.
\begin{quotation}
(1) $\Box^{\llbracket c \rrbracket} (L' -* G')$ is stable w.r.t. $\MV(c).$\footnote{This can be proved directly from the definition of $\llbracket c \rrbracket$ and stability.}

(2) $G \vdash L * \Box^{\llbracket c \rrbracket} (L' -* G')$. (Assumption)

(3) $L' *  \Box^{\llbracket c \rrbracket (L' -* G')} \vdash G'$. \footnote{When $R$ is reflexive, T-Axiom of modal logic is sound, i.e. for any $P$, $\Box^R P \vdash P$. As $\llbracket c \rrbracket$ is reflexive, we know the fact that $\Box^{\llbracket c \rrbracket} (L' -* G') \vdash L' -* G'$, which is immediate followed by $L' *  \Box^{\llbracket c \rrbracket (L' -* G')} \vdash G'$.}
\end{quotation}








\section{Ramification based on VST}


VST is a correctness-certified tool to prove functional correctness of C programs CITE. All Hoare rules are proved sound and users can use them to build modularized proof. At the same time, users can have all the convenience offered by separation logic. For example, frame rule is already proved sound as well. VST is fully developed in Coq and it uses the C semantics offered by ComCert. CITE

AQUINAS, IS IT CORRECT TO USE PRESENT TENSE TO TALK ABOUT VST? SHALL I USE PAST TENSE?

In this work we present, we establish the soundness of primary ramification rule and pure-fact-related ramification rule based on frame rule. 	


MORE TO WRITE: divide pure facts into frame and local based on VST's canonical form. Based on localize/unlocalize, compared with frame rule, ramification rule have better use on VST's automatic symbolic execution system.





2.4. VST instance of \texttt{pSpatialGraph\_Graph\_Bi} and \texttt{sSpatialGraph\_Graph\_Bi} are constructed in "\texttt{spatial\_graph\_aligned\_bi\_VST.v}" and "\texttt{spatial\_graph\_unaligned\_bi\_VST.v}".

3. Embed ramification into VST.
3.1. Ramification rule are proved sound in VST.
3.2. A special ramification rule for VST's Sep-Local-Prop style pre/post condition is prove. The point is traditional ramification rule require the whole frame-like-wand-expression to be closed w.r.t. the modified variables. This special rule split closed and unclosed away.
3.3. Localize and unlocalize are defined.
3.3.1. Localize/unlocalize offer a user-friendly way of using ramification rule.
3.3.2. Unlocalize tactic need "Grab Existential Variables" afterwards. It is not nice.
3.3.3. Writing Ocaml plugin is one solution. But we need to develop for both mac and windows.
3.3.4. Or we can see whether Coq's next version offers more tactics for existential variables.
