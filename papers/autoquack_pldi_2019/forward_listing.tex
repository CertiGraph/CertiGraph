% for second branch
%$\left\{\!\!\!\begin{array}{l@{}} boo \end{array}\right\}$

\begin{figure}[t]
\vspace{-1ex}
  \begin{lstlisting}
void forward (value *from_start,
              value *from_limit,
              value **next,
              value *p,
              int depth) {
// $\left\{\!\!\!\begin{array}{l@{}} \p{gc\_graph}(\gamma) /| \p{fun\_info}(\m{f\_info}, \m{fi}) /| \p{thread\_info}(\m{t\_info}, \m{ti}) /| \null \\ \m{comp\_ext}(\gamma, \m{f\_info}, \m{t\_info}) /| \m{comp\_int}(\gamma, \m{from}, \m{to}, \m{t\_info}) /| \null \\ \m{comp\_p}(\tx{p}, \m{roots}, \gamma, \m{from}) /| \tx{from\_start} = \m{gen\_start}(\gamma, \m{from}) /|  \null \\ \tx{from\_limit} = \m{??} /| \tx{next} = \m{??} \end{array}\right\}$
// $\left\{\!\!\!\begin{array}{l@{}} \exists \m{v}, \m{n}.~ \tx{p} = \m{(v,n)} /| \m{vgen}(\m{v}) \neq \m{from} /| \null \\ \tx{\_p} = (\m{vert\_addr}(\gamma, v) + (\m{WO} * \m{n})) \end{array}\right\}$ 
  value * v;
// $\{ \m{ditto} \}$  
// $\searrow \{\p{vertex}(\gamma, \m{v}) \} $
// $ \{\exists \m{header},\m{fields}.~\m{v} |-> \m{header},\m{fields} /| \m{ipoi}(\m{fields}[n])\}$ 
  value va = *p; 
// 
// $\swarrow$
// $ \{\tx{va} = \m{field2val}(\m{fields}[n]) /| \m{viop}(\m{field2val}(\m{fields}[n]))\} $
// $ \{\m{field2val}(\m{fields}[n]) \in \m{int} \lor \m{field2val}(\m{fields}[n]) \in \m{ptr}\}$
// $\{ /| \m{fields}[n]) \in \m{Z} \lor \m{fields}[n]) \in \m{GCptr} \lor \m{fields}[n]) \in \m{edge} \}$
// $\{\m{fields}[n]) \in \m{edge} /| \exists \m{e}.~\m{field2val}(\m{e})\} /| \tx{va} = \m{field2val}(\m{fields}[n])$ // magic
// $\{\m{fields}[n]) \in \m{edge} /| \exists \m{e}.~\m{field2val}(\m{e})\} /| \tx{va} = \m{field2val}(\m{fields}[n])$ 
// $\{\exists \m{v'}.~ \m{v'} = \m{dst}(\gamma, \m{e}) /| \tx{va} = \m{vertex\_address}(\gamma, \m{v'}) \}$
// $\{\m{v'} = \m{dst}(\gamma, \m{e}) /| \tx{va} = \m{vertex\_address}(\gamma, \m{v'}) /| \m{Is\_block}(\tx{va}) \}$
  if(Is_block(va)) {
// $\{\m{v'} = \m{dst}(\gamma, \m{e}) /| \tx{va} = \m{vertex\_address}(\gamma, \m{v'}) /| \m{Is\_block}(\tx{va}) /| \}$
// $\{\exists \m{b}, \m{i}.~ \m{vertex\_address}(\gamma, \m{v'}) = \m{Vptr}(\m{b}, \m{i})\}$
    v = (value*)int_or_ptr_to_ptr(va);
// $\{\tx{v} = \m{Vptr}(\m{b}, \m{i})\}$
    if(Is_from(from_start, from_limit, v)) {
}
// $\searrow$
      header_t hd = Hd_val(v);
// $\swarrow$
      if(hd == 0) {
// $\searrow$
// $\searrow$
        *p = Field(v,0);
// $\swarrow$
// $\swarrow$
      } else {
        int i; int sz; value *new;
        sz = Wosize_hd(hd);
        new = *next+1;
        *next = new+sz;
        Hd_val(new) = hd;
        for(i = 0; i < sz; i++) {
          Field(new, i) = Field(v, i);
        }
        Hd_val(v) = 0;
        Field(v, 0) = ptr_to_int_or_ptr((void *)new);
// $\searrow$
        *p = ptr_to_int_or_ptr((void *)new);
// $\swarrow$
        if (depth>0)
        for (i=0; i<sz; i++)
          forward(from_start, from_limit, 
            next, &Field(new,i), depth-1);
      }
    }
  }
}
\end{lstlisting}

\vspace{-0.4em}
\caption{Clight code and proof sketch for forward}
\label{fig:forward}
\vspace{-1em}
\end{figure}