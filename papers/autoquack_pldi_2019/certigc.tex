In this section, we explain how we used our graph library
to verify a generational copying garbage collector for the 
CertiCoq compiler. The GC is our most complicated example,
and we will discuss some of its key proofs, but the larger
point here is that we completed this certification using 
exactly the framework and the principles we have discussed
thus far. {\color{magenta}We enjoyed significant code 
reuse from our prior certifications, and when we stated 
new lemmas for the GC, we filed them away at the appropriate
``layers'' so that they may be reused in the future.}

% The last line above is currently false.
% We cannot edit the code to make it 100% true, 
% but the plan is to incorporate GCGraph's special
% properties into a soundness condition that will be
% added atop a LiMaFin-type LabeledGraph.
% Having done that, I'll weaken the last line
% above to match the actual work.

\subsection{Background}
\label{sec:gcbackground}

% My goal here is to start with a broad overview
% and then work my way down to forward
% at the end of this subsection I want it to be pretty
% clear that the whole game is just a series of calls
% to forward.
% This will set us up nicely for the decorated proof of
% forward in the next subsection.

The CertiCoq Project compiles Gallina code into CompCert 
C light, and then uses CompCert to compile C light
into assembly. In order to support Gallina's presumption of
infinite heap memory, CertiCoq provides garbage collection at
the C light level. Their generational copying garbage 
collector is written in C light, and is realistic, 
supporting variable-sized words, 12 generations... 
% Leaving this slot open for the time being, so
% we can highlight those features that we will discuss 
% the most in the technical part later.
Since CertiCoq aims to be end-to-end certified, the GC 
also needs certification.

The GC's client program, also called the mutator, controls
an array of arguments that it cares about. 
% Looking for better term than "cares about"
These arguments may point at memory blocks 
in the heap, and, recursively, the items in those
memory blocks may point at other blocks in the heap. 
By maintaining direct and indirect links to
blocks via this internal ``web of care'', 
% I'm a little iffy about introducing this additional
% analogy, but then again I don't want to introduce
% the analogy of a graph right away. That could be seen
% as a huge conceptual leap, and a skipped step. 
the mutator indicates that it 
cares about those blocks, and reserves the right to 
access them for reading or writing. 
% Maybe add a line about how the mutator can "drop"
% a block, thus showing that it won't need it anymore?

When the mutator runs out of heap space, 
it calls the garbage collector to free up memory. 
The GC is allowed to modify the heap as
it sees fit, with the condition that it not damage the 
mutator's web of care. By this we mean that the same items 
should be accessible from the mutator's arguments
array before and after the collection, and they 
should be reached from the arguments array by 
following similar links as before. 
Other features of the original web, such as where 
items were situated in the heap, may be changed. 
In SECTION, we will explain how we abstracted this
web into a mathematical graph, where preserving the 
web of care is analogous to showing graph isomorphism.

``We thus say that the arguments array is owned by the 
mutator, but the heap is owned by the GC.''

\subsection{Structure of the Program}
\label{sec:gcstructure}
% maybe a diagram showing how everything calls forward? 
% I sketched one before, can show you sometime.
Ours is a generational copying garbage collector, which
means that it leans on the empirical observation that
new blocks often need to be collected soon after their
allocation, while blocks that survive this initial
culling tend to live for much longer.
% Hm, it would take about another 100 words to explain 
% this fully. I'm wondering if we can elide it, 
% treating the above as adequate revision, and assuming 
% they know the rest of the story.

The mutator only ever allocates new memory in the first, 
smallest generation of heap. This generation is thus 
called the nursery. If it finds that the nursery is full, 
the mutator calls the garbage collector to free up space.
The main GC function triggers the collection of the nursery
into the second generation, which is twice in size. These generations
are called the \emph{from} and \emph{to} generations respectively.
To trigger a collection means to examine the elements 
in \emph{from}, see if they are accessible from the mutator's
args array either directly or indirectly, and, if they are, 
copy them over to \emph{to}. This copying is achieved over a few steps, 
and we will examine these shortly, but the larger picture is that 
everything of import in \emph{from} gets copied to \emph{to}, 
and so \emph{from} can safely be reset. 

An important subtlety here is that we enjoyed a 
guarantee that \emph{to} had enough room to accept 
\emph{from}'s items. In the (empirically improbable) worst case, 
\emph{all} of \emph{from}'s data was copied over to \emph{to}, 
so \emph{to} could not have been more than 
half full. We relied on this guarantee before this collection, 
and we must ensure we will enjoy it the next time a collection 
is required. So, in case the collection of the nursery caused
the second generation to become more than half full, we trigger
a collection of the second generation to the third. This makes 
both the first and second generations empty, thus giving us our 
guarantee trivially. It should be 
clear to see that this may also trigger further collections in 
a cascade effect. Once this cascade (if any) is over, we
return control to the mutator, which goes ahead with 
the allocation that it was trying to perform in the nursery.

Armed with an understanding of how the overall collection 
works via two-generational collections, we move one 
level deeper and examine how we identify and 
copy those items in a \emph{from} generation that are reachable
from the args array to the \emph{to} generation.

% 150 or so words that explain forward_roots and do_scan.
% End goal is to convince them that everything relies on forward, 
% and forward is all that remains to be explained.

We start at the mutator-owned args array, whose elements
are either data, or pointers that point at blocks in the 
heap. We do not touch the data or the pointers that point
anywhere but the \emph{from} generation. 
For each pointer that points into \emph{from}, we copy its
target block to \emph{to}, simply adding it in its entirety 
after \emph{to}'s last-used spot, which is called \emph{next}. 
% need better word than "spot" above
% should I mention the distinguished pointer that points at the copy?

This operation only takes care of the blocks that 
the args array was pointing at directly, so we still have work
to do. The only way to get to an indirect 
block is via one of the direct blocks, and, conveniently, we have
just finished copying the direct blocks into a neat contiguous
array. We start at the old \emph{next} in \emph{to}
and work our way through the freshly copied blocks, performing
the same actions as before: ignoring data and pointers to 
places other than \emph{from}, and copying over any objects in
\emph{from} that are pointed at from within \emph{to}. In
the \emph{to} generation, these newly copied blocks 
simply get stacked atop our first batch of copied blocks. 
% need better phrasing above
Of course, the second batch of copied blocks may still
have pointers into \emph{from}: indeed, there is no limit to the 
``depth'' of the web of care. However, thanks to our systematic
copying strategy, it is very easy to take care of indirect
blocks at any depth. We simply keep scanning ``upwards'' in 
\emph{to}, copying over blocks from \emph{from} as necessary, 
until the scan reaches the... blah. 
% a little hard to phrase this last bit...
This completes a collection 
from \emph{from} to \emph{to}, copying all blocks that lived
in \emph{from} and were of interest to the mutator. 
\emph{from} may now be reset.

A good question at this juncture is why this rather selective scan 
of the args array and the heap is good enough to collect \emph{from}. 
We definitely collected every direct block by scanning the args array,
but what of the indirect blocks? Couldn't there be valid indirect links
either from the portion of \emph{to} below \emph{next}, 
or from other generations altogether? 

Both of these turn out to be impossible because the mutator
is a purely functional language. The heap is chronologically
faithful, in that higher-indexed generations host
objects that were allocated earlier. Because
of the immutability of objects in a purely functional language, 
it is impossible for objects to point ``backwards'' to 
a younger generation, as the older object would not have
had known about the younger during its allocation, and could not 
have been modified after its allocation. The generations 
younger than \emph{from} can point into \emph{from} during 
normal mutator activity, but this is
impossible at the time of collection 
because \emph{from} is only ever collected either if it is
the nursery or if a cascade effect has caused all generations younger
than it to be collected and reset. 
``In fact, the only time we ever see backwards pointers
is when we create (and quickly fix) them during garbage collection, 
as described earlier.''

\subsection{Forward}
\label{sec:gcforward}
The garbage collector's main workhorse is the function \emph{forward}.
Whenever we have mentioned any kind of copying in the preceeding 
discussion, we have always meant a call to \emph{forward}. 
Given a pointer, it checks that the pointer's target is a block
in the \emph{from} generation, and, if so, 
makes a copy of that block in the \emph{to} generation. The function 
is robust and versatile, and gets called in a variety of different 
situations... 

Figure (blah) shows a decorated proof of the forward function.
The function's behavior is subtly different depending on 
whether the the pointer $p$ lives in the arguments array or in the 
heap itself. The difference lies in lines blah and blah, where 
we wish to update $p$ to point to the new forwarded block. 
When $p$ lives in the arguments array, this update is easy to 
reason about since $p$ is fundamentally $\bigstar$-separated from our heap. 
When $p$ is itself in the heap, this update itself constitutues a
write to the heap. In the decorated proof, we show the second 
case. To this end, we assume in line (blah) that p is (dododo). 

\input{forward_listing.tex}

\subsection{Issues}
\label{sec:gccsemantics}

\paragraph{Pointer Subtraction.}
{\color{blue}Hmm I'm wondering if we should really be mentioning this,
strapped as we are for space. Anyway, will steal off your emails.}
\input{boundary.tex}

\paragraph{Double-Bounded Pointer Comparisons}







