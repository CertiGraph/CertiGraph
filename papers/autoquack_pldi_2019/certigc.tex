In this section, we explain how we used our graph library
to verify a generational copying garbage collector for the 
CertiCoq compiler. The GC is our most complicated example,
and we will discuss some of its key proofs, but the larger
point here is that we completed this certification using 
exactly the framework and the principles we have discussed
thus far. {\color{magenta}We enjoyed significant code 
reuse from our prior certifications, and when we stated 
new lemmas for the GC, we filed them away at the appropriate
``layers'' so that they may be reused in the future.}

\subsection{Background}
\label{sec:gcbackground}
The CertiCoq Project compiles Gallina code to CompCert 
C light, and then trusts CompCert to carry the compilation 
through to assembly. In order to support Gallina's presumption of
infinite heap memory, CertiCoq provides garbage collection at
the C light level. Accordingly, they presented us with a 
generational copying garbage collector written in C light. 
The GC, which is in the spirit of the OCaml Garbage Collector,
is realistic, supporting variable-sized words, 12 generations... 

The GC's client program, also called the mutator, controls
an array of arguments that it cares about. These arguments may
point at memory blocks in the heap; those blocks, in turn, 
may point at other blocks in the heap, and so on. By 
maintaining links to certain blocks in this way, the mutator 
indicates that it cares about those blocks. When the mutator
runs out of heap space, it calls the garbage collector 
to free up memory. The GC is allowed to modify the heap as
it sees fit, provided... 

A call to the garbage collector is actually just a series of 
calls between generations...

{\color{blue}Wondering about the level of detail we want to go
into with the above to paragraphs.}

\subsection{Forward}
\label{sec:gcforward}
The Garbage Collector's main workhorse is the function \emph{forward}.
Given a pointer to a block that is in the \emph{from} generation, 
it makes a copy of that block in the \emph{to} generation.
{\color{blue}Maybe at this point we could dedicate one or 
two sentences to explaining that the whole dang opera is really just 
calls to \emph{forward}.}

Figure (blah) shows a decorated proof of the forward function.
The function's behavior is subtly different depending on 
whether the the pointer $p$ lives in the arguments array or in the 
heap itself. The difference lies in lines blah and blah, where 
we wish to update $p$ to point to the new forwarded block. 
When $p$ lives in the arguments array, this update is easy to 
reason about since $p$ is fundamentally $\bigstar$-separated from our heap. 
When $p$ is itself in the heap, this update itself constitutues a
write to the heap. In the decorated proof, we show the second 
case. To this end, we assume in line (blah) that p is (dododo). 

\input{forward_listing.tex}

\subsection{Issues}
\label{sec:gccsemantics}

\paragraph{Pointer Subtraction.}
{\color{blue}Hmm I'm wondering if we should really be mentioning this,
strapped as we are for space. Anyway, will steal off your emails.}
\input{boundary.tex}

\paragraph{Double-Bounded Pointer Comparisons}







