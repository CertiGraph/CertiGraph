GOAL

The Verified Software Toolchain (VST) is a series of machine-checked modules written in Coq whose focus is reasoning about C programs~\cite{appel:programlogics}, especially those programs that can be compiled with the CompCert compiler~\cite{leroy:compcert}.  One of VST's modules, Floyd, is a separation-logic based engine to help users
verify concrete programs.  The modules interlock so there are no ``gaps'' in the end-to-end certified results; accordingly all of the rules employed by Floyd have been proved sound with respect to the underlying semantics used by CompCert.  Floyd is written in a combination of Ltac and Gallina and is designed to help users verify the full functional correctness of their programs.  Although Floyd devotes considerable effort to make this task simpler, it prefers expressibility and completeness to more automated tools like HIP/SLEEK.

HIP/SLEEK is a toolset for verifying programs using separation logic~\cite{chin:hipsleek}.  As compared to VST, H/S has a heavier focus on automation: for example, users need only specify loop invariants and the pre/postconditions of methods, rather than describing each program point.  H/S has two interlocking components.  HIP applies Hoare rules using forward reasoning to verify programs, \emph{i.e.} each entailment is of the form $P |- Q * R$, where the heap from the antecedent~$P$ is matched with the consequent $Q$ and a frame/residue $R$. To check these separation logic entailments and calculate~$R$, HIP calls SLEEK.  SLEEK handles spatial operators such as~$*$ and $|->$ before handing any remaining pure entailments to a variety of external solvers such as Z3.  One of H/S's distinguishing features is support for user-defined recursive predicates.  HIP/SLEEK has been used to verify programs manipulating data structures like lists, arrays, and trees.

\subsection{Marking a graph in VST}

\input{mark_listing.tex}

In Figure~\ref{fig:markgraph} we put the code and proof sketch of the classic \li{mark} algorithm that visits and colors every reachable node in a heap-represented graph.  The \li{mark} algorithm is good to start with because it is complex enough to require some care to verify while being simple enough that the invariants are straightforward.  In \S\ref{sec:application} we will discuss more complex examples that \emph{e.g.} add/change/remove edges and/or vertices.

The code in Figure~\ref{fig:markgraph} is written in Clight~\cite{blazy:clight}, an input language to the CompCert certified compiler~\cite{leroy:compcert}, which compiles our code exactly as written.
The paper-format verification sketch for \li{mark} in Figure~\ref{fig:markgraph} is extracted from
a ``Floyd'' proof in VST, with only minor cleanup to aid the presentation.
Accordingly, there is an unbroken certified chain from our specification of \li{mark} all the way to the assembly code.  In \S\ref{sec:hipsleek} we use HIP/SLEEK~\cite{chin:hipsleek} to verify a Java version of \li{mark}; the program invariants generated by HIP/SLEEK are slightly different due to HIP/SLEEK's heavier automation.
% but the overall structure is the same.

The specification we certify (lines \ref{code:markstart} and \ref{code:markend}) is
\[
\{\p{graph}(\li{x},\gamma)\}~\li{mark(x)}~\{\exists \gamma'.~ \p{graph}(\li{x},\gamma') /| \m{mark}(\gamma, \li{x}, \gamma')\}
\]
The specification is for full functional correctness, stated using \emph{mathematical} graphs~$\gamma$; until \S\ref{sec:mathgraph} consider $\gamma$ to be a function that maps a vertex $v \in V$ to triples $(m,l,r)$, where $m$ is a ``mark'' bit (0 or 1) and $\{l,r\} \subseteq V \uplus \{0\}$ are the neighbors of $v$.
The \emph{spatial} \p{graph} predicate describes how the mathematical graph $\gamma$ is implemented in the heap.  Until~\S\ref{sec:spacegraph} it is enough to know that \p{graph} satisfies the fold/unfold relationship in
equation~\eqref{eqn:bigraphintrofoldunfold}, located just under the code in Figure~\ref{fig:markgraph}.

This fold/unfold relationship deserves attention.
First, as we explain in~\S\ref{sec:fixpointfail}, it is probably a mistake to write~\eqref{eqn:bigraphintrofoldunfold} as a definition using $\stackrel{\Delta}{=}$ rather than as a biimplication using $<=>$.  Second, \eqref{eqn:bigraphintrofoldunfold} uses the ``overlapping conjunction'' $\ocon$ of separation logic; informally $P ** Q$ means that $P$ and $Q$ may overlap in the heap (\emph{e.g.}, nodes in the left subgraph can also be in the right subgraph or even be the root $x$).  The presence of the unspecified sharing indicated by the $\ocon$ connective is exactly why graph-manipulating algorithms are so hard to verify (\emph{e.g.}, it is hard to apply the \infrulestyle{Frame} rule).  The standard semantics of the separation logic connectives used in this paper are in Figure~\ref{fig:seplogsem}.
Third, \eqref{eqn:bigraphintrofoldunfold} illustrates how industrial-strength settings complicate verification.  Lines~\mbox{\ref{code:nodedefstart}--\ref{code:nodedefend}} define the data type \li{Node} used by \li{mark}.  The \li{_Alignas($n$)} directives tell CompCert to align fields on $n$-byte boundaries.  As explained in~\S\ref{sec:goodgraph}, this alignment is necessary in C-like memory models to prove fold-unfold \eqref{eqn:bigraphintrofoldunfold}, which is why \eqref{eqn:bigraphintrofoldunfold} includes an alignment restriction $x~\mathsf{mod}~16 = 0$ and an existentially-quantified ``blank'' second field for the root $x \mapsto m,-,l,r$.
%{\color{magenta}(In our Floyd proofs the alignment restriction and blank second field are nicely hidden ``behind the scenes''.)}

Notice that the postcondition of \li{mark} is specified \emph{relationally}, \emph{i.e.} $\{\exists \gamma'.~ \p{graph}(\li{x},\gamma') /| \m{mark}(\gamma, \li{x}, \gamma')\}$ instead of \emph{functionally}, \emph{i.e.} $\{\p{graph}\big(\li{x},\m{mark}(\gamma, \li{x})\big)\}$. In the first case $\m{mark}$ is a relation that specifies that~$\gamma'$ is the result of correctly marking~$\gamma$ from~\li{x}, whereas in the second $\m{mark}$ is a function that \textbf{computes} the result of marking~$\gamma$ from~\li{x}. For both theoretical and practical reasons a relational approach is better.
Theoretically, relations are preferable because they are more general.  For example, relations allow ``inputs'' to have no ``outputs'' (\emph{i.e.} be partial) or alternatively have many outputs (\emph{i.e.} be nondeterministic).  Our graph \li{copy} algorithm is specified nondeterministically to avoid specifying how \li{malloc} allocates fresh blocks of memory.  Relations are also preferable to functions because they are more compositional.
We take advantage of compositionality by using $\m{mark}(\gamma,x,\gamma') /| \ldots$ to specify both our ``spanning tree'' and ``graph copy'' algorithms in~\S\ref{sec:application}, which also mark nodes while carrying out their primary task.

\begin{figure}
\[
\begin{array}{lcl}
\sigma |= P * Q & \defeq & \exists \sigma_1, \sigma_2.~ \sigma_1 \oplus \sigma_2 = \sigma /| \null \\ && ~~ (\sigma_1 |= P) /| (\sigma_2 |= 2)\\
\sigma |= P ** Q & \defeq & \exists \sigma_1, \sigma_2, \sigma_3.~ \sigma_1 \oplus \sigma_2 \oplus \sigma_3 = \sigma /| \null \\ && ~~ (\sigma_1 \oplus \sigma_2 |= P) /| (\sigma_2 \oplus \sigma_3 |= Q) \\
\sigma |= P --* Q & \defeq & \forall \sigma_1, \sigma_2.~ \sigma_1 \oplus \sigma = \sigma_2 /| \null \\ && ~~
(\sigma_1 |= P) => (\sigma_2 |= Q) \\
\sigma |= P --o Q & \defeq & \exists \sigma_1, \sigma_2.~ \sigma_1 \oplus \sigma = \sigma_2 /| \null \\ && ~~
(\sigma_1 |= P) /| (\sigma_2 |= Q)
\end{array}
\]
\vspace{-2ex}
\caption{Separation logic connectives; $\oplus$ is the join operation on states, usually some kind of disjoint union on heaps}
\label{fig:seplogsem}
\vspace{-2ex}
\end{figure}

Practically, it is painful to define computational functions over graphs in a proof assistant like Coq, and portions of this pain are overkill.  For example, Coq requires that all functions terminate, a nontrivial proof obligation over cyclic structures like graphs, but our verification of \li{mark} is only for partial correctness.  Defining relations is much easier because \emph{e.g.} one can use quantifiers and does not have to prove termination.
The $\m{mark}$ and $\m{mark1}$ relations we use are defined straightforwardly at the bottom of Figure~\ref{fig:markgraph}.

Turning to the body of the verification (lines~\ref{code:inmark}--\ref{code:outmark}), readers may already have noticed our new notation: blocks of proof sketch bracketed by the symbols $\searrow$ and $\swarrow$, such as lines~\ref{code:beforerootmark}--\ref{code:afterrootmark}.  We call a bracketed set of lines like this a ``localization block''; localization blocks were inspired by our new \li{localize} $\searrow$ and \li{unlocalize} $\swarrow$ tactics in Floyd (\S\ref{sec:vst}).
The intuitive idea is that we zoom in from a larger ``global'' context to a smaller ``local'' one.  After verifying some commands locally to arrive at a local postcondition, we zoom back out to the global context.  Although we do not do so in Figure~\ref{fig:markgraph}, localization blocks can safely nest.

In lines~\ref{code:beforerootmark}--\ref{code:afterrootmark}, imagine unfolding the \p{graph} predicate in line~\ref{code:globalbeforerootmark} using equation \eqref{eqn:bigraphintrofoldunfold} and then zooming in to the root node \li{x} for lines~\ref{code:beforerootmark}--\ref{code:afterrootmark}, before zooming back out in line~\ref{code:globalafterrootmark}.

To define localization blocks formally we need to first understand the \infrulestyle{Frame} and \infrulestyle{Ramify} rules.

\subsection{Frames and ramifications are localizations}
\label{sec:localizations}
The key rule of separation logic is \infrulestyle{Frame}~\cite{rey02}:
\[
\infrule{Frame}
{\{ P \} ~ c ~ \{Q \}}
{\{P * F \} ~ c ~ \{ Q * F \}}
{\begin{array}{c}F \textrm{ ignores } \MV(c) \end{array}} \qquad \qquad
\]
The reason \infrulestyle{Frame} is so important is because it enables local verifications.  That is, a verifier can focus on the portions of the heap that are relevant to command $c$ and ``frame away'' the rest.  The side condition ``$F \textrm{ ignores } \MV(c)$'' relates to modified program variables and will be discussed in \S\ref{sec:freevars}.

Hobor and Villard observed that \infrulestyle{Frame} is bit rigid because it forces verifiers to split program assertions into syntactically $*$-separated parts~\cite{hobor:ramification}.  This rigidity is particularly unpleasant when verifying programs that manipulate data structures with intrinsic unspecified sharing such as DAGs and graphs.  Hobor and Villard proposed the \infrulestyle{Ramify} rule to circumvent this rigidity:
\[
\infrule{Ramify}
{\{L_1\} ~ c ~ \{L_2\} \\ G_1 |- L_1 * (L_2--* G_2)}
{\{G_1\} ~ c ~ \{G_2\}}
{\begin{array}{c}(L_2 --* G_2) \\ \textrm{ignores} \\ \MV(c) \end{array}} \qquad \qquad \qquad
%{$\begin{array}{l}\m{fv}(Q --* R') \cap \null \\ \m{modif}(c) = \emptyset\end{array}$} \qquad \qquad \qquad
\]
That is, we can verify a ``global'' specification $\{G_1\}~c~\{G_2\}$ by combining a ``local'' specification $\{L_1\}~c~\{L_2\}$ with a \emph{ramification entailment} $G_1 |- L_1 * (L_2--* G_2)$.  This entailment uses the ``magic wand'' operator $--*$ of separation logic\footnote{$--*$ is the adjunct of $*$, \emph{i.e.} $(P * Q |- R) <=> (P |- Q --* R)$.} to express a notion of ``substate update'': inside $G_1$ replace $L_1$ with $L_2$ to reach $G_2$.  Essentially the ramification entailment ensures that the change in state specified locally fits properly into the global context.  In exchange for proving the ramification entailment, a verifier can use \infrulestyle{Ramify} at any time, \emph{i.e.} they need not worry about syntactically matching their assertions with the $*$ in the \infrulestyle{Frame} rule.  Although the ramification entailments can appear difficult, Hobor and Villard observed that in many practical cases they can be handled easily using a ``ramification library''.

We are now ready to give a formal meaning to the ``localization'' pattern employed in Figure~\ref{fig:markgraph}.  When we write:
\begin{lstlisting}
// $\label{code:prelocal}\{ G_1 \}$
// $\label{code:inlocal}\searrow \{ L_1 \}$
$\ramify(i)$      $c_1$; ... ; $c_n$;
// $\label{code:outlocal}\swarrow \{ L_2 \}$
// $\label{code:postlocal}\{ G_2 \}$
\end{lstlisting}
we mean apply \infrulestyle{Ramify} with $G_1 |- L_1 * (L_2 --* G_2)$.
An advantage of this notation is crystal clarity on the predicates used in the ramification entailment.  For convenience, the optional $\ramify(i)$ specification can reference an equation or lemma number that solves the ramification entailment.  For example, in Figure \ref{fig:markgraph} line \ref{code:markram2} references Equation \eqref{lem:updategraphnode} whereas we omit $\ramify$ around line \ref{code:markram1} since the heap is unchanged and so the entailment is straightforward. If we wish to save vertical space we can compress the line pairs \ref{code:prelocal}--\ref{code:inlocal} and \ref{code:outlocal}--\ref{code:postlocal}
to the single lines $\{ G_1 \} \searrow \{ L_1 \}$ and $\{ G_2 \} \swarrow \{ L_2 \}$ without sacrificing clarity.

Hobor and Villard pointed out that \infrulestyle{Ramify} implies \infrulestyle{Frame} (modulo the modified program variables issue we fix in \S\ref{sec:freevars}), meaning that our notation can clarify uses of \infrulestyle{Frame} as well.  This is particularly useful in multi-line contexts with nontrivial $F$, for which the current popular notation to express \infrulestyle{Frame} involves a liberal use of ``\ldots'', \emph{e.g.}:

\vspace{5pt}

\begin{minipage}{.19\textwidth}
Old notation:
\begin{lstlisting}
// $\{ P_1 * F_1 * F_2 * F_3 \}$
   $c_1$;
// $\{ P_2 * \ldots \}$
   $c_2$;
// $\{ P_3 * \ldots \}$
   $c_3$;
// $\{ P_4 * F_1 * F_2 * F_3 \}$
\end{lstlisting}
\end{minipage} \vline ~~~
\begin{minipage}{.2\textwidth}
New notation:
\begin{lstlisting}[numbers=none]
// $\{ P_1 * F_1 * F_2 * F_3 \} \searrow \{ P_1 \}$
      $c_1$;
//    $\{ P_2 \}$
      $c_2$;
//    $\{ P_3 \}$
      $c_3$;
// $\{ P_4 * F_1 * F_2 * F_3 \} \swarrow \{ P_4 \}$
\end{lstlisting}
\end{minipage}

\subsection{Verifying \li{mark} in HIP/SLEEK}
\label{sec:hipsleek} % CHECK THIS!
\label{sec:hipsleekmark}

\begin{figure}[t]
\lstset{otherkeywords={data,relation,rlemma,abstract,axiom,self,null,or}}
  \begin{lstlisting}
$\label{code:hipdatanode}$data node { int val; node left; node right; }

$\label{code:hipstartrelation}$relation lookup(abstract G, node x,
  int d, node l, node r).
$\label{code:hipmark1relation}$relation update(abstract G, node x, int d,
  abstract G1).
$\label{code:hipmarkrelation}$relation mark(abstract G, node x, abstract G1).
relation
  subset_reach(abstract G, node x, abstract G1).
relation
$\label{code:hipendrelation}$ eq_notreach(abstract G, node x, abstract G1).

$\label{code:hipaxiom}$axiom lookup(G,x,1,l,r) ==> mark(G,x,G).
$\label{code:hipmarkramconnect}$axiom mark(G,x,G1) & lookup(G,y,v,l,r) ==>
  subset_reach(G,x,G1) & eq_notreach(G,x,G1) &
$\label{code:hipmarkramconnectend}$  lookup(G1,y,_,l,r).
// ... other $\color{red!80!black}\tx{axioms elided ...}$

$\label{code:hipbegingraphdef}$graph<G> == self = null or
 self::node<v,l,r> U* l::graph<G> U* r::graph<G>
$\label{code:hipendgraphdef}$ & lookup(G,self,v,l,r);

$\label{code:hipbeginlemma}$rlemma "subgraphupdate_l" l::graph<G1> *
 (l::graph<G> --@ (x::node<v,l,r> U*
 (l::graph<G> U* r::graph<G>))) &
 subset_reach(G,l,G1) & eq_notreach(G,l,G1)
 & lookup(G,x,v,l,r) & lookup(G1,x,v1,l,r)
  -> x::node<v1,l,r> U*
$\label{code:hipendlemma}$   (l::graph<G1> U* r::graph<G1>);
// ... other ramification lemmas elided ...

void mark(node x)
requires x::graph<G> $\label{code:hipmarkstart}$
ensures x::graph<G1> & mark(G,x,G1); { $\label{code:hipmarkend}$
  node l, r;
  if (x == null) return;
  else {
    if (x.val == 1) return; $\label{ifcondmark}$
    l = x.left;
    r = x.right;
    x.val = 1;
    mark(l);$\label{beforemarkleft}$
    mark(r);
} } $\label{code:hipmarkstop}$
\end{lstlisting}
%% \vspace{-8pt}
\caption{Bigraph marking in HIP/SLEEK}
\label{fig:hipmarkgraph}
\lstset{deletekeywords={data,relation,rlemma,abstract,axiom,self,null,or}}
\end{figure}

Figure~\ref{fig:hipmarkgraph} gives most of the HIP/SLEEK file used to verify \li{mark} (we have elided about 15 lines to save space).  We specify the pre- and postcondition of \li{mark} in line~\ref{code:hipmarkstart} and~\ref{code:hipmarkend}) respectively; notice that this is the same specification we verified in VST in Figure~\ref{fig:markgraph}.  It is quite unusual for H/S to verify the full functional correctness of an algorithm since its focus on heavier automation tends to trade off proving very exact specifications (\emph{e.g.} H/S proofs about lists usually treat their values as multisets instead of sequences).  We do not give H/S any ``hints'' at intermediate program points.

Line~\ref{code:hipdatanode} defines the recursive data structure \li{node} and lines~\ref{code:hipbegingraphdef}--\ref{code:hipendgraphdef} use H/S's normal user-defined recursive predicate feature to define the \li{graph} predicate.
H/S uses the keyword \li{self} to refer to the object being defined; in other words H/S's definition is very close to the fold/unfold relationship given as equation~\eqref{eqn:bigraphintrofoldunfold} in Figure~\ref{fig:markgraph} and we can justify its soundness as in \S\ref{sec:goodgraph}.  H/S uses the \li{::} operator for $|->$ and to provide the root pointer for a recursive predicate, \li{U*} for $**$ and automatically quantifies free variables existentially.  H/S does not need alignment restrictions because it enjoys a Java-like memory model with objects and fields: \emph{i.e.} it is not possible to have a pointer pointing into the ``middle'' of a record.  The last line of the \li{graph} predicate definition~(\ref{code:hipendgraphdef}) includes the \li{lookup} abstract relation.  In Figure~\ref{fig:markgraph}, this would be written $\gamma(\li{self})= (v,l,r)$.

To implement ramifications in HIP/SLEEK we extended its lemma system~\cite{NguyenC08}.
Normal lemmas in H/S are user defined, automatically checked, and automatically
applied in program verifications.  In contrast, our new lemmas are still user defined and still automatically applied in program verifications, but \textbf{not} automatically checked, so we call them \emph{externally verified lemmas}; their key advantage is that they can be much more complex than the lemmas H/S can check automatically.

The first step to adding such lemmas is to add a notion of abstract relations; the relations used by the \li{mark} verification are given in lines~\ref{code:hipstartrelation}--\ref{code:hipendrelation}.  We have already met \li{lookup}; lines~\ref{code:hipmark1relation} and~\ref{code:hipmarkrelation} are how H/S models \m{mark1} and \m{mark}, respectively.  Users do not provide any definitions for these relations, but we do give H/S some axioms for how they behave: \emph{e.g.} line~\ref{code:hipaxiom} tells H/S that if the root of a graph is marked then we can consider the whole graph marked.  This axiom is used on line~\ref{ifcondmark} to safely \li{$\tx{return}$} once we encounter an already-marked \li{node}.  Users also provide spatial ramification rules as in lines~\ref{code:hipbeginlemma}--\ref{code:hipendlemma}.  %H/S only supports first order quantification so these are a little unpleasant to state, being essentially very concrete versions of the ramification library~(\S\ref{sec:ramifylib}).

\begin{figure}[t]
\lstset{deletekeywords={union},otherkeywords={Module,Type,Prop,Parameter,Axiom,End,forall},numbers=none}
  \begin{lstlisting}
Module Type Mgraphmark.
 ...
 Parameter G : Type.
 Parameter node : Type.
 Parameter graph : node -> G -> formula.
 Parameter mark : G -> node -> G -> formula.
 ...
 Axiom axiom_3 : forall l r x G,
   valid (imp (lookup G x true l r) (mark G x G)).
 ...
 Axiom subgraphupdate_l : forall G v G1 x v1 l r,
  valid (imp (and (star (graph l G1)
  (mwand (graph l G) (union (ptto_node x v l r)
  (union (graph l G) (graph r G)))))
  (and (subset_reach G l G1) (and
  (eq_notreach G l G1) (and (lookup G x v l r)
  (lookup G1 x v1 l r)))))
  (union (ptto_node x v1 l r) (union (graph l G1)
  (graph r G1)))).
 ...
End Mgraphmark.
\end{lstlisting}
%% \vspace{-8pt}
\lstset{deletekeywords={Module,Type,Prop,Parameter,Axiom,End,forall}}
\caption{Coq \li{$\tx{Module Type}$} generated by HIP/SLEEK}
\label{fig:hipcoqfile}
\end{figure}

The lemmas and axioms that HIP/SLEEK has used in the verification still need to be checked.  Accordingly, HIP/SLEEK generates a Coq file with a \li{Module Type} specifying them.  The \li{Module Type} generated for \li{mark} is given in Figure~\ref{fig:hipcoqfile} to illustrate this process.  To obtain a complete verification for \li{mark}, users must build a Coq \li{Module} that satisfies \li{Mgraphmark} using definitions for the abstract relations that they think are reasonable (in particular, for the \li{mark} relation, since it is used in the specification of the algorithm).

\subsection{Automatic localizations in HIP/SLEEK}

HIP/SLEEK reasons about graph algorithms using three key ideas.  First, H/S uses fold/unfold relationships whenever it needs to reason about a recursive predicate during the entailment checking that occurs during forward reasoning. For example, to check the dereference in line \ref{ifcondmark}, the \li{x::graph<G>} predicate is unfolded to reach\footnote{We will write predicates in a more conventional mathematical style rather than the ASCII format used by H/S.}
\begin{align*}
\exists m,l,r.~ & \gamma(\li{x}) \! = \! (m,l,r) /| \null \\
& \li{x} \! |-> \! m,l,r ** \p{graph}(l, \gamma) ** \p{graph}(r, \gamma)
\end{align*}

% (\emph{e.g.} $\li{x} \mapsto m,l,r$)
Second, once HIP/SLEEK realizes that its forward reasoning needs to isolate a predicate that is $**$-shared, it uses the existential wand ``septraction'' operator~$\septraction$~(defined in Figure~\ref{fig:seplogsem}) to reach the strongest post condition.  The existential wand $--o$ is simpler to introduce than the universal one $--*$ during forward reasoning because H/S already knows $G_1$ and $L_1$ when it needs to calculate a residual frame~$R$.  For example, the precondition at line~\ref{beforemarkleft} is
\[
\begin{array}{l}
\gamma(\li{x}) = (0,\li{l},\li{r}) /| \m{mark1}(\gamma,\li{x},\gamma') /| \null \\
\quad \li{x} |-> 1,\li{l},\li{r} ** \p{graph}(\li{l}, \gamma') ** \p{graph}(\li{r}, \gamma')
\end{array}
\]
and since H/S knows the call to \li{mark(l)} requires $\p{graph}(\li{l}, \gamma')$, it can calculate the frame residue $R$ as $Q --o P$ since\footnote{We omit pure conjuncts \emph{e.g.} $\m{mark1}(\gamma,\li{x},\gamma')$ from both $P$ and $R$.}
\begin{gather*}
\overbrace{\li{x} |-> 1,\li{l},\li{r} ** \p{graph}(\li{l}, \gamma') ** \p{graph}(\li{r}, \gamma')}^P |- \overbrace{\p{graph}(\li{l}, \gamma')}^Q * \null \\
\underbrace{\Big(\!\p{graph}(\li{l}, \gamma') \! --o \! \big(\li{x} \! |-> \! 1,\!\li{l},\!\li{r}  **  \p{graph}(\li{l},\! \gamma')  **  \p{graph}(\li{r}, \!\gamma')\big)\!\Big)}_{R}
\end{gather*}
Note that in general $P |- Q * (Q --o P)$ is \textbf{not} a tautology since not every $P$ has a $Q$ ``hiding inside it''.  However, H/S's unfold of \p{graph} makes it readily apparent that $\p{graph}(l, \gamma)$ \textbf{is} inside the premise of the entailment $P$, so H/S is justified in calculating the frame $R$.

To calculate the postcondition of line~\ref{beforemarkleft}, H/S takes the residue~$R$ and $*$-combines it with the postcondition of the \li{mark(l)} call, \emph{i.e.}: % to reach% $\p{graph}(\li{l}, \gamma') /| \m{mark}(\gamma,\li{l},\gamma')$, to reach
\begin{gather*}
\big(\p{graph}(\li{l}, \gamma'')  /|  \m{mark}(\gamma',\li{l},\gamma'')\big)  *  \gamma(\li{x})  =  (0,\li{l},\li{r})  /| \null\\
\m{mark1}(\gamma,\li{x},\gamma') /| \Big(\p{graph}(\li{l}, \gamma') --o \\ \big(x |-> 1,\li{l},\li{r} ** \p{graph}(\li{l}, \gamma') ** \p{graph}(\li{r}, \gamma')\big)\Big)
\end{gather*}
%
%, where $\gamma'$ is the mathematical graph after the \texttt{mark(l)} recursive call.

The final step is to use lemmas to eliminate $\septraction$. After line~\ref{beforemarkleft} H/S uses the lemma from lines~\ref{code:hipbeginlemma}--\ref{code:hipendlemma}:
\[
\begin{array}{@{}l@{}}
\bigg(\!\Big(\!\p{graph}(l, \gamma) --o \big(x |-> m,l,r ** \p{graph}(l, \gamma) \ocon \p{graph}(r, \gamma)\big)\!\Big) \\
~ \null * \p{graph}(l, \gamma') \! /| \! \m{subset\_reach}(\gamma,l,\!\gamma') \! /| \! \m{eqnot\_reach}(\gamma,l,\!\gamma') \\
~ \null /| \gamma(x)=(m,l,r) /| \gamma'(x)=(m1,l,r)\bigg) => \\
\quad \qquad \big(x \mapsto m1,l,r \ocon \p{graph}(l, \gamma') \ocon \p{graph}(r, \gamma')\big)
\end{array}
\]
This lemma does not mention $\m{mark}$ explicitly, allowing it to be reused in other algorithms.  The connection between the \m{mark}, \m{subset\_reach}, and \m{eqnot\_reach} relations is given by the axiom on lines~\ref{code:hipmarkramconnect}--\ref{code:hipmarkramconnectend}; other (elided) lemmas connect \m{mark1} as well.  H/S must apply all of them, guided by structural matching, to eliminate the $--o$ to reach the following relatively pleasant-looking postcondition of line~\ref{beforemarkleft}
\[
\begin{array}{l}
\gamma(\li{x}) = (0,\li{l},\li{r}) /| \m{mark1}(\gamma,\li{x},\gamma') /| \m{mark}(\gamma',\li{l},\gamma'') /| \null \\
\quad \li{x} |-> 1,\li{l},\li{r} ** \p{graph}(\li{l}, \gamma'') ** \p{graph}(\li{r}, \gamma'')
\end{array}
\]
H/S now continues the verification with \li{mark(r)}.

\subsection{Additional verified examples}
\label{sec:application}

{\color{magenta}
In addition to \li{mark} for graphs, we have also verified the same program for DAGs.  And spanning...


 We have also verified \li{mark} for DAGs and \li{copy} for
graphs.  For the sake of space, we do not put these decorated program scripts here.

Unlike graph marking, the spanning tree algorithm changes the
structure of the graph, leading to a more complicated specification,
in both the pure part and the spatial part. Observe that the $\m{span}$ relation is
rather long; the $\m{e\_span}$ handles the case of either calling spanning tree or deleting an edge.
}

