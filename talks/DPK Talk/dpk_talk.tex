% !TEX TS-program = XeLaTeX

\documentclass[usenames, xcolor=dvipsnames]{beamer}
%% \documentclass[professionalfonts, xcolor=table, handout]{beamer}
%% \usepackage{pgfpages}
%% \pgfpagesuselayout{4 on 1}[a4paper,border shrink=5mm, landscape]
\usepackage{fontspec}
\usepackage{amsmath,amssymb}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\usepackage{tikz}
\usetikzlibrary{positioning, matrix, arrows.meta, shapes.geometric, calc,
  decorations.pathmorphing, decorations.pathreplacing, fit, shapes.multipart}
\usepackage{mathabx}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{fancyvrb}
\usepackage{stmaryrd}
\usepackage[absolute,overlay]{textpos}
\usepackage[export]{adjustbox} % for subfigures
\usepackage[normalem]{ulem} % for strikeout

\definecolor{lightg}{RGB}{217,232,225}
\definecolor{darkg}{RGB}{6,81,42}
\definecolor{myred}{rgb}{0.0, 0.42, 0.24}
\colorlet{mypink}{myred!50!white}
\definecolor{mymaroon}{rgb}{0.86, 0.08, 0.24}

\defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
% \setmainfont{Libertinus Serif}
% \setsansfont{Libertinus Sans}
% \setmonofont{Menlo Regular}
\usetheme{Madrid}
\useoutertheme{infolines} % Alternatively: miniframes, infolines, split
\useinnertheme{circles}

% \setbeamertemplate{enumerate item}[default]
\usecolortheme[named=myred]{structure}
% \usecolortheme{spruce}
\usefonttheme{serif}
\setbeamerfont*{frametitle}{series=\bfseries}
\setbeamercolor{alerted text}{fg=mymaroon}
\setbeamertemplate{navigation symbols}{}
\setbeamercolor{emphC}{fg=myred}
% \setbeamercolor{block title}{bg = darkg, fg=white!80}
% \setbeamercolor{block body}{bg = lightg, fg=black}
\setbeamercolor{itemize item}{fg=black}
\setbeamercolor{description item}{fg=myred}

\newcommand{\sz}{\texttt{size}}
\newcommand{\ifty}{\texttt{inf}}
\newcommand{\scon}{\mathbin{\ast}}
\usepackage{scalerel}
\renewcommand{\bigstar}{\raisebox{-0.24em}{{\scaleobj{2.5}{\scon}}}}

\newcommand{\ocon}{%
  \mathbin{\mbox{$\mathrlap{\cup}\hspace*{.15em}
      \raisebox{.01em}[0ex][0ex]{$\scon$}$\hspace*{.07em}}}}
\newcommand{\medocon}{
  \raisebox{-0.3ex}{\resizebox{0.63em}{!}{$\scon$}} \hspace{-2.4ex} \bigcup}
\newcommand{\wand}{%
 \mathrel{\mbox{$\hspace*{-0.03em}\mathord{-}\hspace*{-0.66em}
  \mathord{-}\hspace*{-0.36em}\mathord{\scon}$\hspace*{-0.005em}}}}
\newcommand{\defeq}{\mathbin{\stackrel{\Delta}{=}}}
\newcommand{\emphd}[1]{{\bfseries #1}}
\newcommand{\emphr}[2]{\alert<#1>{#2}}
\newcommand{\bracket}[1]{[#1]}
\newcommand{\hide}[1]{}
\newcommand{\braces}[1]{\color{OliveGreen}\left\{\begin{array}{l@{}} \!\!\! #1 \end{array}\right\}}

\makeatletter\let\frametextheight\beamer@frametextheight\makeatother
\newcommand\credit[1]{%
  \begin{textblock*}{\paperwidth}(0pt,\textheight)
    \raggedleft #1\hspace{.5em}
\end{textblock*}}
\newcommand{\pguards}[1]{\llbracket #1 \rrbracket}
\newcommand{\xmark}{\ding{55}}%
\newcommand{\cmark}{\ding{51}}%
\newcommand{\m}[1]{\ensuremath{\mathit{#1}}} % math font
\newcommand{\p}[1]{\ensuremath{\mathsf{#1}}} % predicate font
\newcommand{\bi}{\Leftrightarrow} % equivalence of expressions

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\setbeamertemplate{section in toc}{%
  \inserttocsectionnumber.~\inserttocsection}
\setbeamercolor{subsection in toc}{bg=white,fg=structure}
\setbeamertemplate{subsection in toc}{%
  \hspace{1.2em}{\rule[0.3ex]{3pt}{3pt}}~\inserttocsubsection\par}


\title[Verifying Dijkstra, Prim, Kruskal]{Functional Correctness of Dijkstra's, Prim's, \\ and Kruskal's Algorithms in C}
\author[]{\underline{Anshuman Mohan} \\ Leow Wei Xiang \\ Aquinas Hobor}
%\institute[NUS]{\includegraphics[height=0.12\textwidth]{NUS_logo_full-horizontal.jpg}}
  \date[]{Cornell PLDG \\ \today}

\begin{document}
\begin{frame}[plain]
  \titlepage
\end{frame}

\begingroup
    \AtBeginSection[]{}
\section{CertiGraph: Motivation and Overview}
\endgroup

\begin{frame}{Motivation: A precondition for Dijkstra}

Longest optimal path has \texttt{size-1} links \\
\pause so $0 \le \texttt{elabel}(\gamma, \m{e}) \le \lfloor\texttt{MAX/(size-1)}\rfloor$ 

\bigskip \pause
\texttt{MAX} = 7, \texttt{size} = 3, so $0 \le \texttt{elabel}(\gamma, \m{e}) \le 3$.

\bigskip

{\centering
\begin{tikzpicture}
[vad/.style={rectangle, fill=black, inner sep=0pt, minimum size=4pt},
 inf/.style={circle, draw=myred, thick, inner sep=0pt, minimum size=4pt},
 inv/.style={circle, fill=myred, draw=myred, thick, inner sep=0pt, minimum size=4pt},
 ->/.style={thick, arrows={-Stealth}}]

  \node at (1.5,-0.2) {3};
  \node at (4.9,-0.2) {3};
  \node at (6,-0.6) {3};


\uncover<3>{
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.7, 0.3) {\small B @ \ifty};
\node at (6.8, 0.3) {\small C @ \ifty}; 
  \node[vad] (A) at (0,0) {};
  \node[inf] (B) [right = 3 of A] {};
  \node[inf] (C) [right = 3 of B] {};
  \draw [->, dashed, myred] (A) -- (B);
  \draw [->, dashed, myred] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);}
 
\uncover<4>{
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.7, 0.3) {\small B @ \ifty};
\node at (6.8, 0.3) {\small C @ \ifty};  
  \node[vad] (A) at (0,0) {};
  \node[inv] (B) [right = 3 of A] {};
  \node[inf] (C) [right = 3 of B] {};
  \draw [->, dashed, myred] (A) -- (B);
  \draw [->, dashed, myred] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);}

\uncover<5>{
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.5, 0.3) {\small B @ 3};
\node at (6.8, 0.3) {\small C @ \ifty};  
  \node[vad] (A) at (0,0) {};
  \node[vad] (B) [right = 3 of A] {};
  \node[inf] (C) [right = 3 of B] {};
  \draw [->] (A) -- (B);
  \draw [->, dashed, myred] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);
  }

\uncover<6>{ 
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.5, 0.3) {\small B @ 3};
\node at (6.8, 0.3) {\small C @ \ifty};  
  \node[vad] (A) at (0,0) {};
  \node[vad] (B) [right = 3 of A] {};
  \node[inv] (C) [right = 3 of B] {};
  \draw [->] (A) -- (B);
  \draw [->, dashed, myred] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);
}

\uncover<7>{ 
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.5, 0.3) {\small B @ 3};
\node at (6.6, 0.3) {\small C @ 6};  
  \node[vad] (A) at (0,0) {};
  \node[vad] (B) [right = 3 of A] {};
  \node[vad] (C) [right = 3 of B] {};
  \draw [->] (A) -- (B);
  \draw [->] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);
}

\uncover<8>{ 
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.5, 0.3) {\small B @ 3};
\node at (6.6, 0.3) {\small C @ 6};  
\node at (5, -1.5) {if $3 > 9$ then relax C $\leadsto$ B};
  \node[vad] (A) at (0,0) {};
  \node[vad] (B) [right = 3 of A] {};
  \node[vad] (C) [right = 3 of B] {};
  \draw [->] (A) -- (B);
  \draw [->] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);
}

\uncover<9>{ 
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.5, 0.3) {\small B @ 3};
\node at (6.6, 0.3) {\small C @ 6};  
\node at (5, -1.5) {if $3 > \alert{1}$ then relax C $\leadsto$ B};
  \node[vad] (A) at (0,0) {};
  \node[vad] (B) [right = 3 of A] {};
  \node[vad] (C) [right = 3 of B] {};
  \draw [->] (A) -- (B);
  \draw [->] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);
}

\uncover<10->{ 
\node at (0.3, 0.3) {\small A @ 0};
\node at (3.5, 0.3) {\small B @ \alert{1}};
\node at (6.6, 0.3) {\small C @ 6}; 
\node at (5, -1.5) {if $3 > 1$ then \alert{relax C $\leadsto$ B}};
  \node[vad] (A) at (0,0) {};
  \node[vad] (B) [right = 3 of A] {};
  \node[vad] (C) [right = 3 of B] {};
  \draw [->] (A) -- (B);
  \draw [->] (B) -- (C);
  \draw [->, dashed, myred] (C.south) .. controls ++(0, -1) .. (B);
}

\end{tikzpicture}

}
\hide{
\bigskip

\uncover<11->{
One solution: Conservatively set upper bound to $\lfloor\texttt{MAX/size}\rfloor$}

\bigskip

\uncover<12->{
Max path cost is then  
$\lfloor\texttt{MAX/size}\rfloor$ \texttt{ * (size-1) = MAX - }$\lfloor\texttt{MAX/size}\rfloor$}
}
\end{frame}

\begin{frame}{Motivation: A precondition for Dijkstra}

There are many ways to fix this!
\\ \hspace{1em} Refactor troublesome addition as subtraction
\\ \hspace{1em} Never look back into optimized part
\\ \hspace{1em} Your suggestion here

\bigskip

\pause Sadly, intuition supports \texttt{inf = MAX} \\
and bugs such as this one are often overlooked

\end{frame}

\begin{frame}{CertiGraph: problem scope}
\includegraphics[scale=0.09]{vst_logo}
\hspace{2em} \includegraphics[scale=0.12]{compcert_logo}
\hspace{2em} \includegraphics[scale=0.2]{paper_screen}

\bigskip
VST + CompCert + \underline{CertiGraph}

\bigskip
\hspace{1em}Verify executable code
\\\hspace{1em}against realistic specifications
\\\hspace{1em}expressed with mathematical graphs

\end{frame}

\begin{frame}{CertiGraph: workflow}
  \input{workflow.tex}
\end{frame}

\begin{frame}{CertiGraph: math graph architecture}
  
\centering
\colorbox{lightg}{\scalebox{.85}{\input{architecture.tex}}}
  
\vspace{1em}
($\mathcal{V}$, $\mathcal{E}$, \texttt{vvalid}, \texttt{evalid},
\texttt{src}, \texttt{dst}, \texttt{vlabel}, \texttt{elabel}, 
\texttt{sound})
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Mathematical Adjacency Matrices}

\begin{frame}{Constraining a representable graph}
What graphs are representable as adjacency matrices? \\
\pause \bigskip
\vspace{-2em}
\begin{align*}
\Big(\hspace{0.5em}\mathcal{V}&=\mathbb{Z}, \\
\mathcal{E}&=\mathcal{V} \times \mathcal{V}, \\
\texttt{vvalid}&=\lambda v.~0 \le v < \texttt{size}, \\ 
\texttt{evalid}&=\ldots, \\
\texttt{src}&=\m{fst}, \\
\texttt{dst}&=\m{snd}, \\
\texttt{vlabel}&=\ldots, \\
\texttt{elabel}&=\ldots, \\
\alert{\texttt{sound}}&=\alert{\texttt{SoundAdjMat}}\hspace{0.5em}\Big) 
\end{align*}

\end{frame}

\begin{frame}[fragile]{A unified, reusable soundness condition}

\begin{Verbatim}
Class SoundAdjMat size inf g := {
  sr: 0 < size <= MAX;
  ir: MIN <= inf <= MAX; 
  vm: forall v, vvalid g v <-> 0 <= v < size;
  em: forall e, evalid g e <-> 
                (MIN <= elabel g e <= MAX /\ 
                 elabel g e < inf);
  iew: forall e, ~evalid g e <-> elabel g e = inf;
  fin: FiniteGraph g
}.
\end{Verbatim}

\pause \bigskip

Need more?
\begin{Verbatim}
Class SoundDijk size inf g := {
  sadjmat: SoundAdjMat size inf g;
  further: ...
}
\end{Verbatim}

\end{frame}


\section{Spatial Representations in Separation Logic}

\begin{frame}{Laying out graphs in memory}
We support three flavors of adjacency matrix: \\
\hspace{1em}stack-allocated 2D~array \texttt{int~graph[size][size]} \\
\hspace{1em}stack-allocated 1D~array \texttt{int~graph[size$\times$size]} \\
\hspace{1em}heap-allocated 2D~array \texttt{int~**graph}

\bigskip \pause
The first, in memory: 
\vspace{-0.8em}
\begin{equation*}
\begin{split}
\m{arr\_addr} (\m{ptr}, \m{i},\texttt{size}) \defeq~&
  \m{ptr} + (\m{i} \times \hide{\texttt{sizeof}(\texttt{int}) \times} \texttt{size}) \\
\mathsf{array}(\m{ptr},\m{list}) \defeq~& \underset{\m{i}\hspace{0.1em} \in [0, \lvert\m{list}\rvert)}{\bigstar} (\m{ptr} + \m{i}) \mapsto \m{list}[\m{i}]) \\
\p{arr\_rep}(\gamma, \m{i}, \m{ptr}) \defeq~& \texttt{let }\m{row} \texttt{ := }\mathsf{graph2mat}(\gamma)[\m{i}] \texttt{ in } \\
&\mathsf{array}(\m{arr\_addr}(\m{ptr},\m{i},\lvert\m{row}\rvert), \m{row}) \\
\vspace{1em}
\p{adjmat\_rep}(\gamma, \m{g\_addr}, \_) \defeq~& \underset{\m{v}\hspace{0.1em} \in \gamma}{\bigstar} \p{arr\_rep}(\gamma, \m{v}, \m{g\_addr})
\end{split}
\end{equation*}

\end{frame}


\section{Shortest Path: Dijkstra}

\begin{frame}[fragile]{\texttt{SoundDijk} and Spatial Representation of DijkGraph}
\begin{Verbatim}
Class SoundDijk size inf g := {
  sadjmat: SoundAdjMat size inf g;
  veb: forall e, evalid g e ->
                 0 <= elabel g e <= (MAX / size) - 1;
  ifr: (MAX / size) - 1 < inf <= MAX - (MAX / size) + 1
}.
\end{Verbatim}

\bigskip \pause

Nothing fancy spatially, use \p{adjmat\_rep} wholesale \\
We verify Dijkstra 3 times: \\
\hspace{1em}reuse math proof, 1\% fiddles in verif

\end{frame}

\begin{frame}[fragile]{Code and Specification}

\begin{Verbatim}
void dijkstra (int **graph, int src, int *dist, 
               int *prev, int size, int inf {
\end{Verbatim}
$\braces{\p{AdjMat}(\gamma) *
\mathsf{array}(\texttt{dist}, \_) * \mathsf{array}(\texttt{prev}, \_)}$
\pause
\begin{Verbatim}
 int pq = init(size); int i, j, u, cost;
 for (i = 0; i < size; i++)
 {  dist[i] = inf; prev[i] = inf; push(i, inf, pq);  }
 dist[src] = 0; prev[src] = src; dec_key(src, 0, pq);
\end{Verbatim}
\pause
$\braces{{\color{mymaroon}\exists \m{dist}, \m{prev}, \m{popped}}.~\p{AdjMat}(\gamma) * {\color{mymaroon}\p{PQ}(\texttt{pq})} * \mathsf{array}(\texttt{dist},{\color{mymaroon}\m{dist}}) * \null \\ \mathsf{array}(\texttt{prev}, {\color{mymaroon}\m{prev}}) \wedge
{\color{mymaroon}\m{dijk\_correct}(\gamma,\texttt{src},\m{popped},\m{prev},\m{dist})}}$
\begin{Verbatim}
 // big while loop
\end{Verbatim}
\end{frame}

\begin{frame}[fragile]{Code and Specification}
$\braces{\exists \m{dist}, \m{prev}, \m{popped}.~\p{AdjMat}(\gamma) * \p{PQ}(\texttt{pq}) * \mathsf{array}(\texttt{dist},\m{dist}) * \null \\ \mathsf{array}(\texttt{prev}, \m{prev}) \wedge
\m{dijk\_correct}(\gamma,\texttt{src},\m{popped},\m{prev},\m{dist})}$
\pause
\begin{Verbatim}
 while (!pq_emp(pq)) {
  u = popMin(pq);
\end{Verbatim}
\pause 
$\color{OliveGreen}//~\braces{{\color{mymaroon}\exists \m{dist'}, \m{prev'}, \m{popped'}, \m{i}}.~\p{AdjMat}(\gamma) * \p{PQ}(\texttt{pq}) * \null \\
\mathsf{array}(\texttt{dist},\m{\color{mymaroon}dist'}) * \mathsf{array}(\texttt{prev}, \m{\color{mymaroon}prev'}) \wedge \null \\
{\color{mymaroon}\m{dijk\_correct\_weak}(\gamma, \texttt{src}, \m{popped'}, \m{prev'}, \m{dist'}, \m{i}, \texttt{u})}}$
\pause
\begin{Verbatim}
  for (i = 0; i < size; i++) {
  cost = getCell(graph, u, i);
  if (cost < inf) {
   if (dist[i] > dist[u] + cost) {
    dist[i] = dist[u] + cost; prev[i] = u;
    dec_key(i, dist[i], pq); 
 }}} // for
\end{Verbatim}
\pause
$\braces{{\color{mymaroon}\exists \m{dist''}, \m{prev''}}.~\p{AdjMat}(\gamma) * \p{PQ}(\texttt{pq}) *
  \mathsf{array}(\texttt{dist},\m{\color{mymaroon}dist''}) * \null \\
  \mathsf{array}(\texttt{prev}, \m{\color{mymaroon}prev''}) \wedge
  {\color{mymaroon}\m{dijk\_correct}(\gamma, \texttt{src}, \m{popped'}, \m{prev''}, \m{dist''})}}$
\end{frame}

\begin{frame}[fragile]{Code and Specification}
$\braces{\exists \m{dist}, \m{prev}, \m{popped}.~\p{AdjMat}(\gamma) * \p{PQ}(\texttt{pq}) * \mathsf{array}(\texttt{dist},\m{dist}) * \null \\ \mathsf{array}(\texttt{prev}, \m{prev}) \wedge
\m{dijk\_correct}(\gamma,\texttt{src},\m{popped},\m{prev},\m{dist})}$
\begin{Verbatim}
 while (!pq_emp(pq)) {
  u = popMin(pq);
  for (i = 0; i < size; i++) {
  cost = getCell(graph, u, i);
  if (cost < inf) {
   if (dist[i] > dist[u] + cost) {
    dist[i] = dist[u] + cost; prev[i] = u;
    dec_key(i, dist[i], pq); 
  }}} // for
\end{Verbatim}
\pause
\begin{Verbatim}
 } // while
\end{Verbatim}
\pause
$\color{OliveGreen}//~\braces{{\color{mymaroon}\exists \m{dist^{\circ}}, \m{prev^{\circ}}, \m{popped^{\circ}}}.~\p{AdjMat}(\gamma) * \p{PQ}(\texttt{pq}) * \null \\
\mathsf{array}(\texttt{dist},\m{\color{mymaroon}dist^{\circ}}) * 
\mathsf{array}(\texttt{prev}, \m{\color{mymaroon}prev^{\circ}}) \wedge \null \\
{\color{mymaroon}\m{all\_popped(popped^{\circ})}} \wedge
{\color{mymaroon}\m{dijk\_correct}(\gamma,\texttt{src},\m{popped^{\circ}},\m{prev^{\circ}},\m{dist^{\circ}})}}$
\pause
\begin{Verbatim}
 freePQ (pq); return;
}
\end{Verbatim}
\end{frame}


\begin{frame}{dijk\_correct}

\begin{equation*}
\begin{split}
\m{dijk\_correct}(\gamma, \m{src}, &\m{popped}, \m{prev}, \m{dist}) \; \defeq \; \\
\forall \m{d}.~vvalid(\gamma, \m{d}) \Rightarrow \\
\alert<2>{\big( \m{d} \in \m{popped} \; \Rightarrow} \; & \\ 
& \hspace{-5em} \exists \m{path}.~\m{path\_correct}(\gamma, \m{prev}, \m{path}, \m{src}, \m{d}) \wedge \null \\
& \hspace{-5em} \m{path\_globally\_optimal}(\gamma, \m{dist}, \m{path}) \alert<2>{\big)} \wedge \null \\
\alert<3>{\big( \m{dist}[\m{d}] < \ifty \; \Rightarrow} \; & \\ 
& \hspace{-5em} \texttt{let }\m{m} \texttt{ := } \m{prev}[\m{d}] \texttt{ in } \m{m} \in \m{popped}(\m{priq}) \wedge \null \\
& \hspace{-5em} \forall \m{m'} \in \m{popped}(\m{priq}).~\m{cost}(\m{p2m} \texttt{+} (m, d)) \le \m{cost}(\m{p2m'} \texttt{+} (m', d)) \alert<3>{\big)} \wedge \null \\
\alert<4>{\big( \m{dist}[\m{d}] = \ifty \; \Rightarrow} \; & \\ 
& \hspace{-5em} \forall \m{m} \in \m{popped}(\m{priq}).~\m{cost}(\m{p2m} \texttt{+} (m, d)) = \ifty \alert<4>{\big)}
\end{split}
\end{equation*}

\end{frame}


\newcommand{\s}{11}
\begin{frame}{Key Transformation: Growing the Subgraph}

\begin{center}
\begin{adjustbox}{scale=0.50}
\begin{tikzpicture}[on grid,
  popped/.style={rounded corners=15pt, line width=1pt, draw, fill=myred},
  fringe/.style={rounded corners=15pt, line width=1pt, draw, fill=mypink},
  popping/.style={rounded corners=15pt, line width=1pt, draw, dashed, fill=mymaroon},
  unseen/.style={rounded corners=15pt, line width=1pt, draw}]
  \uncover<1>{
  \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
  \draw[fringe] (1.5,1.5) -- (9.5,1.5) -- (9.5,9.5) -- (1.5,9.5) -- cycle;
  \draw[popped] (3,3) -- (8,3) -- (6,6) -- (3,8) -- cycle;
  \node at (1.4,1) {\Huge d$_3$};   
  \node at (2.9,2.5) {\Huge d$_2$};   
  \node at (4.4,4) {\Huge \color{white}d$_1$}; 
  \node at (6.6,7) {\Huge u};}
  \uncover<2>{
    \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
  \draw[fringe] (1.5,1.5) -- (9.5,1.5) -- (9.5,9.5) -- (1.5,9.5) -- cycle;
  \draw[popping] (3,3) -- (8,3) -- (8,8) -- (3,8) -- cycle;
  \draw[popped] (3,3) -- (8,3) -- (6,6) -- (3,8) -- cycle;
  \node at (1.4,1) {\Huge d$_3$};   
  \node at (2.9,2.5) {\Huge d$_2$};   
  \node at (4.4,4) {\Huge \color{white}d$_1$}; 
  \node at (6.6,7) {\Huge u}; }
  \uncover<3>{
    \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
  \draw[fringe] (1.5,1.5) -- (9.5,1.5) -- (9.5, 4.0) -- (10.5, 4.0) -- (10.5, 5.0) -- (9.5, 5.0) -- (9.5,9.5) -- (6.5, 9.5) -- (6.5, 10.5) -- (5.5, 10.5) -- (5.5, 9.5) -- (1.5,9.5) -- cycle;
  \draw[popped] (3,3) -- (8,3) -- (8,8) -- (3,8) -- cycle;
  \node at (1.4,1) {\Huge d$_3$};   
  \node at (2.9,2.5) {\Huge d$_2$};   
  \node at (4.4,4) {\Huge \color{white}d$_1$}; 
  \node at (6.6,7) {\Huge \color{white}u}; }
\end{tikzpicture}
\end{adjustbox}
\end{center}
\end{frame}

\begin{frame}{dijk\_correct\_weak}

\begin{equation*}
\begin{split}
&\hspace{-1em}\m{dijk\_correct\_weak}(\gamma, \m{src}, \m{popped}, \m{prev}, \m{dist}, \m{i}, \m{u}) \; \defeq \; \forall \m{d}.~ \\
&\alert<2>{\big( vvalid(\gamma, \m{d}) \; \Rightarrow} \; \m{d} \in \m{popped} \; \Rightarrow \; \ldots \alert<2>{\big)} \wedge \\
&\alert<2>{\Big( 0 \le dst < i \; \Rightarrow} \; 
\big( \m{dist}[\m{d}] < \ifty \; \Rightarrow \ldots \big) \wedge
\big( \m{dist}[\m{d}] = \ifty \; \Rightarrow \ldots \big) \alert<2>{\Big)} \wedge \null \\
&\alert<3>{\Big( i \le dst < size \; \Rightarrow} \; \null \\
&\hspace{1em}\big( \m{dist}[\m{d}] < \ifty \; \Rightarrow \ldots \alert<4>{\wedge m \neq u \wedge m' \neq u} \big) \wedge \null \\
&\hspace{1em}\big( \m{dist}[\m{d}] = \ifty \; \Rightarrow \ldots \alert<4>{\wedge m \neq u} \big) \alert<3>{\Big)} \\
\end{split}
\end{equation*}

\end{frame}

\begin{frame}{Postcondition}

\begin{center}
\begin{adjustbox}{scale=0.50}
\begin{tikzpicture}[on grid,
  popped/.style={rounded corners=15pt, line width=1pt, draw, fill=myred},
  fringe/.style={rounded corners=15pt, line width=1pt, draw, fill=mypink},
  popping/.style={rounded corners=15pt, line width=1pt, draw, dashed, fill=mymaroon},
  unseen/.style={rounded corners=15pt, line width=1pt, draw}]
  \uncover<1>{
    \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
  \draw[fringe] (1.5,1.5) -- (9.5,1.5) -- (9.5, 4.0) -- (10.5, 4.0) -- (10.5, 5.0) -- (9.5, 5.0) -- (9.5,9.5) -- (6.5, 9.5) -- (6.5, 10.5) -- (5.5, 10.5) -- (5.5, 9.5) -- (1.5,9.5) -- cycle;
  \draw[popped] (3,3) -- (8,3) -- (8,8) -- (3,8) -- cycle;
  \node at (1.4,1) {\Huge d$_3$};   
  \node at (2.9,2.5) {\Huge d$_2$};   
  \node at (4.4,4) {\Huge \color{white}d$_1$}; }
  \uncover<2>{
    \draw[unseen] (0,0) -- (\s,0) -- (\s,\s) -- (0,\s) -- cycle;
  \draw[popped] (1.5,1.5) -- (3.5, 1.5) -- (3.5, 0) -- (7.5, 0) -- (7.5, 1.5) -- (9.5,1.5) -- (9.5, 4.0) -- (11, 4.0) -- (11, 8.0) -- (9.5, 8.0) -- (9.5,9.5) -- (6.5, 9.5) -- (6.5, 11) -- (0, 11) -- (0, 3) -- (1.5, 3) -- cycle;
  \node at (1.4,1) {\Huge d$_3$};   
  \node at (4.4,4) {\Huge \color{white}d$_1$}; } 
\end{tikzpicture}
\end{adjustbox}
\end{center}
\end{frame}

\section{Undirectedness in a Directed World}

\begin{frame}[fragile]{Weakening}

Build undirected idioms:

\begin{Verbatim}
Definition adj_edge g e u v :=
  ((src g e = u /\ dst g e = v) \/ 
   (src g e = v /\ dst g e = u)).
\end{Verbatim}

Plus \texttt{upath}, \texttt{connected}, \emph{etc.}

\end{frame}

\begin{frame}{Extending to undirectedness}

Consider the AdjMat representation of a directed graph: \\
\centering
\includegraphics[scale=0.7]{directed}

\end{frame}

\begin{frame}{Extending to undirectedness}

Versus the AdjMat representation of an undirected graph: \\
\centering
\includegraphics[scale=0.7]{undirected}

\end{frame}

\begin{frame}[fragile]{Extending to undirectedness}

Prevent double-counting:
\begin{Verbatim}
Class SoundUAdjMat (g: UAdjMatLG) := {
  sadjmat: @SoundAdjMat size inf g;
  undirec: forall e, evalid g e -> src g e <= dst g e;
}.
\end{Verbatim}
\end{frame}

\begin{frame}{Recall: Math Graph Architecture}
  \centering
  \colorbox{lightg}{\input{architecture.tex}}
\end{frame}

\section{Minimum Spanning Forest: Prim and Kruskal}

\begin{frame}{Prim: minimum spanning \sout{trees} forests}
\end{frame}

\begin{frame}{Kruskal: EdgeList Representation}
Extend spatial support to accommodate EdgeList representation

\bigskip

The double-counting restriction must be lifted: \\
\hspace{1em}an EdgeList-represented graph can have bona fide multi-connections

\bigskip

But the undirected idioms carry over
\end{frame}

\begin{frame}{Kruksal: Layering Undirectedness Atop Union-Find}
  Consider performing \texttt{union u w} \\
  Note: \texttt{reachable} is directed, \texttt{connected} is undirected \\
  \vspace{2em}
  \centering
  \input{bitree_bigraph.tex}
\end{frame}

\begin{frame}{A Note on Modularity}
\centering
  \includegraphics[scale=0.33]{key}
\end{frame}

\begin{frame}{A Note on Modularity}
\centering
  \includegraphics[scale=0.33]{simple}
\end{frame}

\begin{frame}{A Note on Modularity}
\centering
  \includegraphics[scale=0.33]{dijk_prim}
\end{frame}

\begin{frame}{A Note on Modularity}
\centering
  \includegraphics[scale=0.33]{krus}
\end{frame}

\hide{
\begin{frame}{Possible Next Steps}
Verify PQ with \texttt{decrease-key} \\
AdjList representation for Dijkstra, Prim \\
Plug into verified \texttt{malloc} \\
Floyd-Warshall using AdjMat \\
Bellman-Ford using EdgeList \\

\flushright \pause
\includegraphics[scale=0.035]{sunset} \\
\vspace{-2em}{\color{white}Thanks!}\hspace{1em}
\end{frame}
}%end hide
\end{document}
